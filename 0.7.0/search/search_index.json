{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"","boost":2},{"location":"#quick-start","title":"Quick Start","text":"<p>Welcome to libdebug! This powerful Python library can be used to debug your binary executables programmatically, providing a robust, user-friendly interface. Debugging multithreaded applications can be a nightmare, but libdebug has you covered. Hijack, and manage signals and syscalls with a simple API.</p> <p>Supported Systems</p> <p>libdebug currently supports Linux under the x86_64 and AArch64 architectures. Other operating systems and architectures are not supported at this time.</p>","boost":2},{"location":"#dependencies","title":"Dependencies","text":"<p>To install libdebug, you first need to have some dependencies that will not be automatically resolved. These dependencies are libraries, utilities and development headers which are required by libdebug to compile its internals during installation.</p>  Ubuntu Debian Arch Linux Fedora <pre><code>sudo apt install -y python3 python3-dev libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg\n</code></pre> <pre><code>sudo apt install -y python3 python3-dev libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg\n</code></pre> <pre><code>sudo pacman -S python libelf libdwarf gcc make debuginfod\n</code></pre> <pre><code>sudo dnf install -y python3 python3-devel kernel-devel binutils-devel libdwarf-devel\n</code></pre> <p>Is your distro missing?</p> <p>If you are using a Linux distribution that is not included in this section, you can search for equivalent packages for your distro. Chances are the naming convention of your system's repository will only change a prefix or suffix.</p>","boost":2},{"location":"#installation","title":"Installation","text":"<p>Installing libdebug once you have dependencies is as simple as running the following command:</p> stabledevelopment <pre><code>python3 -m pip install libdebug\n</code></pre> <pre><code>python3 -m pip install git+https://github.com/libdebug/libdebug.git@dev\n</code></pre> <p>If you want to test your installation when installing from source, we provide a suite of tests that you can run:</p> Testing your installation<pre><code>cd test\npython run_suite.py\n</code></pre> <p>Note</p> <p>The test folder includes the <code>Makefile</code> that was used to build the required binaries for transparency. However, the compiled binaries may differ due to scheduling, hardware, and compiler versions. Some tests have hardcoded absolute addresses and will likely fail as a result.</p>","boost":2},{"location":"#your-first-script","title":"Your First Script","text":"<p>Now that you have libdebug installed, you can start using it in your scripts. Here is a simple example of how to use libdebug to debug a binary:</p> **libdebug**'s Hello World!<pre><code>from libdebug import debugger\n\nd = debugger(\"./test\") # (1)\n\n# Start debugging from the entry point\nd.run() # (2)\n\nmy_breakpoint = d.breakpoint(\"function\") # (3)\n\n# Continue the execution until the breakpoint is hit\nd.cont() # (4)\n\n# Print RAX\nprint(f\"RAX is {hex(d.regs.rax)}\") # (5)\n</code></pre> <ol> <li>A debugger is created for the <code>test</code> executable</li> <li>The process is spawned and the entry point is reached</li> <li>A breakpoint is placed at the symbol <code>&lt;function&gt;</code> in the binary</li> <li>A continuation command is issued, execution resumes</li> <li>The value of the RAX register is read and printed</li> </ol>","boost":2},{"location":"#conflicts-with-other-python-packages","title":"Conflicts with other Python packages","text":"<p>Using pwntools alongside libdebug</p> <p>The current version of libdebug is incompatible with pwntools.</p> <p>While having both installed in your Python environment is not a problem, starting a process with pwntools in a libdebug script will cause unexpected behaviors as a result of some race conditions.</p> <p>Examples of some known issues include:</p> <ul> <li><code>ptrace</code> not intercepting SIGTRAP signals when the process is run with pwntools. This behavior is described in  Issue #48.</li> <li>Attaching libdebug to a process that was started with pwntools with <code>shell=True</code> will cause the process to attach to the shell process instead. This behavior is described in  Issue #57.</li> </ul>","boost":2},{"location":"#cite-us","title":"Cite Us","text":"<p>Need to cite libdebug in your research? Use the following BibTeX entry:</p> <pre><code>@software{libdebug_2024,\n    title = {libdebug: {Build} {Your} {Own} {Debugger}},\n    copyright = {MIT Licence},\n    url = {https://libdebug.org},\n    publisher = {libdebug.org},\n    author = {Digregorio, Gabriele and Bertolini, Roberto Alessandro and Panebianco, Francesco and Polino, Mario},\n    year = {2024},\n    doi = {10.5281/zenodo.13151549},\n}\n</code></pre>","boost":2},{"location":"basics/command_queue/","title":"The Command Queue","text":"<p>All internal libdebug operations resulting from a command are inserted into a queue and executed according to a first-in-first-out (FIFO) policy. This ensures that commands are executed in the order they are issued. The command queue is automatically polled for new commands when the process is not running as a result of a stopping event.</p> <p>In the following example, the content of the <code>RAX</code> register is printed after the program hits the breakpoint or stops for any other reason:</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\n\nd.breakpoint(\"func\")\n\nd.cont()\n\nprint(f\"RAX: {hex(d.regs.rax)}\")\n</code></pre>","boost":4},{"location":"basics/command_queue/#asap-polling","title":"ASAP Polling","text":"<p>If you want the command in the queue to be polled As Soon As Possible (ASAP) instead of waiting for a stopping event, you can specify it when creating the Debugger object. In this mode, the debugger will stop the process and issue the command as it runs your script. The following script has the same behavior as the previous one, using the ASAP polling option:</p> <pre><code>d = debugger(\"program\", auto_interrupt_on_command=True)\n\nd.run()\n\nd.breakpoint(\"func\")\n\nd.cont()\nd.wait()\n\nprint(f\"RAX: {hex(d.regs.rax)}\")\n</code></pre> <p>In this case, the <code>wait()</code> method is used to wait for the stopping event (in this case, a breakpoint). Read more about the <code>wait()</code> method in the section dedicated to control flow commands.</p> <p>Unstable Debugging</p> <p>The ASAP polling mode is not recommended for debugging. It can lead to non-deterministic behavior and may be frustrating to work with. It is recommended to use the ASAP polling mode only when necessary and to avoid it whenever possible.</p>","boost":4},{"location":"basics/control_flow_commands/","title":"Control Flow Commands","text":"<p>Control flow commands allow you to set step through the code, stop execution and resume it at your pleasure. </p>","boost":4},{"location":"basics/control_flow_commands/#stepping","title":"Stepping","text":"<p>A basic feature of any debugger is the ability to step through the code. libdebug provides several methods to step, some of which will be familiar to users of other debuggers.</p>","boost":4},{"location":"basics/control_flow_commands/#single-step","title":"Single Step","text":"<p>The <code>step()</code> command executes the instruction at the instruction pointer and stops the process. When possible, it uses the hardware single-step feature of the CPU for better performance.</p> <p>Function Signature</p> <pre><code>d.step()\n</code></pre>","boost":4},{"location":"basics/control_flow_commands/#next","title":"Next","text":"<p>The <code>next()</code> command executes the instruction at the instruction pointer and stops the process. If the instruction is a function call, it will execute the whole function and stop at the next instruction. In other debuggers, this command is known as \"step over\".</p> <p>Please note that the <code>next()</code> command resumes the execution of the program if the instruction is a function call. This means that the debugger can encounter stopping events in the middle of the function, causing the command to return before the function finishes.</p> <p>Function Signature</p> <pre><code>d.next()\n</code></pre> <p>Damn heuristics!</p> <p>The <code>next()</code> command uses heuristics to determine if the instruction is a function call and to find its end. This means that the command may not work as expected in some cases (e.g. tail-calls, non-returning calls, broken stack frame).</p>","boost":4},{"location":"basics/control_flow_commands/#step-until","title":"Step Until","text":"<p>The <code>step_until()</code> command executes single steps until a specific address is reached. Optionally, you can also limit steps to a maximum count (default value is -1, meaning no limit).</p> <p>Function Signature</p> <pre><code>d.step_until(position, max_steps=-1, file='hybrid') \n</code></pre> <p>The file parameter can be used to specify the choice on relative addressing. Refer to the memory access section for more information on addressing modes.</p>","boost":4},{"location":"basics/control_flow_commands/#continuing","title":"Continuing","text":"<p>The <code>cont()</code> command continues the execution.</p> <p>Function Signature</p> <pre><code>d.cont()\n</code></pre> <p>Script execution</p> <p>Please note that, after resuming execution of the tracee process, the script will continue to run. This means that the script will not wait for the process to stop before continuing with the rest of the script. If the next command is a libdebug command that requires the process to be stopped, the script will then wait for a stopping event before executing that command.</p> <p>For example, in the following script, libdebug will not wait for the process to stop before checking d.dead. To change this behavior, you can use the <code>wait()</code> command right after the <code>cont()</code>. <pre><code>from libdebug import debugger\n\nd = debugger(\"program_that_dies_tragically\")\n\nd.run()\n\nd.cont()\n\nif d.dead:\n    print(\"The program is dead!\")\n</code></pre></p>","boost":4},{"location":"basics/control_flow_commands/#the-wait-method","title":"The <code>wait()</code> Method","text":"<p>The <code>wait()</code> command is likely the most important in libdebug. Loved by most and hated by many, it instructs the debugger to wait for a stopping event before continuing with the execution of the script.</p> <p>Example</p> <p>In the following script, libdebug will wait for the process to stop before printing \"provola\". <pre><code>from libdebug import debugger\n\nd = debugger(\"program_that_dies_tragically\")\n\nd.run()\n\nd.cont()\nd.wait()\n\nprint(\"provola\")\n</code></pre></p>","boost":4},{"location":"basics/control_flow_commands/#interrupt","title":"Interrupt","text":"<p>You can manually issue a stopping signal to the program using the <code>interrupt()</code> command. Clearly, this command is issued as soon as it is executed within the script.</p> <p>Function Signature</p> <pre><code>d.interrupt()\n</code></pre>","boost":4},{"location":"basics/control_flow_commands/#finish","title":"Finish","text":"<p>The <code>finish()</code> command continues execution until the current function returns or a breakpoint is hit. In other debuggers, this command is known as \"step out\".</p> <p>Function Signature</p> <pre><code>d.finish(heuristic='backtrace')\n</code></pre> <p>Damn heuristics!</p> <p>The <code>finish()</code> command uses heuristics to determine the end of a function. While libdebug allows to choose the heuristic, it is possible that none of the available options work in some specific cases. (e.g. tail-calls, non-returning calls).</p>","boost":4},{"location":"basics/control_flow_commands/#available-heuristics","title":"Available Heuristics","text":"<p>The <code>finish()</code> command allows you to choose the heuristic to use. If you don't specify any, the <code>\"backtrace\"</code> heuristic will be used. The following heuristics are available:</p> Heuristic Description <code>backtrace</code> The <code>backtrace</code> heuristic uses the return address on the stack function frame to determine the end of the function. This is the default heuristic but may fail in case of broken stack, rare execution flows, and obscure compiler optimizations. <code>step-mode</code> The <code>step-mode</code> heuristic uses repeated single steps to execute instructions until a <code>ret</code> instruction is reached. Nested calls are handled, when the calling convention is respected. This heuristic is slower and may fail in case of rare execution flows and obscure compiler optimizations.","boost":4},{"location":"basics/detach_and_gdb/","title":"Detach and GDB Migration","text":"<p>In libdebug, you can detach from the debugged process and continue execution with the <code>detach()</code> method.</p> <p>Function Signature</p> <pre><code>d.detach()\n</code></pre> <p>Detaching from a running process</p> <p>Remember that detaching from a process is meant to be used when the process is stopped. If the process is running, the command will wait for a stopping event. To forcibly stop the process, you can use the <code>interrupt()</code> method before migrating.</p>","boost":4},{"location":"basics/detach_and_gdb/#gdb-migration","title":"GDB Migration","text":"<p>If at any time during your script you want to take a more traditional approach to debugging, you can seamlessly switch to GDB. This will temporarily detach libdebug from the program and give you control over the program using GDB. Quitting GDB will return control to libdebug. </p> <p>By default, the behavior of this command is to open GDB in a new terminal window. For this to work, it is necessary to specify your terminal emulator in the libcontext parameters.</p> <p>Example of setting the terminal with tmux</p> <pre><code>from libdebug import libcontext\n\nlibcontext.terminal = ['tmux', 'splitw', '-h']\n</code></pre> <p>Once the terminal is set, you can use the <code>gdb()</code> method to open GDB in a new terminal window.</p> <p>Function Signature</p> <pre><code>d.gdb(open_in_new_process = True)\n</code></pre> <p>If instead of opening GDB in a new terminal window you want to use the current terminal, you can simply set the <code>open_in_new_process</code> parameter to <code>False</code>.</p> <p>Migrating from a running process</p> <p>Remember that GDB Migration is meant to be used when the process is stopped. If the process is running, the command will wait for a stopping event. To forcibly stop the process, you can use the <code>interrupt()</code> method before migrating.</p>","boost":4},{"location":"basics/detach_and_gdb/#graceful-termination","title":"Graceful Termination","text":"<p>If you are finished working with a Debugger object and wish to deallocate it, you can terminate it using the <code>terminate()</code> command.</p> <p>Function Signature</p> <pre><code>d.terminate()\n</code></pre> <p>What happens to the running process?</p> <p>When you terminate a Debugger object, the process is forcibly killed. If you wish to detach from the process and continue execution before terminating it, you should use the <code>detach()</code> command before.</p>","boost":4},{"location":"basics/kill_and_post_mortem/","title":"Process Death (and afterlife)","text":"<p>The default behavior in libdebug is to kill the debugged process when the script exits. This is done to prevent the process from running indefinitely if the debugging script terminates or you forget to kill it manually. When creating a Debugger object, you can set the <code>kill_on_exit</code> attribute to <code>False</code> to prevent this behavior:</p> <pre><code>from libdebug import Debugger\n\nd = debugger(\"test\", kill_on_exit=False)\n</code></pre> <p>You can also change this attribute in an existing Debugger object at runtime:  </p> <pre><code>d.kill_on_exit = False\n</code></pre> <p>Behavior when attaching to a process</p> <p>When debugging is initiated by attaching to an existing process, the <code>kill_on_exit</code> policy is enforced in the same way as when starting a new process.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#killing-the-process","title":"Killing the Process","text":"<p>You can kill the process at any time using the <code>kill()</code> method:</p> <pre><code>d.kill()\n</code></pre> <p>This method sends a <code>SIGKILL</code> signal to the process, which terminates it immediately. If the process is already dead, libdebug will throw an exception. When multiple threads are running, the <code>kill()</code> method will kill all threads under the parent process.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#post-mortem-analysis","title":"Post Mortem Analysis","text":"<p>You can check if the process is dead using the <code>dead</code> property:</p> <pre><code>if not d.dead:\n    print(\"The process is not dead\")\nelse:\n    print(\"The process is dead\")\n</code></pre> <p>The <code>running</code> property</p> <p>The Debugger object also exposes the <code>running</code> property. This is not the opposite of <code>dead</code>. The <code>running</code> property is <code>True</code> when the process is running and <code>False</code> when it is not. If execution was stopped by the debugger awaiting a command, the <code>running</code> property will be equal to <code>False</code>. However, in this case the process is still alive.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#cause-of-death","title":"Cause of Death","text":"<p>Has your process passed away unexpectedly? We are sorry to hear that. If your process is indeed defunct, you can access the exit code and signal using <code>exit_code</code> and <code>exit_signal</code>:</p> <pre><code>if d.dead:\n    print(f\"The process exited with code {d.exit_code}\")\n\nif d.dead:\n    print(f\"The process exited with signal {d.exit_signal}\")\n</code></pre>","boost":4},{"location":"basics/libdebug101/","title":"libdebug 101","text":"<p>Welcome to libdebug! When writing a script to debug a program, the first step is to create a Debugger object. This object will be your main interface for debugging commands.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(argv=[\"./program\", \"arg1\", \"arg2\"]) # (1)\n</code></pre> <ol> <li>You can either pass the name of the executable as a positional string argument, or a list of argv parameters for the execution.</li> </ol> <p>Am I already debugging?</p> <p>Creating a Debugger object will not start the execution automatically. You can reuse the same debugger to iteratively run multiple instances of the program. This is particularly useful for smart bruteforcing or fuzzing scripts.</p> <p>To run the executable, refer to Running an Executable</p>","boost":4},{"location":"basics/libdebug101/#environment","title":"Environment","text":"<p>Just as you would expect, you can also pass environment variables to the program using the <code>env</code> parameter. Here, the variables are passed as a string-string dictionary.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", env = {\"LD_PRELOAD\": \"musl_libc.so\"})\n</code></pre>","boost":4},{"location":"basics/libdebug101/#address-space-layout-randomization-aslr","title":"Address Space Layout Randomization (ASLR)","text":"<p>Modern operating system kernels implement mitigations against predictable addresses in binary exploitation scenarios. One such feature is ASLR, which randomizes the base address of mapped virtual memory pages (e.g., binary, libraries, stack). When debugging, this feature can become a nuisance for the user.</p> <p>For your convenience, the default behavior on libdebug is to disable ASLR. The debugger <code>aslr</code> parameter can be used to change this behavior.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", aslr=True)\n</code></pre>","boost":4},{"location":"basics/libdebug101/#binary-entry-point","title":"Binary Entry Point","text":"<p>When a child process is spawned on the Linux kernel through the <code>ptrace</code> system call, it is possible to trace it as soon as the loader has set up your executable. Debugging these first instructions inside the loader library is generally uninteresting.</p> <p>For this reason, the default behavior for libdebug is to continue until the binary entry point (1) is reached. When you need to start debugging from the very beginning, you can simply disable this behavior in the following way:</p> <ol> <li>In Linux, the binary entry point corresponds to the <code>_start</code> / <code>__rt_entry</code> symbol in your binary executable. This function is the initial stub that calls the <code>main()</code> function in your executable, through a call to the standard library of your system (e.g., <code>__libc_start_main</code>, <code>__rt_lib_init</code>)</li> </ol> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", continue_to_binary_entrypoint=False)\n</code></pre> <p>What the hell are you debugging?</p> <p>Please note that this feature assumes the binary is well-formed. If the ELF header is corrupt, the binary entrypoint will not be resolved correctly. As such, setting this parameter to <code>False</code> is a good practice when you don't want libdebug to rely on this information.</p>","boost":4},{"location":"basics/libdebug101/#what-else-can-i-do","title":"What else can I do?","text":"<p>The Debugger object has many more parameters it can take. Since they are associated to other features, we will mention them later in the documentation.</p>","boost":4},{"location":"basics/memory_access/","title":"Memory Access","text":"<p>In libdebug, memory access is performed via the <code>memory</code> attribute of the Debugger object or the Thread Context. When reading from memory, a bytes-like object is returned. The following methods are available:</p> Single byte accessSlice accessBase and lengthSymbol accessSymbol Range <p>Access a single byte of memory by providing the address as an integer. <pre><code>d.memory[0x1000]\n</code></pre></p> <p>Access a range of bytes by providing the start and end addresses as integers. <pre><code>d.memory[0x1000:0x1010]\n</code></pre></p> <p>Access a range of bytes by providing the base address and length as integers. <pre><code>d.memory[0x1000, 0x10]\n</code></pre></p> <p>Access memory using a symbol name. <pre><code>d.memory[\"function\", 0x8]\n</code></pre></p> <p>When specifying a symbol, you can also provide an offset. Contrary to what happens in GDB, the offset is always interpreted as hexadecimal. <pre><code>d.memory[\"function+a8\"]\n</code></pre></p> <p>Access a range of bytes using a symbol name. <pre><code>d.memory[\"function\":\"function+0f\"]\n</code></pre> Please note that contrary to what happens in GDB, the offset is always interpreted as hexadecimal.</p> <p>Accessing memory with symbols</p> <p>Please note that, unless otherwise specified, symbols are resolved in the debugged binary only. To resolve symbols in shared libraries, you need to indicate it in the third parameter of the function.</p> <pre><code>d.memory[\"__libc_start_main\", 0x8, \"libc\"]\n</code></pre> <p>Writing to memory works similarly. You can write a bytes-like object to memory using the same addressing methods:</p> <pre><code>d.memory[d.rsp, 0x10] = b\"AAAAAAABC\"\nd.memory[\"main_arena\", 16, \"libc\"] = b\"12345678\"\n</code></pre>","boost":4},{"location":"basics/memory_access/#absolute-and-relative-addressing","title":"Absolute and Relative Addressing","text":"<p>Just like with symbols, memory addresses can also be accessed relative to a certain file base. libdebug uses <code>\"hybrid\"</code> addressing by default. This means it first attempts to resolve addresses as absolute. If the address does not correspond to an absolute one, it considers it relative to the base of the binary.</p> <p>You can use the third parameter of the memory access method to select the file you want to use as base (e.g., libc, ld, binary). If you want to force libdebug to use absolute addressing, you can specify <code>\"absolute\"</code> instead.</p> <p>Examples of relative and absolute addressing</p> <pre><code># Absolute addressing\nd.memory[0x7ffff7fcb200, 0x10, \"absolute\"]\n\n# Hybrid addressing\nd.memory[0x1000, 0x10, \"hybrid\"]\n\n# Relative addressing\nd.memory[0x1000, 0x10, \"binary\"]\nd.memory[0x1000, 0x10, \"libc\"]\n</code></pre>","boost":4},{"location":"basics/memory_access/#searching-inside-memory","title":"Searching inside Memory","text":"<p>The <code>memory</code> attribute of the Debugger object also allows you to search for specific values in the memory of the process. You can search for integers, strings, or bytes-like objects.</p> <p>Function Signature</p> <pre><code>d.memory.find(\n    value: int | bytes | str,\n    file: str = \"all\",\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; list[int]:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>value</code> <code>int</code> | <code>bytes</code> | <code>str</code> The value to search for. <code>file</code> <code>str</code> The backing file to search in (e.g, binary, libc, stack). <code>start</code> <code>int</code> (optional) The start address of the search (works with both relative and absolute). <code>end</code> <code>int</code> (optional) The end address of the search (works with both relative and absolute). <p>Returns:</p> Return Type Description <code>Addresses</code> <code>list[int]</code> List of memory addresses where the value was found. <p>Usage Example</p> <pre><code>bish_string_addr = d.memory.find(\"/bin/sh\", file=\"libc\")\n\nvalue_address = d.memory.find(0x1234, file=\"stack\", start=d.regs.rsp)\n</code></pre>","boost":4},{"location":"basics/memory_access/#faster-memory-access","title":"Faster Memory Access","text":"<p>Warning: This feature is Experimental!</p> <p>This feature is experimental and may not work as expected. Please report any issues you encounter  here.</p> <p>By default, libdebug reads and writes memory using the <code>ptrace</code> system call interface. However, this is not the most efficient way to access memory and will likely be changed in future versions.</p> <p>To speed up memory access, you can already enable a faster system that relies on Linux's procfs. To use it, simply set the <code>fast_memory</code> parameter to <code>True</code> when creating the Debugger object. You can also enable and disable this feature at runtime by accessing the debugger's attribute.</p> When creating the Debugger objectAt runtime <pre><code>d = debugger(\"test\", fast_memory=True)\n</code></pre> <pre><code>d.fast_memory = True\n</code></pre>","boost":4},{"location":"basics/register_access/","title":"Register Access","text":"<p>libdebug offers a simple register access interface for supported architectures. Registers through the <code>regs</code> attribute of the Debugger object or the Thread Context. This includes both general-purpose and special registers, as well as the flags.</p> <p>Multithreading</p> <p>In multi-threaded debugging, the <code>regs</code> attribute of the Debugger object will return the registers of the main thread.</p> <p>The following is an example of how to interact with the <code>RAX</code> register in a debugger object on AMD64:</p> Operation Code Snippet Reading <code>read_value = d.regs.rax</code> Writing <code>d.regs.rax = read_value + 1</code> <p>Note that the register values are read and written as Python integers. This is true for all registers except for floating point ones, which are coherent with their type. To avoid confusion, we list available registers and their types below. Related registers are available to access as well.</p> AMD64AArch64 Register Type Related Description General Purpose RAX Integer EAX, AX, AH, AL Accumulator register RBX Integer EBX, BX, BH, BL Base register RCX Integer ECX, CX, CH, CL Counter register RDX Integer EDX, DX, DH, DL Data register RSI Integer ESI, SI Source index for string operations RDI Integer EDI, DI Destination index for string operations RBP Integer EBP, BP Base pointer (frame pointer) RSP Integer ESP, SP Stack pointer R8 Integer R8D, R8W, R8B General-purpose register R9 Integer R9D, R9W, R9B General-purpose register R10 Integer R10D, R10W, R10B General-purpose register R11 Integer R11D, R11W, R11B General-purpose register R12 Integer R12D, R12W, R12B General-purpose register R13 Integer R13D, R13W, R13B General-purpose register R14 Integer R14D, R14W, R14B General-purpose register R15 Integer R15D, R15W, R15B General-purpose register RIP Integer EIP Instruction pointer Floating Point Registers XMM0 Floating Point Lower 128 bits of YMM0/ZMM0 XMM1 Floating Point Lower 128 bits of YMM1/ZMM1 XMM2 Floating Point Lower 128 bits of YMM2/ZMM2 XMM3 Floating Point Lower 128 bits of YMM3/ZMM3 XMM4 Floating Point Lower 128 bits of YMM4/ZMM4 XMM5 Floating Point Lower 128 bits of YMM5/ZMM5 XMM6 Floating Point Lower 128 bits of YMM6/ZMM6 XMM7 Floating Point Lower 128 bits of YMM7/ZMM7 XMM8 Floating Point Lower 128 bits of YMM8/ZMM8 XMM9 Floating Point Lower 128 bits of YMM9/ZMM9 XMM10 Floating Point Lower 128 bits of YMM10/ZMM10 XMM11 Floating Point Lower 128 bits of YMM11/ZMM11 XMM12 Floating Point Lower 128 bits of YMM12/ZMM12 XMM13 Floating Point Lower 128 bits of YMM13/ZMM13 XMM14 Floating Point Lower 128 bits of YMM14/ZMM14 XMM15 Floating Point Lower 128 bits of YMM15/ZMM15 YMM0 Floating Point 256-bit AVX extension of XMM0 YMM1 Floating Point 256-bit AVX extension of XMM1 YMM2 Floating Point 256-bit AVX extension of XMM2 YMM3 Floating Point 256-bit AVX extension of XMM3 YMM4 Floating Point 256-bit AVX extension of XMM4 YMM5 Floating Point 256-bit AVX extension of XMM5 YMM6 Floating Point 256-bit AVX extension of XMM6 YMM7 Floating Point 256-bit AVX extension of XMM7 YMM8 Floating Point 256-bit AVX extension of XMM8 YMM9 Floating Point 256-bit AVX extension of XMM9 YMM10 Floating Point 256-bit AVX extension of XMM10 YMM11 Floating Point 256-bit AVX extension of XMM11 YMM12 Floating Point 256-bit AVX extension of XMM12 YMM13 Floating Point 256-bit AVX extension of XMM13 YMM14 Floating Point 256-bit AVX extension of XMM14 YMM15 Floating Point 256-bit AVX extension of XMM15 ZMM0 Floating Point 512-bit AVX-512 extension of XMM0 ZMM1 Floating Point 512-bit AVX-512 extension of XMM1 ZMM2 Floating Point 512-bit AVX-512 extension of XMM2 ZMM3 Floating Point 512-bit AVX-512 extension of XMM3 ZMM4 Floating Point 512-bit AVX-512 extension of XMM4 ZMM5 Floating Point 512-bit AVX-512 extension of XMM5 ZMM6 Floating Point 512-bit AVX-512 extension of XMM6 ZMM7 Floating Point 512-bit AVX-512 extension of XMM7 ZMM8 Floating Point 512-bit AVX-512 extension of XMM8 ZMM9 Floating Point 512-bit AVX-512 extension of XMM9 ZMM10 Floating Point 512-bit AVX-512 extension of XMM10 ZMM11 Floating Point 512-bit AVX-512 extension of XMM11 ZMM12 Floating Point 512-bit AVX-512 extension of XMM12 ZMM13 Floating Point 512-bit AVX-512 extension of XMM13 ZMM14 Floating Point 512-bit AVX-512 extension of XMM14 ZMM15 Floating Point 512-bit AVX-512 extension of XMM15 Floating Point (Legacy x87) ST(0)-ST(7) Floating Point x87 FPU data registers MM0-MM7 Floating Point MMX registers Register Type Alias(es) Description General Purpose X0 Integer W0 Function result or argument X1 Integer W1 Function result or argument X2 Integer W2 Function result or argument X3 Integer W3 Function result or argument X4 Integer W4 Function result or argument X5 Integer W5 Function result or argument X6 Integer W6 Function result or argument X7 Integer W7 Function result or argument X8 Integer W8 Indirect result location (also called \"IP0\") X9 Integer W9 Temporary register X10 Integer W10 Temporary register X11 Integer W11 Temporary register X12 Integer W12 Temporary register X13 Integer W13 Temporary register X14 Integer W14 Temporary register X15 Integer W15 Temporary register (also called \"IP1\") X16 Integer W16 Platform Register (often used as scratch) X17 Integer W17 Platform Register (often used as scratch) X18 Integer W18 Platform Register X19 Integer W19 Callee-saved register X20 Integer W20 Callee-saved register X21 Integer W21 Callee-saved register X22 Integer W22 Callee-saved register X23 Integer W23 Callee-saved register X24 Integer W24 Callee-saved register X25 Integer W25 Callee-saved register X26 Integer W26 Callee-saved register X27 Integer W27 Callee-saved register X28 Integer W28 Callee-saved register X29 Integer W29, FP Frame pointer X30 Integer W30, LR Link register (return address) XZR Integer WZR, ZR Zero register (always reads as zero) SP Integer Stack pointer PC Integer Program counter Floating Point Registers (SIMD/FP) V0 Floating Point Vector or scalar register V1 Floating Point Vector or scalar register V2 Floating Point Vector or scalar register V3 Floating Point Vector or scalar register V4 Floating Point Vector or scalar register V5 Floating Point Vector or scalar register V6 Floating Point Vector or scalar register V7 Floating Point Vector or scalar register V8 Floating Point Vector or scalar register V9 Floating Point Vector or scalar register V10 Floating Point Vector or scalar register V11 Floating Point Vector or scalar register V12 Floating Point Vector or scalar register V13 Floating Point Vector or scalar register V14 Floating Point Vector or scalar register V15 Floating Point Vector or scalar register V16 Floating Point Vector or scalar register V17 Floating Point Vector or scalar register V18 Floating Point Vector or scalar register V19 Floating Point Vector or scalar register V20 Floating Point Vector or scalar register V21 Floating Point Vector or scalar register V22 Floating Point Vector or scalar register V23 Floating Point Vector or scalar register V24 Floating Point Vector or scalar register V25 Floating Point Vector or scalar register V26 Floating Point Vector or scalar register V27 Floating Point Vector or scalar register V28 Floating Point Vector or scalar register V29 Floating Point Vector or scalar register V30 Floating Point Vector or scalar register V31 Floating Point Vector or scalar register Q0 Floating Point Vector or scalar register Q1 Floating Point Vector or scalar register Q2 Floating Point Vector or scalar register Q3 Floating Point Vector or scalar register Q4 Floating Point Vector or scalar register Q5 Floating Point Vector or scalar register Q6 Floating Point Vector or scalar register Q7 Floating Point Vector or scalar register Q8 Floating Point Vector or scalar register Q9 Floating Point Vector or scalar register Q10 Floating Point Vector or scalar register Q11 Floating Point Vector or scalar register Q12 Floating Point Vector or scalar register Q13 Floating Point Vector or scalar register Q14 Floating Point Vector or scalar register Q15 Floating Point Vector or scalar register Q16 Floating Point Vector or scalar register Q17 Floating Point Vector or scalar register Q18 Floating Point Vector or scalar register Q19 Floating Point Vector or scalar register Q20 Floating Point Vector or scalar register Q21 Floating Point Vector or scalar register Q22 Floating Point Vector or scalar register Q23 Floating Point Vector or scalar register Q24 Floating Point Vector or scalar register Q25 Floating Point Vector or scalar register Q26 Floating Point Vector or scalar register Q27 Floating Point Vector or scalar register Q28 Floating Point Vector or scalar register Q29 Floating Point Vector or scalar register Q30 Floating Point Vector or scalar register Q31 Floating Point Vector or scalar register D0 Floating Point Vector or scalar register D1 Floating Point Vector or scalar register D2 Floating Point Vector or scalar register D3 Floating Point Vector or scalar register D4 Floating Point Vector or scalar register D5 Floating Point Vector or scalar register D6 Floating Point Vector or scalar register D7 Floating Point Vector or scalar register D8 Floating Point Vector or scalar register D9 Floating Point Vector or scalar register D10 Floating Point Vector or scalar register D11 Floating Point Vector or scalar register D12 Floating Point Vector or scalar register D13 Floating Point Vector or scalar register D14 Floating Point Vector or scalar register D15 Floating Point Vector or scalar register D16 Floating Point Vector or scalar register D17 Floating Point Vector or scalar register D18 Floating Point Vector or scalar register D19 Floating Point Vector or scalar register D20 Floating Point Vector or scalar register D21 Floating Point Vector or scalar register D22 Floating Point Vector or scalar register D23 Floating Point Vector or scalar register D24 Floating Point Vector or scalar register D25 Floating Point Vector or scalar register D26 Floating Point Vector or scalar register D27 Floating Point Vector or scalar register D28 Floating Point Vector or scalar register D29 Floating Point Vector or scalar register D30 Floating Point Vector or scalar register D31 Floating Point Vector or scalar register S0 Floating Point Vector or scalar register S1 Floating Point Vector or scalar register S2 Floating Point Vector or scalar register S3 Floating Point Vector or scalar register S4 Floating Point Vector or scalar register S5 Floating Point Vector or scalar register S6 Floating Point Vector or scalar register S7 Floating Point Vector or scalar register S8 Floating Point Vector or scalar register S9 Floating Point Vector or scalar register S10 Floating Point Vector or scalar register S11 Floating Point Vector or scalar register S12 Floating Point Vector or scalar register S13 Floating Point Vector or scalar register S14 Floating Point Vector or scalar register S15 Floating Point Vector or scalar register S16 Floating Point Vector or scalar register S17 Floating Point Vector or scalar register S18 Floating Point Vector or scalar register S19 Floating Point Vector or scalar register S20 Floating Point Vector or scalar register S21 Floating Point Vector or scalar register S22 Floating Point Vector or scalar register S23 Floating Point Vector or scalar register S24 Floating Point Vector or scalar register S25 Floating Point Vector or scalar register S26 Floating Point Vector or scalar register S27 Floating Point Vector or scalar register S28 Floating Point Vector or scalar register S29 Floating Point Vector or scalar register S30 Floating Point Vector or scalar register S31 Floating Point Vector or scalar register H0 Floating Point Vector or scalar register H1 Floating Point Vector or scalar register H2 Floating Point Vector or scalar register H3 Floating Point Vector or scalar register H4 Floating Point Vector or scalar register H5 Floating Point Vector or scalar register H6 Floating Point Vector or scalar register H7 Floating Point Vector or scalar register H8 Floating Point Vector or scalar register H9 Floating Point Vector or scalar register H10 Floating Point Vector or scalar register H11 Floating Point Vector or scalar register H12 Floating Point Vector or scalar register H13 Floating Point Vector or scalar register H14 Floating Point Vector or scalar register H15 Floating Point Vector or scalar register H16 Floating Point Vector or scalar register H17 Floating Point Vector or scalar register H18 Floating Point Vector or scalar register H19 Floating Point Vector or scalar register H20 Floating Point Vector or scalar register H21 Floating Point Vector or scalar register H22 Floating Point Vector or scalar register H23 Floating Point Vector or scalar register H24 Floating Point Vector or scalar register H25 Floating Point Vector or scalar register H26 Floating Point Vector or scalar register H27 Floating Point Vector or scalar register H28 Floating Point Vector or scalar register H29 Floating Point Vector or scalar register H30 Floating Point Vector or scalar register H31 Floating Point Vector or scalar register B0 Floating Point Vector or scalar register B1 Floating Point Vector or scalar register B2 Floating Point Vector or scalar register B3 Floating Point Vector or scalar register B4 Floating Point Vector or scalar register B5 Floating Point Vector or scalar register B6 Floating Point Vector or scalar register B7 Floating Point Vector or scalar register B8 Floating Point Vector or scalar register B9 Floating Point Vector or scalar register B10 Floating Point Vector or scalar register B11 Floating Point Vector or scalar register B12 Floating Point Vector or scalar register B13 Floating Point Vector or scalar register B14 Floating Point Vector or scalar register B15 Floating Point Vector or scalar register B16 Floating Point Vector or scalar register B17 Floating Point Vector or scalar register B18 Floating Point Vector or scalar register B19 Floating Point Vector or scalar register B20 Floating Point Vector or scalar register B21 Floating Point Vector or scalar register B22 Floating Point Vector or scalar register B23 Floating Point Vector or scalar register B24 Floating Point Vector or scalar register B25 Floating Point Vector or scalar register B26 Floating Point Vector or scalar register B27 Floating Point Vector or scalar register B28 Floating Point Vector or scalar register B29 Floating Point Vector or scalar register B30 Floating Point Vector or scalar register B31 Floating Point Vector or scalar register <p>Hardware Support</p> <p>libdebug only exposes registers which are available on your CPU model. For AMD64, the list of available AVX registers is determined by checking the CPU capabilities. If you believe your CPU supports AVX registers but they are not available, we encourage your to open an  Issue with your hardware details.</p>","boost":4},{"location":"basics/register_access/#searching-inside-registers","title":"Searching inside Registers","text":"<p>The <code>regs</code> field of the Debugger object or the Thread Context can also used to search for specific values inside the registers. </p> <p>Function Signature</p> <pre><code>d.regs.find(value: float) -&gt; list[str]:\n</code></pre> <p>The search routine will look for the given value in integer registers when the <code>value</code> is an int and in floating point registers when the value is a <code>float</code>.</p> <p>Searching for a Value</p> <pre><code>d.regs.rax = 0x1337\n\n# Search for the value 0x1337 in the registers\nresults = d.regs.find(0x1337)\nprint(f\"Found in: {results}\")\n</code></pre>","boost":4},{"location":"basics/running_an_executable/","title":"Running an Executable","text":"<p>You have created your first debugger object, and now you want to run an executable. Calling the <code>run()</code> method will start execution on a new child process and, unless otherwise specified, continue to the binary entry point.</p> <p><pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\nd.run()\n</code></pre> At this point, the process execution is stopped, waiting for your commands.</p> <p>A few things to keep in mind</p> <ul> <li>Please remember that the process you are debugging (the tracee) and the debugger itself are running in different threads. </li> <li>Also note that breakpoints and other stopping events set by the user are not kept between different runs of the program. If you want to place them, you should do so after each call to <code>d.run()</code>.</li> </ul>","boost":4},{"location":"basics/running_an_executable/#process-io","title":"Process I/O","text":"<p>When execution is resumed, chances are that your process will need to take input and produce output. To interact with the standard input and output of the process, you can use the pipe handle returned by the <code>run()</code> function.</p> <p>You can interact with the process's pipe handle using the following commands:</p> Method Description <code>recv</code> Receives <code>numb</code> bytes from the target.Parameters:- <code>numb</code> (int | None) | default = None - <code>timeout</code> (int) | default = timeout_default <code>recverr</code> Receives <code>numb</code> bytes from the target's standard error.Parameters:- <code>numb</code> (int | None) | default = None- <code>timeout</code> (int) | default = timeout_default <code>recvline</code> Receives <code>numlines</code> lines of data from the target.Parameters:- <code>numlines</code> (int) | default = 1 - <code>drop</code> (bool) | default = True- <code>timeout</code> (int) | default = timeout_default <code>recverrline</code> Receives <code>numlines</code> lines of data from the target's standard error.Parameters:- <code>numlines</code> (int) | default = 1- <code>drop</code> (bool) | default = True- <code>timeout</code> (int) | default = timeout_default <code>recvuntil</code> Receives data from the target until a specified delimiter is encountered for a certain number of occurrences. Parameters:- <code>delims</code> (bytes)- <code>occurrences</code> (int) | default = 1- <code>drop</code> (bool) | default = True- <code>timeout</code> (int) | default = timeout_default <code>recverruntil</code> Receives data from the target's standard error until a specified delimiter is encountered for a certain number of occurrences.Parameters:- <code>delims</code> (bytes)- <code>occurrences</code> (int) | default = 1- <code>drop</code> (bool) | default = True-<code>timeout</code> (int) | default = timeout_default <code>send</code> Sends data to the targetParameters:- <code>data</code> (bytes) <code>sendafter</code> Sends data to the target after receiving a specified number of occurrences of the delimiter.Parameters:- <code>delims</code> (bytes)- <code>data</code> (bytes)- <code>occurrences</code> (int) | default = 1- <code>drop</code> (bool) | default = False- <code>timeout</code> (int) | default = timeout_default <code>sendline</code> Sends a single line of data to the target.Parameters:- <code>data</code> (bytes) <code>sendlineafter</code> Sends a single line of data to the target after receiving a specified number of occurrences of the delimiter.Parameters:- <code>delims</code> (bytes)- <code>data</code> (bytes)- <code>occurrences</code> (int) | default = 1- <code>drop</code> (bool) | default = False- <code>timeout</code> (int) | default = timeout_default <code>close</code> Closes the connection to the target.","boost":4},{"location":"basics/supported_systems/","title":"Supported Systems","text":"","boost":4},{"location":"basics/supported_systems/#operating-systems","title":"Operating Systems","text":"<p>Currently, libdebug only supports the  GNU/Linux Operating System.</p>","boost":4},{"location":"basics/supported_systems/#architectures","title":"Architectures","text":"Architecture Alias Support Notes  x86_64 AMD64  Stable  i386 over AMD64 32-bit compatibility mode  Experimental Partial compatibility  i386 IA-32  Experimental Only in  i386-support  ARM 64-bit AArch64  Stable  ARM 32-bit ARM32  Not Supported","boost":4},{"location":"blog/","title":"Blogposts","text":""},{"location":"code_examples/example_cc24/","title":"CyberChallenge 2024 - Workshop","text":"<p>This script was used to showcase the power of libdebug during the Workshop at the CyberChallenge.IT 2024 Finals. An explanation of the script, along with a brief introduction to libdebug, is available in the official stream of the event, starting from timestamp 2:17:00.</p> <pre><code>from libdebug import debugger\nfrom string import ascii_letters, digits\n\n# Enable the escape_antidebug option to bypass the ptrace call\nd = debugger(\"main\", escape_antidebug=True)\n\ndef callback(_, __):\n    # This will automatically issue a continue when the breakpoint is hit\n    pass\n\ndef on_enter_nanosleep(t, _):\n    # This sets every argument to NULL to make the syscall fail\n    t.syscall_arg0 = 0\n    t.syscall_arg1 = 0\n    t.syscall_arg2 = 0\n    t.syscall_arg3 = 0\n\nalphabet = ascii_letters + digits + \"_{}\"\n\nflag = b\"\"\nbest_hit_count = 0\n\nwhile True:\n    for c in alphabet:\n        r = d.run()\n\n        # Any time we call run() we have to reset the breakpoint and syscall handler\n        bp = d.breakpoint(0x13e1, hardware=True, callback=callback, file=\"binary\")\n        d.handle_syscall(\"clock_nanosleep\", on_enter=on_enter_nanosleep)\n\n        d.cont()\n\n        r.sendline(flag + c.encode())\n\n        # This makes the debugger wait for the process to terminate\n        d.wait()\n\n        response = r.recvline()\n\n        # `run()` will automatically kill any still-running process, but it's good practice to do it manually\n        d.kill()\n\n        if b\"Yeah\" in response:\n            # The flag is correct\n            flag += c.encode()\n            print(flag)\n            break\n\n        if bp.hit_count &gt; best_hit_count:\n            # We have found a new flag character\n            best_hit_count = bp.hit_count\n            flag += c.encode()\n            print(flag)\n            break\n\n    if c == \"}\":\n        break\n\nprint(flag)\n</code></pre>","boost":0.8},{"location":"code_examples/example_nlinks/","title":"DEF CON Quals 2023 - nlinks","text":"<p>This is a script that solves the challenge nlinks from DEF CON Quals 2023. Please find the binary executables here. <pre><code>def get_passsphrase_from_class_1_binaries(previous_flag):\n    flag = b\"\"\n\n    d = debugger(\"CTF/1\")\n    r = d.run()\n\n    bp = d.breakpoint(0x7EF1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.recvuntil(b\"Passphrase:\\n\")\n\n    # We send a fake flag after the valid password\n    r.send(previous_flag + b\"a\" * 8)\n\n    for _ in range(8):\n        # Here we reached the breakpoint\n        if not bp.hit_on(d):\n            print(\"Here we should have hit the breakpoint\")\n\n        offset = ord(\"a\") ^ d.regs.rbp\n        d.regs.rbp = d.regs.r13\n\n        # We calculate the correct character value and append it to the flag\n        flag += (offset ^ d.regs.r13).to_bytes(1, \"little\")\n\n        d.cont()\n\n    r.recvline()\n\n    d.kill()\n\n    # Here the value of flag is b\"\\x00\\x006\\x00\\x00\\x00(\\x00\"\n    return flag\n\ndef get_passsphrase_from_class_2_binaries(previous_flag):\n    bitmap = {}\n    lastpos = 0\n    flag = b\"\"\n\n    d = debugger(\"CTF/2\")\n    r = d.run()\n\n    bp1 = d.breakpoint(0xD8C1, hardware=True, file=\"binary\")\n    bp2 = d.breakpoint(0x1858, hardware=True, file=\"binary\")\n    bp3 = d.breakpoint(0xDBA1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.recvuntil(b\"Passphrase:\\n\")\n    r.send(previous_flag + b\"a\" * 8)\n\n    while True:\n        if d.regs.rip == bp1.address:\n            # Prepare for the next element in the bitmap\n            lastpos = d.regs.rbp\n            d.regs.rbp = d.regs.r13 + 1\n        elif d.regs.rip == bp2.address:\n            # Update the bitmap\n            bitmap[d.regs.r12 &amp; 0xFF] = lastpos &amp; 0xFF\n        elif d.regs.rip == bp3.address:\n            # Use the bitmap to calculate the expected character\n            d.regs.rbp = d.regs.r13\n            wanted = d.regs.rbp\n            needed = 0\n            for i in range(8):\n                if wanted &amp; (2**i):\n                    needed |= bitmap[2**i]\n            flag += chr(needed).encode()\n\n            if bp3.hit_count == 8:\n                # We have found all the characters\n                d.cont()\n                break\n\n        d.cont()\n\n    d.kill()\n\n    # Here the value of flag is b\"\\x00\\x00\\x00\\x01\\x00\\x00a\\x00\"\n    return flag\n\ndef get_passsphrase_from_class_3_binaries():\n    flag = b\"\"\n\n    d = debugger(\"CTF/0\")\n    r = d.run()\n\n    bp = d.breakpoint(0x91A1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.send(b\"a\" * 8)\n\n    for _ in range(8):\n\n        # Here we reached the breakpoint\n        if not bp.hit_on(d):\n            print(\"Here we should have hit the breakpoint\")\n\n        offset = ord(\"a\") - d.regs.rbp\n        d.regs.rbp = d.regs.r13\n\n        # We calculate the correct character value and append it to the flag\n        flag += chr((d.regs.r13 + offset) % 256).encode(\"latin-1\")\n\n        d.cont()\n\n    r.recvline()\n\n    d.kill()\n\n    # Here the value of flag is b\"BM8\\xd3\\x02\\x00\\x00\\x00\"\n    return flag\n\ndef run_nlinks():\n    flag0 = get_passsphrase_from_class_3_binaries()\n    flag1 = get_passsphrase_from_class_1_binaries(flag0)\n    flag2 = get_passsphrase_from_class_2_binaries(flag1)\n\n    print(flag0, flag1, flag2)\n</code></pre></p>","boost":0.8},{"location":"code_examples/examples_index/","title":"Examples Index","text":"<p>This chapter contains a collection of examples showcasing the power of libdebug in various scenarios. Each example is a script that uses the library to solve a specific challenge or demonstrate a particular feature.</p>","boost":1},{"location":"from_pydoc/generated/libdebug/","title":"libdebug.libdebug","text":""},{"location":"from_pydoc/generated/libdebug/#libdebug.libdebug.debugger","title":"<code>debugger(argv=[], aslr=False, env=None, escape_antidebug=False, continue_to_binary_entrypoint=True, auto_interrupt_on_command=False, fast_memory=False, kill_on_exit=True)</code>","text":"<p>This function is used to create a new <code>Debugger</code> object. It returns a <code>Debugger</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>str | list[str]</code> <p>The location of the binary to debug, and any additional arguments to pass to it.</p> <code>[]</code> <code>aslr</code> <code>bool</code> <p>Whether to enable ASLR. Defaults to False.</p> <code>False</code> <code>env</code> <code>dict[str, str]</code> <p>The environment variables to use. Defaults to the same environment of the debugging script.</p> <code>None</code> <code>escape_antidebug</code> <code>bool</code> <p>Whether to automatically attempt to patch antidebugger detectors based on the ptrace syscall.</p> <code>False</code> <code>continue_to_binary_entrypoint</code> <code>bool</code> <p>Whether to automatically continue to the binary entrypoint. Defaults to True.</p> <code>True</code> <code>auto_interrupt_on_command</code> <code>bool</code> <p>Whether to automatically interrupt the process when a command is issued. Defaults to False.</p> <code>False</code> <code>fast_memory</code> <code>bool</code> <p>Whether to use a faster memory reading method. Defaults to False.</p> <code>False</code> <code>kill_on_exit</code> <code>bool</code> <p>Whether to kill the debugged process when the debugger exits. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Debugger</code> <code>Debugger</code> <p>The <code>Debugger</code> object.</p> Source code in <code>libdebug/libdebug.py</code> <pre><code>def debugger(\n    argv: str | list[str] = [],\n    aslr: bool = False,\n    env: dict[str, str] | None = None,\n    escape_antidebug: bool = False,\n    continue_to_binary_entrypoint: bool = True,\n    auto_interrupt_on_command: bool = False,\n    fast_memory: bool = False,\n    kill_on_exit: bool = True,\n) -&gt; Debugger:\n    \"\"\"This function is used to create a new `Debugger` object. It returns a `Debugger` object.\n\n    Args:\n        argv (str | list[str], optional): The location of the binary to debug, and any additional arguments to pass to it.\n        aslr (bool, optional): Whether to enable ASLR. Defaults to False.\n        env (dict[str, str], optional): The environment variables to use. Defaults to the same environment of the debugging script.\n        escape_antidebug (bool): Whether to automatically attempt to patch antidebugger detectors based on the ptrace syscall.\n        continue_to_binary_entrypoint (bool, optional): Whether to automatically continue to the binary entrypoint. Defaults to True.\n        auto_interrupt_on_command (bool, optional): Whether to automatically interrupt the process when a command is issued. Defaults to False.\n        fast_memory (bool, optional): Whether to use a faster memory reading method. Defaults to False.\n        kill_on_exit (bool, optional): Whether to kill the debugged process when the debugger exits. Defaults to True.\n\n    Returns:\n        Debugger: The `Debugger` object.\n    \"\"\"\n    if isinstance(argv, str):\n        argv = [argv]\n\n    internal_debugger = InternalDebugger()\n    internal_debugger.argv = argv\n    internal_debugger.env = env\n    internal_debugger.aslr_enabled = aslr\n    internal_debugger.autoreach_entrypoint = continue_to_binary_entrypoint\n    internal_debugger.auto_interrupt_on_command = auto_interrupt_on_command\n    internal_debugger.escape_antidebug = escape_antidebug\n    internal_debugger.fast_memory = fast_memory\n    internal_debugger.kill_on_exit = kill_on_exit\n\n    debugger = Debugger()\n    debugger.post_init_(internal_debugger)\n\n    # If we are attaching, we assume the architecture is the same as the current platform\n    if argv:\n        debugger.arch = elf_architecture(argv[0])\n\n    return debugger\n</code></pre>"},{"location":"from_pydoc/generated/liblog/","title":"libdebug.liblog","text":""},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog","title":"<code>LibLog</code>","text":"<p>Custom logger singleton class that can be used to log messages to the console.</p> Source code in <code>libdebug/liblog.py</code> <pre><code>class LibLog:\n    \"\"\"Custom logger singleton class that can be used to log messages to the console.\"\"\"\n\n    _instance = None\n\n    def __new__(cls: type):\n        \"\"\"Create a new instance of the class if it does not exist yet.\n\n        Returns:\n            LibLog: the instance of the class.\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self: LibLog) -&gt; None:\n        \"\"\"Initializes the logger.\"\"\"\n        if self._initialized:\n            return\n\n        # Add custom log levels\n        logging.addLevelName(60, \"SILENT\")\n        logging.SILENT = 60\n\n        # General logger\n        self.general_logger = self._setup_logger(\"libdebug\", logging.INFO)\n\n        # Component-specific loggers\n        self.debugger_logger = self._setup_logger(\"debugger\", logging.SILENT)\n        self.pipe_logger = self._setup_logger(\"pipe\", logging.SILENT)\n\n        self._initialized = True\n\n    def _setup_logger(self: LibLog, name: str, level: int) -&gt; logging.Logger:\n        \"\"\"Setup a logger with the given name and level.\n\n        Args:\n            name (str): name of the logger.\n            level (int): logging level.\n\n        Returns:\n            logging.Logger: the logger object.\n        \"\"\"\n        logger = logging.getLogger(name)\n        logger.setLevel(level)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\"%(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n        return logger\n\n    def debugger(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a message to the debugger logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{PrintStyle.RED}DEBUGGER{PrintStyle.DEFAULT_COLOR}]\"\n        self.debugger_logger.debug(f\"{header} {message}\", *args, **kwargs)\n\n    def pipe(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a message to the pipe logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{PrintStyle.BLUE}PIPE{PrintStyle.DEFAULT_COLOR}]\"\n        self.pipe_logger.debug(f\"{header} {message}\", *args, **kwargs)\n\n    def info(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a info message to the general logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{PrintStyle.GREEN}INFO{PrintStyle.DEFAULT_COLOR}]\"\n        self.general_logger.info(f\"{header} {message}\", *args, **kwargs)\n\n    def warning(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a warning message to the general logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{PrintStyle.BRIGHT_YELLOW}WARNING{PrintStyle.DEFAULT_COLOR}]\"\n        self.general_logger.warning(f\"{header} {message}\", *args, **kwargs)\n\n    def error(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log an error message to the general logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{PrintStyle.RED}ERROR{PrintStyle.DEFAULT_COLOR}]\"\n        self.general_logger.error(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the logger.</p> Source code in <code>libdebug/liblog.py</code> <pre><code>def __init__(self: LibLog) -&gt; None:\n    \"\"\"Initializes the logger.\"\"\"\n    if self._initialized:\n        return\n\n    # Add custom log levels\n    logging.addLevelName(60, \"SILENT\")\n    logging.SILENT = 60\n\n    # General logger\n    self.general_logger = self._setup_logger(\"libdebug\", logging.INFO)\n\n    # Component-specific loggers\n    self.debugger_logger = self._setup_logger(\"debugger\", logging.SILENT)\n    self.pipe_logger = self._setup_logger(\"pipe\", logging.SILENT)\n\n    self._initialized = True\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.__new__","title":"<code>__new__()</code>","text":"<p>Create a new instance of the class if it does not exist yet.</p> <p>Returns:</p> Name Type Description <code>LibLog</code> <p>the instance of the class.</p> Source code in <code>libdebug/liblog.py</code> <pre><code>def __new__(cls: type):\n    \"\"\"Create a new instance of the class if it does not exist yet.\n\n    Returns:\n        LibLog: the instance of the class.\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.debugger","title":"<code>debugger(message, *args, **kwargs)</code>","text":"<p>Log a message to the debugger logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def debugger(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a message to the debugger logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{PrintStyle.RED}DEBUGGER{PrintStyle.DEFAULT_COLOR}]\"\n    self.debugger_logger.debug(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.error","title":"<code>error(message, *args, **kwargs)</code>","text":"<p>Log an error message to the general logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def error(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log an error message to the general logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{PrintStyle.RED}ERROR{PrintStyle.DEFAULT_COLOR}]\"\n    self.general_logger.error(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.info","title":"<code>info(message, *args, **kwargs)</code>","text":"<p>Log a info message to the general logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def info(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a info message to the general logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{PrintStyle.GREEN}INFO{PrintStyle.DEFAULT_COLOR}]\"\n    self.general_logger.info(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.pipe","title":"<code>pipe(message, *args, **kwargs)</code>","text":"<p>Log a message to the pipe logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def pipe(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a message to the pipe logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{PrintStyle.BLUE}PIPE{PrintStyle.DEFAULT_COLOR}]\"\n    self.pipe_logger.debug(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.warning","title":"<code>warning(message, *args, **kwargs)</code>","text":"<p>Log a warning message to the general logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def warning(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a warning message to the general logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{PrintStyle.BRIGHT_YELLOW}WARNING{PrintStyle.DEFAULT_COLOR}]\"\n    self.general_logger.warning(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/breakpoint_validator/","title":"libdebug.architectures.breakpoint_validator","text":""},{"location":"from_pydoc/generated/architectures/breakpoint_validator/#libdebug.architectures.breakpoint_validator.validate_hardware_breakpoint","title":"<code>validate_hardware_breakpoint(arch, bp)</code>","text":"<p>Validate a hardware breakpoint for the specified architecture.</p> Source code in <code>libdebug/architectures/breakpoint_validator.py</code> <pre><code>def validate_hardware_breakpoint(arch: str, bp: Breakpoint) -&gt; None:\n    \"\"\"Validate a hardware breakpoint for the specified architecture.\"\"\"\n    if arch == \"aarch64\":\n        validate_breakpoint_aarch64(bp)\n    elif arch == \"amd64\":\n        validate_breakpoint_amd64(bp)\n    else:\n        raise ValueError(f\"Architecture {arch} not supported\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/","title":"libdebug.architectures.call_utilities_manager","text":""},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager","title":"<code>CallUtilitiesManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An architecture-independent interface for call instruction utilities.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>class CallUtilitiesManager(ABC):\n    \"\"\"An architecture-independent interface for call instruction utilities.\"\"\"\n\n    @abstractmethod\n    def is_call(self: CallUtilitiesManager, opcode_window: bytes) -&gt; bool:\n        \"\"\"Check if the current instruction is a call instruction.\"\"\"\n\n    @abstractmethod\n    def compute_call_skip(self: CallUtilitiesManager, opcode_window: bytes) -&gt; int:\n        \"\"\"Compute the address where to skip after the current call instruction.\"\"\"\n\n    @abstractmethod\n    def get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n        \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager.compute_call_skip","title":"<code>compute_call_skip(opcode_window)</code>  <code>abstractmethod</code>","text":"<p>Compute the address where to skip after the current call instruction.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>@abstractmethod\ndef compute_call_skip(self: CallUtilitiesManager, opcode_window: bytes) -&gt; int:\n    \"\"\"Compute the address where to skip after the current call instruction.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager.get_call_and_skip_amount","title":"<code>get_call_and_skip_amount(opcode_window)</code>  <code>abstractmethod</code>","text":"<p>Check if the current instruction is a call instruction and compute the instruction size.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>@abstractmethod\ndef get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n    \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager.is_call","title":"<code>is_call(opcode_window)</code>  <code>abstractmethod</code>","text":"<p>Check if the current instruction is a call instruction.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>@abstractmethod\ndef is_call(self: CallUtilitiesManager, opcode_window: bytes) -&gt; bool:\n    \"\"\"Check if the current instruction is a call instruction.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_provider/","title":"libdebug.architectures.call_utilities_provider","text":""},{"location":"from_pydoc/generated/architectures/call_utilities_provider/#libdebug.architectures.call_utilities_provider.call_utilities_provider","title":"<code>call_utilities_provider(architecture)</code>","text":"<p>Returns an instance of the call utilities provider to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/architectures/call_utilities_provider.py</code> <pre><code>def call_utilities_provider(architecture: str) -&gt; CallUtilitiesManager:\n    \"\"\"Returns an instance of the call utilities provider to be used by the `_InternalDebugger` class.\"\"\"\n    match architecture:\n        case \"amd64\":\n            return _amd64_call_utilities\n        case \"aarch64\":\n            return _aarch64_call_utilities\n        case _:\n            raise NotImplementedError(f\"Architecture {architecture} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/ptrace_software_breakpoint_patcher/","title":"libdebug.architectures.ptrace_software_breakpoint_patcher","text":""},{"location":"from_pydoc/generated/architectures/ptrace_software_breakpoint_patcher/#libdebug.architectures.ptrace_software_breakpoint_patcher.software_breakpoint_byte_size","title":"<code>software_breakpoint_byte_size(architecture)</code>","text":"<p>Return the size of a software breakpoint instruction.</p> Source code in <code>libdebug/architectures/ptrace_software_breakpoint_patcher.py</code> <pre><code>def software_breakpoint_byte_size(architecture: str) -&gt; int:\n    \"\"\"Return the size of a software breakpoint instruction.\"\"\"\n    match architecture:\n        case \"amd64\" | \"i386\":\n            return 1\n        case \"aarch64\":\n            return 4\n        case _:\n            raise ValueError(f\"Unsupported architecture: {architecture}\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/register_helper/","title":"libdebug.architectures.register_helper","text":""},{"location":"from_pydoc/generated/architectures/register_helper/#libdebug.architectures.register_helper.register_holder_provider","title":"<code>register_holder_provider(architecture, register_file, fp_register_file)</code>","text":"<p>Returns an instance of the register holder to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/architectures/register_helper.py</code> <pre><code>def register_holder_provider(\n    architecture: str,\n    register_file: object,\n    fp_register_file: object,\n) -&gt; RegisterHolder:\n    \"\"\"Returns an instance of the register holder to be used by the `_InternalDebugger` class.\"\"\"\n    match architecture:\n        case \"amd64\" | \"i386\":\n            return Amd64PtraceRegisterHolder(register_file, fp_register_file)\n        case \"aarch64\":\n            return Aarch64PtraceRegisterHolder(register_file, fp_register_file)\n        case _:\n            raise NotImplementedError(f\"Architecture {architecture} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/","title":"libdebug.architectures.stack_unwinding_manager","text":""},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/#libdebug.architectures.stack_unwinding_manager.StackUnwindingManager","title":"<code>StackUnwindingManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An architecture-independent interface for stack unwinding.</p> Source code in <code>libdebug/architectures/stack_unwinding_manager.py</code> <pre><code>class StackUnwindingManager(ABC):\n    \"\"\"An architecture-independent interface for stack unwinding.\"\"\"\n\n    @abstractmethod\n    def unwind(self: StackUnwindingManager, target: ThreadContext) -&gt; list:\n        \"\"\"Unwind the stack of the target process.\"\"\"\n\n    @abstractmethod\n    def get_return_address(self: StackUnwindingManager, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n        \"\"\"Get the return address of the current function.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/#libdebug.architectures.stack_unwinding_manager.StackUnwindingManager.get_return_address","title":"<code>get_return_address(target, vmaps)</code>  <code>abstractmethod</code>","text":"<p>Get the return address of the current function.</p> Source code in <code>libdebug/architectures/stack_unwinding_manager.py</code> <pre><code>@abstractmethod\ndef get_return_address(self: StackUnwindingManager, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n    \"\"\"Get the return address of the current function.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/#libdebug.architectures.stack_unwinding_manager.StackUnwindingManager.unwind","title":"<code>unwind(target)</code>  <code>abstractmethod</code>","text":"<p>Unwind the stack of the target process.</p> Source code in <code>libdebug/architectures/stack_unwinding_manager.py</code> <pre><code>@abstractmethod\ndef unwind(self: StackUnwindingManager, target: ThreadContext) -&gt; list:\n    \"\"\"Unwind the stack of the target process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_provider/","title":"libdebug.architectures.stack_unwinding_provider","text":""},{"location":"from_pydoc/generated/architectures/stack_unwinding_provider/#libdebug.architectures.stack_unwinding_provider.stack_unwinding_provider","title":"<code>stack_unwinding_provider(architecture)</code>","text":"<p>Returns an instance of the stack unwinding provider to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/architectures/stack_unwinding_provider.py</code> <pre><code>def stack_unwinding_provider(architecture: str) -&gt; StackUnwindingManager:\n    \"\"\"Returns an instance of the stack unwinding provider to be used by the `_InternalDebugger` class.\"\"\"\n    match architecture:\n        case \"amd64\":\n            return _amd64_stack_unwinder\n        case \"aarch64\":\n            return _aarch64_stack_unwinder\n        case _:\n            raise NotImplementedError(f\"Architecture {architecture} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/syscall_hijacker/","title":"libdebug.architectures.syscall_hijacker","text":""},{"location":"from_pydoc/generated/architectures/syscall_hijacker/#libdebug.architectures.syscall_hijacker.SyscallHijacker","title":"<code>SyscallHijacker</code>","text":"<p>Class that provides syscall hijacking for the x86_64 architecture.</p> Source code in <code>libdebug/architectures/syscall_hijacker.py</code> <pre><code>class SyscallHijacker:\n    \"\"\"Class that provides syscall hijacking for the x86_64 architecture.\"\"\"\n\n    # Allowed arguments for the hijacker\n    allowed_args: set[str] = frozenset(\n        {\n            \"syscall_number\",\n            \"syscall_arg0\",\n            \"syscall_arg1\",\n            \"syscall_arg2\",\n            \"syscall_arg3\",\n            \"syscall_arg4\",\n            \"syscall_arg5\",\n        },\n    )\n\n    def create_hijacker(\n        self: SyscallHijacker,\n        new_syscall: int,\n        **kwargs: int,\n    ) -&gt; Callable[[ThreadContext, int], None]:\n        \"\"\"Create a new hijacker for the given syscall.\n\n        Args:\n            new_syscall (int): The new syscall number.\n            **kwargs: The keyword arguments.\n        \"\"\"\n\n        def hijack_on_enter_wrapper(d: ThreadContext, _: int) -&gt; None:\n            \"\"\"Wrapper for the hijack_on_enter method.\"\"\"\n            self._hijack_on_enter(d, new_syscall, **kwargs)\n\n        return hijack_on_enter_wrapper\n\n    def _hijack_on_enter(\n        self: SyscallHijacker,\n        d: ThreadContext,\n        new_syscall: int,\n        **kwargs: int,\n    ) -&gt; None:\n        \"\"\"Hijack the syscall on enter.\n\n        Args:\n            d (ThreadContext): The target ThreadContext.\n            new_syscall (int): The new syscall number.\n            **kwargs: The keyword arguments.\n        \"\"\"\n        d.syscall_number = new_syscall\n        if \"syscall_arg0\" in kwargs:\n            d.syscall_arg0 = kwargs.get(\"syscall_arg0\", False)\n        if \"syscall_arg1\" in kwargs:\n            d.syscall_arg1 = kwargs.get(\"syscall_arg1\", False)\n        if \"syscall_arg2\" in kwargs:\n            d.syscall_arg2 = kwargs.get(\"syscall_arg2\", False)\n        if \"syscall_arg3\" in kwargs:\n            d.syscall_arg3 = kwargs.get(\"syscall_arg3\", False)\n        if \"syscall_arg4\" in kwargs:\n            d.syscall_arg4 = kwargs.get(\"syscall_arg4\", False)\n        if \"syscall_arg5\" in kwargs:\n            d.syscall_arg5 = kwargs.get(\"syscall_arg5\", False)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/syscall_hijacker/#libdebug.architectures.syscall_hijacker.SyscallHijacker.create_hijacker","title":"<code>create_hijacker(new_syscall, **kwargs)</code>","text":"<p>Create a new hijacker for the given syscall.</p> <p>Parameters:</p> Name Type Description Default <code>new_syscall</code> <code>int</code> <p>The new syscall number.</p> required <code>**kwargs</code> <code>int</code> <p>The keyword arguments.</p> <code>{}</code> Source code in <code>libdebug/architectures/syscall_hijacker.py</code> <pre><code>def create_hijacker(\n    self: SyscallHijacker,\n    new_syscall: int,\n    **kwargs: int,\n) -&gt; Callable[[ThreadContext, int], None]:\n    \"\"\"Create a new hijacker for the given syscall.\n\n    Args:\n        new_syscall (int): The new syscall number.\n        **kwargs: The keyword arguments.\n    \"\"\"\n\n    def hijack_on_enter_wrapper(d: ThreadContext, _: int) -&gt; None:\n        \"\"\"Wrapper for the hijack_on_enter method.\"\"\"\n        self._hijack_on_enter(d, new_syscall, **kwargs)\n\n    return hijack_on_enter_wrapper\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_breakpoint_validator/","title":"libdebug.architectures.aarch64.aarch64_breakpoint_validator","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_breakpoint_validator/#libdebug.architectures.aarch64.aarch64_breakpoint_validator.validate_breakpoint_aarch64","title":"<code>validate_breakpoint_aarch64(bp)</code>","text":"<p>Validate a hardware breakpoint for the AARCH64 architecture.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_breakpoint_validator.py</code> <pre><code>def validate_breakpoint_aarch64(bp: Breakpoint) -&gt; None:\n    \"\"\"Validate a hardware breakpoint for the AARCH64 architecture.\"\"\"\n    if bp.condition not in [\"r\", \"w\", \"rw\", \"x\"]:\n        raise ValueError(\"Invalid condition for watchpoints. Supported conditions are 'r', 'w', 'rw', 'x'.\")\n\n    if not (1 &lt;= bp.length &lt;= 8):\n        raise ValueError(\"Invalid length for watchpoints. Supported lengths are between 1 and 8.\")\n\n    if bp.condition != \"x\" and bp.address &amp; 0x7:\n        raise ValueError(\"Watchpoint address must be aligned to 8 bytes on aarch64. This is a kernel limitation.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/","title":"libdebug.architectures.aarch64.aarch64_call_utilities","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities","title":"<code>Aarch64CallUtilities</code>","text":"<p>               Bases: <code>CallUtilitiesManager</code></p> <p>Class that provides call utilities for the AArch64 architecture.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>class Aarch64CallUtilities(CallUtilitiesManager):\n    \"\"\"Class that provides call utilities for the AArch64 architecture.\"\"\"\n\n    def is_call(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; bool:\n        \"\"\"Check if the current instruction is a call instruction.\"\"\"\n        # Check for BL instruction\n        if (opcode_window[3] &amp; 0xFC) == 0x94:\n            return True\n\n        # Check for BLR instruction\n        if opcode_window[3] == 0xD6 and (opcode_window[2] &amp; 0x3F) == 0x3F:\n            return True\n\n        return False\n\n    def compute_call_skip(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; int:\n        \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n        # Check for BL instruction\n        if self.is_call(opcode_window):\n            return 4\n\n        return 0\n\n    def get_call_and_skip_amount(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; tuple[bool, int]:\n        \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n        skip = self.compute_call_skip(opcode_window)\n        return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities.compute_call_skip","title":"<code>compute_call_skip(opcode_window)</code>","text":"<p>Compute the instruction size of the current call instruction.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>def compute_call_skip(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; int:\n    \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n    # Check for BL instruction\n    if self.is_call(opcode_window):\n        return 4\n\n    return 0\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities.get_call_and_skip_amount","title":"<code>get_call_and_skip_amount(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction and compute the instruction size.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>def get_call_and_skip_amount(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; tuple[bool, int]:\n    \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n    skip = self.compute_call_skip(opcode_window)\n    return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities.is_call","title":"<code>is_call(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>def is_call(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; bool:\n    \"\"\"Check if the current instruction is a call instruction.\"\"\"\n    # Check for BL instruction\n    if (opcode_window[3] &amp; 0xFC) == 0x94:\n        return True\n\n    # Check for BLR instruction\n    if opcode_window[3] == 0xD6 and (opcode_window[2] &amp; 0x3F) == 0x3F:\n        return True\n\n    return False\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/","title":"libdebug.architectures.aarch64.aarch64_ptrace_register_holder","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder","title":"<code>Aarch64PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PtraceRegisterHolder</code></p> <p>A class that provides views and setters for the register of an aarch64 process.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>@dataclass\nclass Aarch64PtraceRegisterHolder(PtraceRegisterHolder):\n    \"\"\"A class that provides views and setters for the register of an aarch64 process.\"\"\"\n\n    def provide_regs_class(self: Aarch64PtraceRegisterHolder) -&gt; type:\n        \"\"\"Provide a class to hold the register accessors.\"\"\"\n        return Aarch64Registers\n\n    def apply_on_regs(self: Aarch64PtraceRegisterHolder, target: Aarch64Registers, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the Aarch64Registers class.\"\"\"\n        target.register_file = self.register_file\n        target._fp_register_file = self.fp_register_file\n\n        if hasattr(target_class, \"w0\"):\n            return\n\n        for i in range(31):\n            name_64 = f\"x{i}\"\n            name_32 = f\"w{i}\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n\n        # setup the floating point registers\n        for i in range(32):\n            name_v = f\"v{i}\"\n            name_128 = f\"q{i}\"\n            name_64 = f\"d{i}\"\n            name_32 = f\"s{i}\"\n            name_16 = f\"h{i}\"\n            name_8 = f\"b{i}\"\n            setattr(target_class, name_v, _get_property_fp_128(name_v, i))\n            setattr(target_class, name_128, _get_property_fp_128(name_128, i))\n            setattr(target_class, name_64, _get_property_fp_64(name_64, i))\n            setattr(target_class, name_32, _get_property_fp_32(name_32, i))\n            setattr(target_class, name_16, _get_property_fp_16(name_16, i))\n            setattr(target_class, name_8, _get_property_fp_8(name_8, i))\n\n        # setup special aarch64 registers\n        target_class.pc = _get_property_64(\"pc\")\n        target_class.sp = _get_property_64(\"sp\")\n        target_class.lr = _get_property_64(\"x30\")\n        target_class.fp = _get_property_64(\"x29\")\n        target_class.xzr = _get_property_zr(\"xzr\")\n        target_class.wzr = _get_property_zr(\"wzr\")\n\n    def apply_on_thread(self: Aarch64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the thread class.\"\"\"\n        target.register_file = self.register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"instruction_pointer\"):\n            return\n\n        # setup generic \"instruction_pointer\" property\n        target_class.instruction_pointer = _get_property_64(\"pc\")\n\n        # setup generic syscall properties\n        target_class.syscall_return = _get_property_64(\"x0\")\n        target_class.syscall_arg0 = _get_property_64(\"x0\")\n        target_class.syscall_arg1 = _get_property_64(\"x1\")\n        target_class.syscall_arg2 = _get_property_64(\"x2\")\n        target_class.syscall_arg3 = _get_property_64(\"x3\")\n        target_class.syscall_arg4 = _get_property_64(\"x4\")\n        target_class.syscall_arg5 = _get_property_64(\"x5\")\n\n        # syscall number handling is special on aarch64, as the original number is stored in x8\n        # but writing to x8 isn't enough to change the actual called syscall\n        target_class.syscall_number = _get_property_syscall_num()\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>","text":"<p>Apply the register accessors to the Aarch64Registers class.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def apply_on_regs(self: Aarch64PtraceRegisterHolder, target: Aarch64Registers, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the Aarch64Registers class.\"\"\"\n    target.register_file = self.register_file\n    target._fp_register_file = self.fp_register_file\n\n    if hasattr(target_class, \"w0\"):\n        return\n\n    for i in range(31):\n        name_64 = f\"x{i}\"\n        name_32 = f\"w{i}\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n\n    # setup the floating point registers\n    for i in range(32):\n        name_v = f\"v{i}\"\n        name_128 = f\"q{i}\"\n        name_64 = f\"d{i}\"\n        name_32 = f\"s{i}\"\n        name_16 = f\"h{i}\"\n        name_8 = f\"b{i}\"\n        setattr(target_class, name_v, _get_property_fp_128(name_v, i))\n        setattr(target_class, name_128, _get_property_fp_128(name_128, i))\n        setattr(target_class, name_64, _get_property_fp_64(name_64, i))\n        setattr(target_class, name_32, _get_property_fp_32(name_32, i))\n        setattr(target_class, name_16, _get_property_fp_16(name_16, i))\n        setattr(target_class, name_8, _get_property_fp_8(name_8, i))\n\n    # setup special aarch64 registers\n    target_class.pc = _get_property_64(\"pc\")\n    target_class.sp = _get_property_64(\"sp\")\n    target_class.lr = _get_property_64(\"x30\")\n    target_class.fp = _get_property_64(\"x29\")\n    target_class.xzr = _get_property_zr(\"xzr\")\n    target_class.wzr = _get_property_zr(\"wzr\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>","text":"<p>Apply the register accessors to the thread class.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def apply_on_thread(self: Aarch64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the thread class.\"\"\"\n    target.register_file = self.register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"instruction_pointer\"):\n        return\n\n    # setup generic \"instruction_pointer\" property\n    target_class.instruction_pointer = _get_property_64(\"pc\")\n\n    # setup generic syscall properties\n    target_class.syscall_return = _get_property_64(\"x0\")\n    target_class.syscall_arg0 = _get_property_64(\"x0\")\n    target_class.syscall_arg1 = _get_property_64(\"x1\")\n    target_class.syscall_arg2 = _get_property_64(\"x2\")\n    target_class.syscall_arg3 = _get_property_64(\"x3\")\n    target_class.syscall_arg4 = _get_property_64(\"x4\")\n    target_class.syscall_arg5 = _get_property_64(\"x5\")\n\n    # syscall number handling is special on aarch64, as the original number is stored in x8\n    # but writing to x8 isn't enough to change the actual called syscall\n    target_class.syscall_number = _get_property_syscall_num()\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.provide_regs_class","title":"<code>provide_regs_class()</code>","text":"<p>Provide a class to hold the register accessors.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def provide_regs_class(self: Aarch64PtraceRegisterHolder) -&gt; type:\n    \"\"\"Provide a class to hold the register accessors.\"\"\"\n    return Aarch64Registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_registers/","title":"libdebug.architectures.aarch64.aarch64_registers","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_registers/#libdebug.architectures.aarch64.aarch64_registers.Aarch64Registers","title":"<code>Aarch64Registers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registers</code></p> <p>This class holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_registers.py</code> <pre><code>@dataclass\nclass Aarch64Registers(Registers):\n    \"\"\"This class holds the state of the architectural-dependent registers of a process.\"\"\"\n\n    def __init__(self: Aarch64Registers, thread_id: int) -&gt; None:\n        \"\"\"Initializes the Registers object.\"\"\"\n        self._internal_debugger = get_global_internal_debugger()\n        self._thread_id = thread_id\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_registers/#libdebug.architectures.aarch64.aarch64_registers.Aarch64Registers.__init__","title":"<code>__init__(thread_id)</code>","text":"<p>Initializes the Registers object.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_registers.py</code> <pre><code>def __init__(self: Aarch64Registers, thread_id: int) -&gt; None:\n    \"\"\"Initializes the Registers object.\"\"\"\n    self._internal_debugger = get_global_internal_debugger()\n    self._thread_id = thread_id\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/","title":"libdebug.architectures.aarch64.aarch64_stack_unwinder","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/#libdebug.architectures.aarch64.aarch64_stack_unwinder.Aarch64StackUnwinder","title":"<code>Aarch64StackUnwinder</code>","text":"<p>               Bases: <code>StackUnwindingManager</code></p> <p>Class that provides stack unwinding for the AArch64 architecture.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_stack_unwinder.py</code> <pre><code>class Aarch64StackUnwinder(StackUnwindingManager):\n    \"\"\"Class that provides stack unwinding for the AArch64 architecture.\"\"\"\n\n    def unwind(self: Aarch64StackUnwinder, target: ThreadContext) -&gt; list:\n        \"\"\"Unwind the stack of a process.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n\n        Returns:\n            list: A list of return addresses.\n        \"\"\"\n        assert hasattr(target.regs, \"pc\")\n\n        frame_pointer = target.regs.x29\n\n        vmaps = target._internal_debugger.debugging_interface.maps()\n        initial_link_register = None\n\n        try:\n            initial_link_register = self.get_return_address(target, vmaps)\n        except ValueError:\n            liblog.warning(\n                \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n            )\n\n        stack_trace = [target.regs.pc, initial_link_register] if initial_link_register else [target.regs.pc]\n\n        # Follow the frame chain\n        while frame_pointer:\n            try:\n                link_register = int.from_bytes(target.memory[frame_pointer + 8, 8, \"absolute\"], byteorder=\"little\")\n                frame_pointer = int.from_bytes(target.memory[frame_pointer, 8, \"absolute\"], byteorder=\"little\")\n\n                if not any(vmap.start &lt;= link_register &lt; vmap.end for vmap in vmaps):\n                    break\n\n                # Leaf functions don't set the previous stack frame pointer\n                # But they set the link register to the return address\n                # Non-leaf functions set both\n                if initial_link_register and link_register == initial_link_register:\n                    initial_link_register = None\n                    continue\n\n                stack_trace.append(link_register)\n            except (OSError, ValueError):\n                break\n\n        return stack_trace\n\n    def get_return_address(self: Aarch64StackUnwinder, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n        \"\"\"Get the return address of the current function.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n            vmaps (list[MemoryMap]): The memory maps of the process.\n\n        Returns:\n            int: The return address.\n        \"\"\"\n        return_address = target.regs.x30\n\n        if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n            raise ValueError(\"Return address not in any valid memory map\")\n\n        return return_address\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/#libdebug.architectures.aarch64.aarch64_stack_unwinder.Aarch64StackUnwinder.get_return_address","title":"<code>get_return_address(target, vmaps)</code>","text":"<p>Get the return address of the current function.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <code>vmaps</code> <code>list[MemoryMap]</code> <p>The memory maps of the process.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The return address.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_stack_unwinder.py</code> <pre><code>def get_return_address(self: Aarch64StackUnwinder, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n    \"\"\"Get the return address of the current function.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n        vmaps (list[MemoryMap]): The memory maps of the process.\n\n    Returns:\n        int: The return address.\n    \"\"\"\n    return_address = target.regs.x30\n\n    if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n        raise ValueError(\"Return address not in any valid memory map\")\n\n    return return_address\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/#libdebug.architectures.aarch64.aarch64_stack_unwinder.Aarch64StackUnwinder.unwind","title":"<code>unwind(target)</code>","text":"<p>Unwind the stack of a process.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of return addresses.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_stack_unwinder.py</code> <pre><code>def unwind(self: Aarch64StackUnwinder, target: ThreadContext) -&gt; list:\n    \"\"\"Unwind the stack of a process.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n\n    Returns:\n        list: A list of return addresses.\n    \"\"\"\n    assert hasattr(target.regs, \"pc\")\n\n    frame_pointer = target.regs.x29\n\n    vmaps = target._internal_debugger.debugging_interface.maps()\n    initial_link_register = None\n\n    try:\n        initial_link_register = self.get_return_address(target, vmaps)\n    except ValueError:\n        liblog.warning(\n            \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n        )\n\n    stack_trace = [target.regs.pc, initial_link_register] if initial_link_register else [target.regs.pc]\n\n    # Follow the frame chain\n    while frame_pointer:\n        try:\n            link_register = int.from_bytes(target.memory[frame_pointer + 8, 8, \"absolute\"], byteorder=\"little\")\n            frame_pointer = int.from_bytes(target.memory[frame_pointer, 8, \"absolute\"], byteorder=\"little\")\n\n            if not any(vmap.start &lt;= link_register &lt; vmap.end for vmap in vmaps):\n                break\n\n            # Leaf functions don't set the previous stack frame pointer\n            # But they set the link register to the return address\n            # Non-leaf functions set both\n            if initial_link_register and link_register == initial_link_register:\n                initial_link_register = None\n                continue\n\n            stack_trace.append(link_register)\n        except (OSError, ValueError):\n            break\n\n    return stack_trace\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_breakpoint_validator/","title":"libdebug.architectures.amd64.amd64_breakpoint_validator","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_breakpoint_validator/#libdebug.architectures.amd64.amd64_breakpoint_validator.validate_breakpoint_amd64","title":"<code>validate_breakpoint_amd64(bp)</code>","text":"<p>Validate a hardware breakpoint for the AMD64 architecture.</p> Source code in <code>libdebug/architectures/amd64/amd64_breakpoint_validator.py</code> <pre><code>def validate_breakpoint_amd64(bp: Breakpoint) -&gt; None:\n    \"\"\"Validate a hardware breakpoint for the AMD64 architecture.\"\"\"\n    if bp.condition not in [\"w\", \"rw\", \"x\"]:\n        raise ValueError(\"Invalid condition for watchpoints. Supported conditions are 'w', 'rw', 'x'.\")\n\n    if bp.length not in [1, 2, 4, 8]:\n        raise ValueError(\"Invalid length for watchpoints. Supported lengths are 1, 2, 4, 8.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/","title":"libdebug.architectures.amd64.amd64_call_utilities","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities","title":"<code>Amd64CallUtilities</code>","text":"<p>               Bases: <code>CallUtilitiesManager</code></p> <p>Class that provides call utilities for the x86_64 architecture.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>class Amd64CallUtilities(CallUtilitiesManager):\n    \"\"\"Class that provides call utilities for the x86_64 architecture.\"\"\"\n\n    def is_call(self, opcode_window: bytes) -&gt; bool:\n        \"\"\"Check if the current instruction is a call instruction.\"\"\"\n        # Check for direct CALL (E8 xx xx xx xx)\n        if opcode_window[0] == 0xE8:\n            return True\n\n        # Check for indirect CALL using ModR/M (FF /2)\n        if opcode_window[0] == 0xFF:\n            # Extract ModR/M byte\n            modRM = opcode_window[1]\n            reg = (modRM &gt;&gt; 3) &amp; 0x07  # Middle three bits\n\n            if reg == 2:\n                return True\n\n        return False\n\n    def compute_call_skip(self, opcode_window: bytes) -&gt; int:\n        \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n        # Check for direct CALL (E8 xx xx xx xx)\n        if opcode_window[0] == 0xE8:\n            return 5  # Direct CALL\n\n        # Check for indirect CALL using ModR/M (FF /2)\n        if opcode_window[0] == 0xFF:\n            # Extract ModR/M byte\n            modRM = opcode_window[1]\n            mod = (modRM &gt;&gt; 6) &amp; 0x03  # First two bits\n            reg = (modRM &gt;&gt; 3) &amp; 0x07  # Next three bits\n\n            # Check if reg field is 010 (indirect CALL)\n            if reg == 2:\n                if mod == 0:\n                    if (modRM &amp; 0x07) == 4:\n                        return 3 + (4 if opcode_window[2] == 0x25 else 0)  # SIB byte + optional disp32\n                    elif (modRM &amp; 0x07) == 5:\n                        return 6  # disp32\n                    return 2  # No displacement\n                elif mod == 1:\n                    return 3  # disp8\n                elif mod == 2:\n                    return 6  # disp32\n                elif mod == 3:\n                    return 2  # Register direct\n\n        return 0  # Not a CALL\n\n    def get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n        \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n        skip = self.compute_call_skip(opcode_window)\n        return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities.compute_call_skip","title":"<code>compute_call_skip(opcode_window)</code>","text":"<p>Compute the instruction size of the current call instruction.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>def compute_call_skip(self, opcode_window: bytes) -&gt; int:\n    \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n    # Check for direct CALL (E8 xx xx xx xx)\n    if opcode_window[0] == 0xE8:\n        return 5  # Direct CALL\n\n    # Check for indirect CALL using ModR/M (FF /2)\n    if opcode_window[0] == 0xFF:\n        # Extract ModR/M byte\n        modRM = opcode_window[1]\n        mod = (modRM &gt;&gt; 6) &amp; 0x03  # First two bits\n        reg = (modRM &gt;&gt; 3) &amp; 0x07  # Next three bits\n\n        # Check if reg field is 010 (indirect CALL)\n        if reg == 2:\n            if mod == 0:\n                if (modRM &amp; 0x07) == 4:\n                    return 3 + (4 if opcode_window[2] == 0x25 else 0)  # SIB byte + optional disp32\n                elif (modRM &amp; 0x07) == 5:\n                    return 6  # disp32\n                return 2  # No displacement\n            elif mod == 1:\n                return 3  # disp8\n            elif mod == 2:\n                return 6  # disp32\n            elif mod == 3:\n                return 2  # Register direct\n\n    return 0  # Not a CALL\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities.get_call_and_skip_amount","title":"<code>get_call_and_skip_amount(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction and compute the instruction size.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>def get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n    \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n    skip = self.compute_call_skip(opcode_window)\n    return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities.is_call","title":"<code>is_call(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>def is_call(self, opcode_window: bytes) -&gt; bool:\n    \"\"\"Check if the current instruction is a call instruction.\"\"\"\n    # Check for direct CALL (E8 xx xx xx xx)\n    if opcode_window[0] == 0xE8:\n        return True\n\n    # Check for indirect CALL using ModR/M (FF /2)\n    if opcode_window[0] == 0xFF:\n        # Extract ModR/M byte\n        modRM = opcode_window[1]\n        reg = (modRM &gt;&gt; 3) &amp; 0x07  # Middle three bits\n\n        if reg == 2:\n            return True\n\n    return False\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/","title":"libdebug.architectures.amd64.amd64_ptrace_register_holder","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder","title":"<code>Amd64PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PtraceRegisterHolder</code></p> <p>A class that provides views and setters for the registers of an x86_64 process.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>@dataclass\nclass Amd64PtraceRegisterHolder(PtraceRegisterHolder):\n    \"\"\"A class that provides views and setters for the registers of an x86_64 process.\"\"\"\n\n    def provide_regs_class(self: Amd64PtraceRegisterHolder) -&gt; type:\n        \"\"\"Provide a class to hold the register accessors.\"\"\"\n        return Amd64Registers\n\n    def apply_on_regs(self: Amd64PtraceRegisterHolder, target: Amd64Registers, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the Amd64Registers class.\"\"\"\n        target.register_file = self.register_file\n        target._fp_register_file = self.fp_register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"rip\"):\n            return\n\n        # setup accessors\n        for name in AMD64_GP_REGS:\n            name_64 = \"r\" + name + \"x\"\n            name_32 = \"e\" + name + \"x\"\n            name_16 = name + \"x\"\n            name_8l = name + \"l\"\n            name_8h = name + \"h\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n            setattr(target_class, name_8h, _get_property_8h(name_64))\n\n        for name in AMD64_BASE_REGS:\n            name_64 = \"r\" + name\n            name_32 = \"e\" + name\n            name_16 = name\n            name_8l = name + \"l\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n\n        for name in AMD64_EXT_REGS:\n            name_64 = name\n            name_32 = name + \"d\"\n            name_16 = name + \"w\"\n            name_8l = name + \"b\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n\n        # setup special registers\n        target_class.rip = _get_property_64(\"rip\")\n\n        # setup floating-point registers\n        # see libdebug/cffi/ptrace_cffi_build.py for the possible values of fp_register_file.type\n        match self.fp_register_file.type:\n            case 0:\n                self._handle_fp_512(target_class)\n            case 1:\n                self._handle_fp_896(target_class)\n            case 2:\n                self._handle_fp_2696(target_class)\n            case _:\n                raise NotImplementedError(\n                    f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n                )\n\n    def apply_on_thread(self: Amd64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the thread class.\"\"\"\n        target.register_file = self.register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"instruction_pointer\"):\n            return\n\n        # setup generic \"instruction_pointer\" property\n        target_class.instruction_pointer = _get_property_64(\"rip\")\n\n        # setup generic syscall properties\n        target_class.syscall_number = _get_property_64(\"orig_rax\")\n        target_class.syscall_return = _get_property_64(\"rax\")\n        target_class.syscall_arg0 = _get_property_64(\"rdi\")\n        target_class.syscall_arg1 = _get_property_64(\"rsi\")\n        target_class.syscall_arg2 = _get_property_64(\"rdx\")\n        target_class.syscall_arg3 = _get_property_64(\"r10\")\n        target_class.syscall_arg4 = _get_property_64(\"r8\")\n        target_class.syscall_arg5 = _get_property_64(\"r9\")\n\n    def _handle_fp_512(self: Amd64PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 512 bytes long, which means we just have the xmm registers.\"\"\"\n        for index in range(16):\n            name = f\"xmm{index}\"\n            setattr(target_class, name, _get_property_fp_xmm0(name, index))\n\n    def _handle_fp_896(self: Amd64PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 896 bytes long, which means we have the xmm and ymm registers.\"\"\"\n        for index in range(16):\n            name = f\"xmm{index}\"\n            setattr(target_class, name, _get_property_fp_xmm0(name, index))\n\n        for index in range(16):\n            name = f\"ymm{index}\"\n            setattr(target_class, name, _get_property_fp_ymm0(name, index))\n\n    def _handle_fp_2696(self: Amd64PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 2696 bytes long, which means we have 32 zmm registers.\"\"\"\n        for index in range(16):\n            name = f\"xmm{index}\"\n            setattr(target_class, name, _get_property_fp_xmm0(name, index))\n\n        for index in range(16):\n            name = f\"ymm{index}\"\n            setattr(target_class, name, _get_property_fp_ymm0(name, index))\n\n        for index in range(16):\n            name = f\"zmm{index}\"\n            setattr(target_class, name, _get_property_fp_zmm0(name, index))\n\n        for index in range(16):\n            name = f\"xmm{index + 16}\"\n            setattr(target_class, name, _get_property_fp_xmm1(name, index))\n\n        for index in range(16):\n            name = f\"ymm{index + 16}\"\n            setattr(target_class, name, _get_property_fp_ymm1(name, index))\n\n        for index in range(16):\n            name = f\"zmm{index + 16}\"\n            setattr(target_class, name, _get_property_fp_zmm1(name, index))\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>","text":"<p>Apply the register accessors to the Amd64Registers class.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def apply_on_regs(self: Amd64PtraceRegisterHolder, target: Amd64Registers, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the Amd64Registers class.\"\"\"\n    target.register_file = self.register_file\n    target._fp_register_file = self.fp_register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"rip\"):\n        return\n\n    # setup accessors\n    for name in AMD64_GP_REGS:\n        name_64 = \"r\" + name + \"x\"\n        name_32 = \"e\" + name + \"x\"\n        name_16 = name + \"x\"\n        name_8l = name + \"l\"\n        name_8h = name + \"h\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n        setattr(target_class, name_8h, _get_property_8h(name_64))\n\n    for name in AMD64_BASE_REGS:\n        name_64 = \"r\" + name\n        name_32 = \"e\" + name\n        name_16 = name\n        name_8l = name + \"l\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n\n    for name in AMD64_EXT_REGS:\n        name_64 = name\n        name_32 = name + \"d\"\n        name_16 = name + \"w\"\n        name_8l = name + \"b\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n\n    # setup special registers\n    target_class.rip = _get_property_64(\"rip\")\n\n    # setup floating-point registers\n    # see libdebug/cffi/ptrace_cffi_build.py for the possible values of fp_register_file.type\n    match self.fp_register_file.type:\n        case 0:\n            self._handle_fp_512(target_class)\n        case 1:\n            self._handle_fp_896(target_class)\n        case 2:\n            self._handle_fp_2696(target_class)\n        case _:\n            raise NotImplementedError(\n                f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n            )\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>","text":"<p>Apply the register accessors to the thread class.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def apply_on_thread(self: Amd64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the thread class.\"\"\"\n    target.register_file = self.register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"instruction_pointer\"):\n        return\n\n    # setup generic \"instruction_pointer\" property\n    target_class.instruction_pointer = _get_property_64(\"rip\")\n\n    # setup generic syscall properties\n    target_class.syscall_number = _get_property_64(\"orig_rax\")\n    target_class.syscall_return = _get_property_64(\"rax\")\n    target_class.syscall_arg0 = _get_property_64(\"rdi\")\n    target_class.syscall_arg1 = _get_property_64(\"rsi\")\n    target_class.syscall_arg2 = _get_property_64(\"rdx\")\n    target_class.syscall_arg3 = _get_property_64(\"r10\")\n    target_class.syscall_arg4 = _get_property_64(\"r8\")\n    target_class.syscall_arg5 = _get_property_64(\"r9\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.provide_regs_class","title":"<code>provide_regs_class()</code>","text":"<p>Provide a class to hold the register accessors.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def provide_regs_class(self: Amd64PtraceRegisterHolder) -&gt; type:\n    \"\"\"Provide a class to hold the register accessors.\"\"\"\n    return Amd64Registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_registers/","title":"libdebug.architectures.amd64.amd64_registers","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_registers/#libdebug.architectures.amd64.amd64_registers.Amd64Registers","title":"<code>Amd64Registers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registers</code></p> <p>This class holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/architectures/amd64/amd64_registers.py</code> <pre><code>@dataclass\nclass Amd64Registers(Registers):\n    \"\"\"This class holds the state of the architectural-dependent registers of a process.\"\"\"\n\n    def __init__(self: Amd64Registers, thread_id: int) -&gt; None:\n        \"\"\"Initializes the Registers object.\"\"\"\n        self._internal_debugger = get_global_internal_debugger()\n        self._thread_id = thread_id\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_registers/#libdebug.architectures.amd64.amd64_registers.Amd64Registers.__init__","title":"<code>__init__(thread_id)</code>","text":"<p>Initializes the Registers object.</p> Source code in <code>libdebug/architectures/amd64/amd64_registers.py</code> <pre><code>def __init__(self: Amd64Registers, thread_id: int) -&gt; None:\n    \"\"\"Initializes the Registers object.\"\"\"\n    self._internal_debugger = get_global_internal_debugger()\n    self._thread_id = thread_id\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/","title":"libdebug.architectures.amd64.amd64_stack_unwinder","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/#libdebug.architectures.amd64.amd64_stack_unwinder.Amd64StackUnwinder","title":"<code>Amd64StackUnwinder</code>","text":"<p>               Bases: <code>StackUnwindingManager</code></p> <p>Class that provides stack unwinding for the x86_64 architecture.</p> Source code in <code>libdebug/architectures/amd64/amd64_stack_unwinder.py</code> <pre><code>class Amd64StackUnwinder(StackUnwindingManager):\n    \"\"\"Class that provides stack unwinding for the x86_64 architecture.\"\"\"\n\n    def unwind(self: Amd64StackUnwinder, target: ThreadContext) -&gt; list:\n        \"\"\"Unwind the stack of a process.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n\n        Returns:\n            list: A list of return addresses.\n        \"\"\"\n        assert hasattr(target.regs, \"rip\")\n        assert hasattr(target.regs, \"rbp\")\n\n        current_rbp = target.regs.rbp\n        stack_trace = [target.regs.rip]\n\n        vmaps = target._internal_debugger.debugging_interface.maps()\n\n        while current_rbp:\n            try:\n                # Read the return address\n                return_address = int.from_bytes(target.memory[current_rbp + 8, 8, \"absolute\"], byteorder=\"little\")\n\n                if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n                    break\n\n                # Read the previous rbp and set it as the current one\n                current_rbp = int.from_bytes(target.memory[current_rbp, 8, \"absolute\"], byteorder=\"little\")\n\n                stack_trace.append(return_address)\n            except (OSError, ValueError):\n                break\n\n        # If we are in the prolouge of a function, we need to get the return address from the stack\n        # using a slightly more complex method\n        try:\n            first_return_address = self.get_return_address(target, vmaps)\n\n            if len(stack_trace) &gt; 1:\n                if first_return_address != stack_trace[1]:\n                    stack_trace.insert(1, first_return_address)\n            else:\n                stack_trace.append(first_return_address)\n        except (OSError, ValueError):\n            liblog.warning(\n                \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n            )\n\n        return stack_trace\n\n    def get_return_address(self: Amd64StackUnwinder, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n        \"\"\"Get the return address of the current function.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n            vmaps (list[MemoryMap]): The memory maps of the process.\n\n        Returns:\n            int: The return address.\n        \"\"\"\n        instruction_window = target.memory[target.regs.rip, 4, \"absolute\"]\n\n        # Check if the instruction window is a function preamble and handle each case\n        return_address = None\n\n        if self._preamble_state(instruction_window) == 0:\n            return_address = target.memory[target.regs.rbp + 8, 8, \"absolute\"]\n        elif self._preamble_state(instruction_window) == 1:\n            return_address = target.memory[target.regs.rsp, 8, \"absolute\"]\n        else:\n            return_address = target.memory[target.regs.rsp + 8, 8, \"absolute\"]\n\n        return_address = int.from_bytes(return_address, byteorder=\"little\")\n\n        if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n            raise ValueError(\"Return address not in any valid memory map\")\n\n        return return_address\n\n    def _preamble_state(self: Amd64StackUnwinder, instruction_window: bytes) -&gt; int:\n        \"\"\"Check if the instruction window is a function preamble and if so at what stage.\n\n        Args:\n            instruction_window (bytes): The instruction window.\n\n        Returns:\n            int: 0 if not a preamble, 1 if rbp has not been pushed yet, 2 otherwise\n        \"\"\"\n        preamble_state = 0\n\n        # endbr64 and push rbp\n        if b\"\\xf3\\x0f\\x1e\\xfa\" in instruction_window or b\"\\x55\" in instruction_window:\n            preamble_state = 1\n        # mov rbp, rsp\n        elif b\"\\x48\\x89\\xe5\" in instruction_window:\n            preamble_state = 2\n\n        return preamble_state\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/#libdebug.architectures.amd64.amd64_stack_unwinder.Amd64StackUnwinder.get_return_address","title":"<code>get_return_address(target, vmaps)</code>","text":"<p>Get the return address of the current function.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <code>vmaps</code> <code>list[MemoryMap]</code> <p>The memory maps of the process.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The return address.</p> Source code in <code>libdebug/architectures/amd64/amd64_stack_unwinder.py</code> <pre><code>def get_return_address(self: Amd64StackUnwinder, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n    \"\"\"Get the return address of the current function.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n        vmaps (list[MemoryMap]): The memory maps of the process.\n\n    Returns:\n        int: The return address.\n    \"\"\"\n    instruction_window = target.memory[target.regs.rip, 4, \"absolute\"]\n\n    # Check if the instruction window is a function preamble and handle each case\n    return_address = None\n\n    if self._preamble_state(instruction_window) == 0:\n        return_address = target.memory[target.regs.rbp + 8, 8, \"absolute\"]\n    elif self._preamble_state(instruction_window) == 1:\n        return_address = target.memory[target.regs.rsp, 8, \"absolute\"]\n    else:\n        return_address = target.memory[target.regs.rsp + 8, 8, \"absolute\"]\n\n    return_address = int.from_bytes(return_address, byteorder=\"little\")\n\n    if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n        raise ValueError(\"Return address not in any valid memory map\")\n\n    return return_address\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/#libdebug.architectures.amd64.amd64_stack_unwinder.Amd64StackUnwinder.unwind","title":"<code>unwind(target)</code>","text":"<p>Unwind the stack of a process.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of return addresses.</p> Source code in <code>libdebug/architectures/amd64/amd64_stack_unwinder.py</code> <pre><code>def unwind(self: Amd64StackUnwinder, target: ThreadContext) -&gt; list:\n    \"\"\"Unwind the stack of a process.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n\n    Returns:\n        list: A list of return addresses.\n    \"\"\"\n    assert hasattr(target.regs, \"rip\")\n    assert hasattr(target.regs, \"rbp\")\n\n    current_rbp = target.regs.rbp\n    stack_trace = [target.regs.rip]\n\n    vmaps = target._internal_debugger.debugging_interface.maps()\n\n    while current_rbp:\n        try:\n            # Read the return address\n            return_address = int.from_bytes(target.memory[current_rbp + 8, 8, \"absolute\"], byteorder=\"little\")\n\n            if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n                break\n\n            # Read the previous rbp and set it as the current one\n            current_rbp = int.from_bytes(target.memory[current_rbp, 8, \"absolute\"], byteorder=\"little\")\n\n            stack_trace.append(return_address)\n        except (OSError, ValueError):\n            break\n\n    # If we are in the prolouge of a function, we need to get the return address from the stack\n    # using a slightly more complex method\n    try:\n        first_return_address = self.get_return_address(target, vmaps)\n\n        if len(stack_trace) &gt; 1:\n            if first_return_address != stack_trace[1]:\n                stack_trace.insert(1, first_return_address)\n        else:\n            stack_trace.append(first_return_address)\n    except (OSError, ValueError):\n        liblog.warning(\n            \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n        )\n\n    return stack_trace\n</code></pre>"},{"location":"from_pydoc/generated/builtin/antidebug_syscall_handler/","title":"libdebug.builtin.antidebug_syscall_handler","text":""},{"location":"from_pydoc/generated/builtin/antidebug_syscall_handler/#libdebug.builtin.antidebug_syscall_handler.on_enter_ptrace","title":"<code>on_enter_ptrace(t, handler)</code>","text":"<p>Callback for ptrace syscall onenter.</p> Source code in <code>libdebug/builtin/antidebug_syscall_handler.py</code> <pre><code>def on_enter_ptrace(t: ThreadContext, handler: SyscallHandler) -&gt; None:\n    \"\"\"Callback for ptrace syscall onenter.\"\"\"\n    handler._command = t.syscall_arg0\n\n    command = Commands(t.syscall_arg0)\n    liblog.debugger(f\"entered ptrace syscall with request: {command.name}\")\n</code></pre>"},{"location":"from_pydoc/generated/builtin/antidebug_syscall_handler/#libdebug.builtin.antidebug_syscall_handler.on_exit_ptrace","title":"<code>on_exit_ptrace(t, handler)</code>","text":"<p>Callback for ptrace syscall onexit.</p> Source code in <code>libdebug/builtin/antidebug_syscall_handler.py</code> <pre><code>def on_exit_ptrace(t: ThreadContext, handler: SyscallHandler) -&gt; None:\n    \"\"\"Callback for ptrace syscall onexit.\"\"\"\n    if handler._command is None:\n        liblog.error(\"ptrace onexit called without corresponding onenter. This should not happen.\")\n        return\n\n    match handler._command:\n        case Commands.PTRACE_TRACEME:\n            if not handler._traceme_called:\n                handler._traceme_called = True\n                t.syscall_return = 0\n        case _:\n            liblog.error(f\"ptrace syscall with request {handler._command} not supported\")\n</code></pre>"},{"location":"from_pydoc/generated/builtin/pretty_print_syscall_handler/","title":"libdebug.builtin.pretty_print_syscall_handler","text":""},{"location":"from_pydoc/generated/builtin/pretty_print_syscall_handler/#libdebug.builtin.pretty_print_syscall_handler.pprint_on_enter","title":"<code>pprint_on_enter(d, syscall_number, **kwargs)</code>","text":"<p>Function that will be called when a syscall is entered in pretty print mode.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>ThreadContext</code> <p>the thread context.</p> required <code>syscall_number</code> <code>int</code> <p>the syscall number.</p> required <code>**kwargs</code> <code>bool</code> <p>the keyword arguments.</p> <code>{}</code> Source code in <code>libdebug/builtin/pretty_print_syscall_handler.py</code> <pre><code>def pprint_on_enter(d: ThreadContext, syscall_number: int, **kwargs: int) -&gt; None:\n    \"\"\"Function that will be called when a syscall is entered in pretty print mode.\n\n    Args:\n        d (ThreadContext): the thread context.\n        syscall_number (int): the syscall number.\n        **kwargs (bool): the keyword arguments.\n    \"\"\"\n    syscall_name = resolve_syscall_name(d._internal_debugger.arch, syscall_number)\n    syscall_args = resolve_syscall_arguments(d._internal_debugger.arch, syscall_number)\n\n    values = [\n        d.syscall_arg0,\n        d.syscall_arg1,\n        d.syscall_arg2,\n        d.syscall_arg3,\n        d.syscall_arg4,\n        d.syscall_arg5,\n    ]\n\n    if \"old_args\" in kwargs:\n        old_args = kwargs[\"old_args\"]\n        entries = [\n            f\"{arg} = {PrintStyle.BRIGHT_YELLOW}0x{value:x}{PrintStyle.DEFAULT_COLOR}\"\n            if old_value == value\n            else f\"{arg} = {PrintStyle.BRIGHT_YELLOW}0x{old_value:x} -&gt; {PrintStyle.BRIGHT_YELLOW}0x{value:x}{PrintStyle.DEFAULT_COLOR}\"\n            for arg, value, old_value in zip(syscall_args, values, old_args, strict=False)\n            if arg is not None\n        ]\n    else:\n        entries = [\n            f\"{arg} = {PrintStyle.BRIGHT_YELLOW}0x{value:x}{PrintStyle.DEFAULT_COLOR}\"\n            for arg, value in zip(syscall_args, values, strict=False)\n            if arg is not None\n        ]\n\n    hijacked = kwargs.get(\"hijacked\", False)\n    user_handled = kwargs.get(\"callback\", False)\n    if hijacked:\n        print(\n            f\"{PrintStyle.RED}(user hijacked) {PrintStyle.STRIKE}{PrintStyle.BLUE}{syscall_name}{PrintStyle.DEFAULT_COLOR}({', '.join(entries)}){PrintStyle.RESET}\",\n        )\n    elif user_handled:\n        print(\n            f\"{PrintStyle.RED}(callback) {PrintStyle.BLUE}{syscall_name}{PrintStyle.DEFAULT_COLOR}({', '.join(entries)}) = \",\n            end=\"\",\n        )\n    else:\n        print(\n            f\"{PrintStyle.BLUE}{syscall_name}{PrintStyle.DEFAULT_COLOR}({', '.join(entries)}) = \",\n            end=\"\",\n        )\n</code></pre>"},{"location":"from_pydoc/generated/builtin/pretty_print_syscall_handler/#libdebug.builtin.pretty_print_syscall_handler.pprint_on_exit","title":"<code>pprint_on_exit(syscall_return)</code>","text":"<p>Function that will be called when a syscall is exited in pretty print mode.</p> <p>Parameters:</p> Name Type Description Default <code>syscall_return</code> <code>int | list[int]</code> <p>the syscall return value.</p> required Source code in <code>libdebug/builtin/pretty_print_syscall_handler.py</code> <pre><code>def pprint_on_exit(syscall_return: int | tuple[int, int]) -&gt; None:\n    \"\"\"Function that will be called when a syscall is exited in pretty print mode.\n\n    Args:\n        syscall_return (int | list[int]): the syscall return value.\n    \"\"\"\n    if isinstance(syscall_return, tuple):\n        print(\n            f\"{PrintStyle.YELLOW}{PrintStyle.STRIKE}0x{syscall_return[0]:x}{PrintStyle.RESET} {PrintStyle.YELLOW}0x{syscall_return[1]:x}{PrintStyle.RESET}\",\n        )\n    else:\n        print(f\"{PrintStyle.YELLOW}0x{syscall_return:x}{PrintStyle.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/cffi/debug_sym_cffi_build/","title":"libdebug.cffi.debug_sym_cffi_build","text":""},{"location":"from_pydoc/generated/cffi/debug_sym_cffi_build_legacy/","title":"libdebug.cffi.debug_sym_cffi_build_legacy","text":""},{"location":"from_pydoc/generated/cffi/personality_cffi_build/","title":"libdebug.cffi.personality_cffi_build","text":""},{"location":"from_pydoc/generated/cffi/ptrace_cffi_build/","title":"libdebug.cffi.ptrace_cffi_build","text":""},{"location":"from_pydoc/generated/data/breakpoint/","title":"libdebug.data.breakpoint","text":""},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint","title":"<code>Breakpoint</code>  <code>dataclass</code>","text":"<p>A breakpoint in the target process.</p> <p>Attributes:</p> Name Type Description <code>address</code> <code>int</code> <p>The address of the breakpoint in the target process.</p> <code>symbol</code> <code>str</code> <p>The symbol, if available, of the breakpoint in the target process.</p> <code>hit_count</code> <code>int</code> <p>The number of times this specific breakpoint has been hit.</p> <code>hardware</code> <code>bool</code> <p>Whether the breakpoint is a hardware breakpoint or not.</p> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>The callback defined by the user to execute when the breakpoint is hit.</p> <code>condition</code> <code>str</code> <p>The breakpoint condition. Available values are \"X\", \"W\", \"RW\". Supported only for hardware breakpoints.</p> <code>length</code> <code>int</code> <p>The length of the breakpoint area. Supported only for hardware breakpoints.</p> <code>enabled</code> <code>bool</code> <p>Whether the breakpoint is enabled or not.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>@dataclass\nclass Breakpoint:\n    \"\"\"A breakpoint in the target process.\n\n    Attributes:\n        address (int): The address of the breakpoint in the target process.\n        symbol (str): The symbol, if available, of the breakpoint in the target process.\n        hit_count (int): The number of times this specific breakpoint has been hit.\n        hardware (bool): Whether the breakpoint is a hardware breakpoint or not.\n        callback (Callable[[ThreadContext, Breakpoint], None]): The callback defined by the user to execute when the breakpoint is hit.\n        condition (str): The breakpoint condition. Available values are \"X\", \"W\", \"RW\". Supported only for hardware breakpoints.\n        length (int): The length of the breakpoint area. Supported only for hardware breakpoints.\n        enabled (bool): Whether the breakpoint is enabled or not.\n    \"\"\"\n\n    address: int = 0\n    symbol: str = \"\"\n    hit_count: int = 0\n    hardware: bool = False\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None\n    condition: str = \"x\"\n    length: int = 1\n    enabled: bool = True\n\n    _linked_thread_ids: list[int] = field(default_factory=list)\n    # The thread ID that hit the breakpoint\n\n    _disabled_for_step: bool = False\n    _changed: bool = False\n\n    def enable(self: Breakpoint) -&gt; None:\n        \"\"\"Enable the breakpoint.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = True\n        self._changed = True\n\n    def disable(self: Breakpoint) -&gt; None:\n        \"\"\"Disable the breakpoint.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = False\n        self._changed = True\n\n    def hit_on(self: Breakpoint, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the breakpoint has been hit on the given thread context.\"\"\"\n        return self.enabled and thread_context.instruction_pointer == self.address\n\n    def __hash__(self: Breakpoint) -&gt; int:\n        \"\"\"Hash the breakpoint by its address, so that it can be used in sets and maps correctly.\"\"\"\n        return hash(self.address)\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash the breakpoint by its address, so that it can be used in sets and maps correctly.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def __hash__(self: Breakpoint) -&gt; int:\n    \"\"\"Hash the breakpoint by its address, so that it can be used in sets and maps correctly.\"\"\"\n    return hash(self.address)\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.disable","title":"<code>disable()</code>","text":"<p>Disable the breakpoint.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def disable(self: Breakpoint) -&gt; None:\n    \"\"\"Disable the breakpoint.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = False\n    self._changed = True\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.enable","title":"<code>enable()</code>","text":"<p>Enable the breakpoint.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def enable(self: Breakpoint) -&gt; None:\n    \"\"\"Enable the breakpoint.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = True\n    self._changed = True\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.hit_on","title":"<code>hit_on(thread_context)</code>","text":"<p>Returns whether the breakpoint has been hit on the given thread context.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def hit_on(self: Breakpoint, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the breakpoint has been hit on the given thread context.\"\"\"\n    return self.enabled and thread_context.instruction_pointer == self.address\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map/","title":"libdebug.data.memory_map","text":""},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap","title":"<code>MemoryMap</code>  <code>dataclass</code>","text":"<p>A memory map of the target process.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <p>The start address of the memory map.</p> <code>end</code> <code>int</code> <p>The end address of the memory map.</p> <code>permissions</code> <code>str</code> <p>The permissions of the memory map.</p> <code>size</code> <code>int</code> <p>The size of the memory map.</p> <code>offset</code> <code>int</code> <p>The relative offset of the memory map.</p> <code>backing_file</code> <code>str</code> <p>The backing file of the memory map, or the symbolic name of the memory map.</p> Source code in <code>libdebug/data/memory_map.py</code> <pre><code>@dataclass(frozen=True)\nclass MemoryMap:\n    \"\"\"A memory map of the target process.\n\n    Attributes:\n        start (int): The start address of the memory map.\n        end (int): The end address of the memory map.\n        permissions (str): The permissions of the memory map.\n        size (int): The size of the memory map.\n        offset (int): The relative offset of the memory map.\n        backing_file (str): The backing file of the memory map, or the symbolic name of the memory map.\n    \"\"\"\n\n    start: int = 0\n    end: int = 0\n    permissions: str = \"\"\n    size: int = 0\n\n    offset: int = 0\n    \"\"\"The relative offset of the memory map inside the backing file, if any.\"\"\"\n\n    backing_file: str = \"\"\n    \"\"\"The backing file of the memory map, such as 'libc.so.6', or the symbolic name of the memory map, such as '[stack]'.\"\"\"\n\n    @staticmethod\n    def parse(vmap: str) -&gt; MemoryMap:\n        \"\"\"Parses a memory map from a /proc/pid/maps string representation.\n\n        Args:\n            vmap (str): The string containing the memory map.\n\n        Returns:\n            MemoryMap: The parsed memory map.\n        \"\"\"\n        try:\n            address, permissions, offset, *_, backing_file = vmap.split(\" \", 6)\n            start = int(address.split(\"-\")[0], 16)\n            end = int(address.split(\"-\")[1], 16)\n            size = end - start\n            int_offset = int(offset, 16)\n            backing_file = backing_file.strip()\n            if not backing_file:\n                backing_file = f\"anon_{start:x}\"\n        except ValueError as e:\n            raise ValueError(\n                f\"Invalid memory map: {vmap}. Please specify a valid memory map.\",\n            ) from e\n\n        return MemoryMap(start, end, permissions, size, int_offset, backing_file)\n\n    def __repr__(self: MemoryMap) -&gt; str:\n        \"\"\"Return the string representation of the memory map.\"\"\"\n        return f\"MemoryMap(start={hex(self.start)}, end={hex(self.end)}, permissions={self.permissions}, size={hex(self.size)}, offset={hex(self.offset)}, backing_file={self.backing_file})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.backing_file","title":"<code>backing_file: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The backing file of the memory map, such as 'libc.so.6', or the symbolic name of the memory map, such as '[stack]'.</p>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.offset","title":"<code>offset: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The relative offset of the memory map inside the backing file, if any.</p>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the string representation of the memory map.</p> Source code in <code>libdebug/data/memory_map.py</code> <pre><code>def __repr__(self: MemoryMap) -&gt; str:\n    \"\"\"Return the string representation of the memory map.\"\"\"\n    return f\"MemoryMap(start={hex(self.start)}, end={hex(self.end)}, permissions={self.permissions}, size={hex(self.size)}, offset={hex(self.offset)}, backing_file={self.backing_file})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.parse","title":"<code>parse(vmap)</code>  <code>staticmethod</code>","text":"<p>Parses a memory map from a /proc/pid/maps string representation.</p> <p>Parameters:</p> Name Type Description Default <code>vmap</code> <code>str</code> <p>The string containing the memory map.</p> required <p>Returns:</p> Name Type Description <code>MemoryMap</code> <code>MemoryMap</code> <p>The parsed memory map.</p> Source code in <code>libdebug/data/memory_map.py</code> <pre><code>@staticmethod\ndef parse(vmap: str) -&gt; MemoryMap:\n    \"\"\"Parses a memory map from a /proc/pid/maps string representation.\n\n    Args:\n        vmap (str): The string containing the memory map.\n\n    Returns:\n        MemoryMap: The parsed memory map.\n    \"\"\"\n    try:\n        address, permissions, offset, *_, backing_file = vmap.split(\" \", 6)\n        start = int(address.split(\"-\")[0], 16)\n        end = int(address.split(\"-\")[1], 16)\n        size = end - start\n        int_offset = int(offset, 16)\n        backing_file = backing_file.strip()\n        if not backing_file:\n            backing_file = f\"anon_{start:x}\"\n    except ValueError as e:\n        raise ValueError(\n            f\"Invalid memory map: {vmap}. Please specify a valid memory map.\",\n        ) from e\n\n    return MemoryMap(start, end, permissions, size, int_offset, backing_file)\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/","title":"libdebug.data.register_holder","text":""},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder","title":"<code>RegisterHolder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract class that holds the state of the registers of a process, providing setters and getters for them.</p> Source code in <code>libdebug/data/register_holder.py</code> <pre><code>class RegisterHolder(ABC):\n    \"\"\"An abstract class that holds the state of the registers of a process, providing setters and getters for them.\"\"\"\n\n    @abstractmethod\n    def apply_on_thread(self: RegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Applies the current register values to the specified thread target.\n\n        Args:\n            target (ThreadContext): The object to which the register values should be applied.\n            target_class (type): The class of the target object, needed to set the attributes.\n        \"\"\"\n\n    @abstractmethod\n    def apply_on_regs(self: RegisterHolder, target: object, target_class: type) -&gt; None:\n        \"\"\"Applies the current register values to the specified regs target.\n\n        Args:\n            target (object): The object to which the register values should be applied.\n            target_class (type): The class of the target object, needed to set the attributes.\n        \"\"\"\n\n    @abstractmethod\n    def poll(self: RegisterHolder, target: ThreadContext) -&gt; None:\n        \"\"\"Polls the register values from the specified target.\n\n        Args:\n            target (ThreadContext): The object from which the register values should be polled.\n        \"\"\"\n\n    @abstractmethod\n    def flush(self: RegisterHolder, source: ThreadContext) -&gt; None:\n        \"\"\"Flushes the register values from the specified source.\n\n        Args:\n            source (ThreadContext): The object from which the register values should be flushed.\n        \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>  <code>abstractmethod</code>","text":"<p>Applies the current register values to the specified regs target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>object</code> <p>The object to which the register values should be applied.</p> required <code>target_class</code> <code>type</code> <p>The class of the target object, needed to set the attributes.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef apply_on_regs(self: RegisterHolder, target: object, target_class: type) -&gt; None:\n    \"\"\"Applies the current register values to the specified regs target.\n\n    Args:\n        target (object): The object to which the register values should be applied.\n        target_class (type): The class of the target object, needed to set the attributes.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>  <code>abstractmethod</code>","text":"<p>Applies the current register values to the specified thread target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The object to which the register values should be applied.</p> required <code>target_class</code> <code>type</code> <p>The class of the target object, needed to set the attributes.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef apply_on_thread(self: RegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Applies the current register values to the specified thread target.\n\n    Args:\n        target (ThreadContext): The object to which the register values should be applied.\n        target_class (type): The class of the target object, needed to set the attributes.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.flush","title":"<code>flush(source)</code>  <code>abstractmethod</code>","text":"<p>Flushes the register values from the specified source.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ThreadContext</code> <p>The object from which the register values should be flushed.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef flush(self: RegisterHolder, source: ThreadContext) -&gt; None:\n    \"\"\"Flushes the register values from the specified source.\n\n    Args:\n        source (ThreadContext): The object from which the register values should be flushed.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.poll","title":"<code>poll(target)</code>  <code>abstractmethod</code>","text":"<p>Polls the register values from the specified target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The object from which the register values should be polled.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef poll(self: RegisterHolder, target: ThreadContext) -&gt; None:\n    \"\"\"Polls the register values from the specified target.\n\n    Args:\n        target (ThreadContext): The object from which the register values should be polled.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/registers/","title":"libdebug.data.registers","text":""},{"location":"from_pydoc/generated/data/registers/#libdebug.data.registers.Registers","title":"<code>Registers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abtract class that holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/data/registers.py</code> <pre><code>@dataclass\nclass Registers(ABC):\n    \"\"\"Abtract class that holds the state of the architectural-dependent registers of a process.\"\"\"\n\n    @abstractmethod\n    def __init__(self: Registers) -&gt; None:\n        \"\"\"Initializes the Registers object.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/registers/#libdebug.data.registers.Registers.__init__","title":"<code>__init__()</code>  <code>abstractmethod</code>","text":"<p>Initializes the Registers object.</p> Source code in <code>libdebug/data/registers.py</code> <pre><code>@abstractmethod\ndef __init__(self: Registers) -&gt; None:\n    \"\"\"Initializes the Registers object.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/","title":"libdebug.data.signal_catcher","text":""},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher","title":"<code>SignalCatcher</code>  <code>dataclass</code>","text":"<p>Catch a signal raised by the target process.</p> <p>Attributes:</p> Name Type Description <code>signal_number</code> <code>int</code> <p>The signal number to catch.</p> <code>callback</code> <code>Callable[[ThreadContext, CaughtSignal], None]</code> <p>The callback defined by the user to execute when the</p> <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher associated with the</p> <code>enabled</code> <code>bool</code> <p>Whether the signal will be caught or not.</p> <code>hit_count</code> <code>int</code> <p>The number of times the signal has been caught.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>@dataclass\nclass SignalCatcher:\n    \"\"\"Catch a signal raised by the target process.\n\n    Attributes:\n        signal_number (int): The signal number to catch.\n        callback (Callable[[ThreadContext, CaughtSignal], None]): The callback defined by the user to execute when the\n        signal is caught.\n        recursive (bool): Whether, when the signal is hijacked with another one, the signal catcher associated with the\n        new signal should be considered as well. Defaults to False.\n        enabled (bool): Whether the signal will be caught or not.\n        hit_count (int): The number of times the signal has been caught.\n    \"\"\"\n\n    signal_number: int\n    callback: Callable[[ThreadContext, SignalCatcher], None]\n    recursive: bool = True\n    enabled: bool = True\n    hit_count: int = 0\n\n    def enable(self: SignalCatcher) -&gt; None:\n        \"\"\"Enable the signal catcher.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = True\n\n    def disable(self: SignalCatcher) -&gt; None:\n        \"\"\"Disable the signal catcher.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = False\n\n    def hit_on(self: SignalCatcher, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the signal catcher has been hit on the given thread context.\"\"\"\n        return self.enabled and thread_context._signal_number == self.signal_number\n\n    def __hash__(self: SignalCatcher) -&gt; int:\n        \"\"\"Return the hash of the signal catcher, based just on the signal number.\"\"\"\n        return hash(self.signal_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the signal catcher, based just on the signal number.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def __hash__(self: SignalCatcher) -&gt; int:\n    \"\"\"Return the hash of the signal catcher, based just on the signal number.\"\"\"\n    return hash(self.signal_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.disable","title":"<code>disable()</code>","text":"<p>Disable the signal catcher.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def disable(self: SignalCatcher) -&gt; None:\n    \"\"\"Disable the signal catcher.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = False\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.enable","title":"<code>enable()</code>","text":"<p>Enable the signal catcher.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def enable(self: SignalCatcher) -&gt; None:\n    \"\"\"Enable the signal catcher.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = True\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.hit_on","title":"<code>hit_on(thread_context)</code>","text":"<p>Returns whether the signal catcher has been hit on the given thread context.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def hit_on(self: SignalCatcher, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the signal catcher has been hit on the given thread context.\"\"\"\n    return self.enabled and thread_context._signal_number == self.signal_number\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/","title":"libdebug.data.syscall_handler","text":""},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler","title":"<code>SyscallHandler</code>  <code>dataclass</code>","text":"<p>Handle a syscall executed by the target process.</p> <p>Attributes:</p> Name Type Description <code>syscall_number</code> <code>int</code> <p>The syscall number to handle.</p> <code>on_enter_user</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the user to execute when the</p> <code>on_exit_user</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the user to execute when the</p> <code>on_enter_pprint</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the pretty print to execute when</p> <code>on_exit_pprint</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the pretty print to execute when</p> <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler associated with</p> <code>enabled</code> <code>bool</code> <p>Whether the syscall will be handled or not.</p> <code>hit_count</code> <code>int</code> <p>The number of times the syscall has been handled.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>@dataclass\nclass SyscallHandler:\n    \"\"\"Handle a syscall executed by the target process.\n\n    Attributes:\n        syscall_number (int): The syscall number to handle.\n        on_enter_user (Callable[[ThreadContext, int], None]): The callback defined by the user to execute when the\n        syscall is entered.\n        on_exit_user (Callable[[ThreadContext, int], None]): The callback defined by the user to execute when the\n        syscall is exited.\n        on_enter_pprint (Callable[[ThreadContext, int], None]): The callback defined by the pretty print to execute when\n        the syscall is entered.\n        on_exit_pprint (Callable[[ThreadContext, int], None]): The callback defined by the pretty print to execute when\n        the syscall is exited.\n        recursive (bool): Whether, when the syscall is hijacked with another one, the syscall handler associated with\n        the new syscall should be considered as well. Defaults to False.\n        enabled (bool): Whether the syscall will be handled or not.\n        hit_count (int): The number of times the syscall has been handled.\n    \"\"\"\n\n    syscall_number: int\n    on_enter_user: Callable[[ThreadContext, int], None]\n    on_exit_user: Callable[[ThreadContext, int], None]\n    on_enter_pprint: Callable[[ThreadContext, int, Any], None]\n    on_exit_pprint: Callable[[int | tuple[int, int]], None]\n    recursive: bool = False\n    enabled: bool = True\n    hit_count: int = 0\n\n    _has_entered: bool = False\n    _skip_exit: bool = False\n\n    def enable(self: SyscallHandler) -&gt; None:\n        \"\"\"Handle the syscall.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = True\n        self._has_entered = False\n\n    def disable(self: SyscallHandler) -&gt; None:\n        \"\"\"Unhandle the syscall.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = False\n        self._has_entered = False\n\n    def hit_on_enter(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the syscall handler has been hit during the syscall entry on the given thread context.\"\"\"\n        return self.enabled and thread_context.syscall_number == self.syscall_number and self._has_entered\n\n    def hit_on_exit(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the syscall handler has been hit during the syscall exit on the given thread context.\"\"\"\n        return self.enabled and thread_context.syscall_number == self.syscall_number and not self._has_entered\n\n    def __hash__(self: SyscallHandler) -&gt; int:\n        \"\"\"Return the hash of the syscall handler, based just on the syscall number.\"\"\"\n        return hash(self.syscall_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the syscall handler, based just on the syscall number.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def __hash__(self: SyscallHandler) -&gt; int:\n    \"\"\"Return the hash of the syscall handler, based just on the syscall number.\"\"\"\n    return hash(self.syscall_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.disable","title":"<code>disable()</code>","text":"<p>Unhandle the syscall.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def disable(self: SyscallHandler) -&gt; None:\n    \"\"\"Unhandle the syscall.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = False\n    self._has_entered = False\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.enable","title":"<code>enable()</code>","text":"<p>Handle the syscall.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def enable(self: SyscallHandler) -&gt; None:\n    \"\"\"Handle the syscall.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = True\n    self._has_entered = False\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.hit_on_enter","title":"<code>hit_on_enter(thread_context)</code>","text":"<p>Returns whether the syscall handler has been hit during the syscall entry on the given thread context.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def hit_on_enter(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the syscall handler has been hit during the syscall entry on the given thread context.\"\"\"\n    return self.enabled and thread_context.syscall_number == self.syscall_number and self._has_entered\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.hit_on_exit","title":"<code>hit_on_exit(thread_context)</code>","text":"<p>Returns whether the syscall handler has been hit during the syscall exit on the given thread context.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def hit_on_exit(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the syscall handler has been hit during the syscall exit on the given thread context.\"\"\"\n    return self.enabled and thread_context.syscall_number == self.syscall_number and not self._has_entered\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/","title":"libdebug.debugger.debugger","text":""},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger","title":"<code>Debugger</code>","text":"<p>The Debugger class is the main class of <code>libdebug</code>. It contains all the methods needed to run and interact with the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>class Debugger:\n    \"\"\"The Debugger class is the main class of `libdebug`. It contains all the methods needed to run and interact with the process.\"\"\"\n\n    _sentinel: object = object()\n    \"\"\"A sentinel object.\"\"\"\n\n    _internal_debugger: InternalDebugger | None = None\n    \"\"\"The internal debugger object.\"\"\"\n\n    def __init__(self: Debugger) -&gt; None:\n        pass\n\n    def post_init_(self: Debugger, internal_debugger: InternalDebugger) -&gt; None:\n        \"\"\"Do not use this constructor directly. Use the `debugger` function instead.\"\"\"\n        self._internal_debugger = internal_debugger\n        self._internal_debugger.start_up()\n\n    def run(self: Debugger) -&gt; PipeManager:\n        \"\"\"Starts the process and waits for it to stop.\"\"\"\n        return self._internal_debugger.run()\n\n    def attach(self: Debugger, pid: int) -&gt; None:\n        \"\"\"Attaches to an existing process.\"\"\"\n        self._internal_debugger.attach(pid)\n\n    def detach(self: Debugger) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n        self._internal_debugger.detach()\n\n    def kill(self: Debugger) -&gt; None:\n        \"\"\"Kills the process.\"\"\"\n        self._internal_debugger.kill()\n\n    def terminate(self: Debugger) -&gt; None:\n        \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n        The debugger object will not be usable after this method is called.\n        This method should only be called to free up resources when the debugger object is no longer needed.\n        \"\"\"\n        self._internal_debugger.terminate()\n\n    def cont(self: Debugger) -&gt; None:\n        \"\"\"Continues the process.\"\"\"\n        self._internal_debugger.cont()\n\n    def interrupt(self: Debugger) -&gt; None:\n        \"\"\"Interrupts the process.\"\"\"\n        self._internal_debugger.interrupt()\n\n    def wait(self: Debugger) -&gt; None:\n        \"\"\"Waits for the process to stop.\"\"\"\n        self._internal_debugger.wait()\n\n    def maps(self: Debugger) -&gt; list[MemoryMap]:\n        \"\"\"Returns the memory maps of the process.\"\"\"\n        return self._internal_debugger.maps()\n\n    def print_maps(self: Debugger) -&gt; None:\n        \"\"\"Prints the memory maps of the process.\"\"\"\n        self._internal_debugger.print_maps()\n\n    def breakpoint(\n        self: Debugger,\n        position: int | str,\n        hardware: bool = False,\n        condition: str = \"x\",\n        length: int = 1,\n        callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Sets a breakpoint at the specified location.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software.\n            Defaults to False.\n            condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n            length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n            callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n            breakpoint is hit. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n\n    def watchpoint(\n        self: Debugger,\n        position: int | str,\n        condition: str = \"w\",\n        length: int = 1,\n        callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\").\n            Defaults to \"w\".\n            length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n            callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n            watchpoint is hit. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(\n            position,\n            hardware=True,\n            condition=condition,\n            length=length,\n            callback=callback,\n            file=file,\n        )\n\n    def catch_signal(\n        self: Debugger,\n        signal: int | str,\n        callback: None | Callable[[ThreadContext, SignalCatcher], None] = None,\n        recursive: bool = False,\n    ) -&gt; SignalCatcher:\n        \"\"\"Catch a signal in the target process.\n\n        Args:\n            signal (int | str): The signal to catch.\n            callback (Callable[[ThreadContext, CaughtSignal], None], optional): A callback to be called when the signal\n            is caught. Defaults to None.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n            associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            CaughtSignal: The CaughtSignal object.\n        \"\"\"\n        return self._internal_debugger.catch_signal(signal, callback, recursive)\n\n    def hijack_signal(\n        self: Debugger,\n        original_signal: int | str,\n        new_signal: int | str,\n        recursive: bool = False,\n    ) -&gt; SyscallHandler:\n        \"\"\"Hijack a signal in the target process.\n\n        Args:\n            original_signal (int | str): The signal to hijack.\n            new_signal (int | str): The signal to hijack the original signal with.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n            associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            CaughtSignal: The CaughtSignal object.\n        \"\"\"\n        return self._internal_debugger.hijack_signal(original_signal, new_signal, recursive)\n\n    def handle_syscall(\n        self: Debugger,\n        syscall: int | str,\n        on_enter: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n        on_exit: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n        recursive: bool = False,\n    ) -&gt; SyscallHandler:\n        \"\"\"Handle a syscall in the target process.\n\n        Args:\n            syscall (int | str): The syscall name or number to handle.\n            on_enter (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n            syscall is entered. Defaults to None.\n            on_exit (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n            syscall is exited. Defaults to None.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n            associated with the new syscall should be considered as well. Defaults to False.\n\n        Returns:\n            HandledSyscall: The HandledSyscall object.\n        \"\"\"\n        return self._internal_debugger.handle_syscall(syscall, on_enter, on_exit, recursive)\n\n    def hijack_syscall(\n        self: Debugger,\n        original_syscall: int | str,\n        new_syscall: int | str,\n        recursive: bool = False,\n        **kwargs: int,\n    ) -&gt; SyscallHandler:\n        \"\"\"Hijacks a syscall in the target process.\n\n        Args:\n            original_syscall (int | str): The syscall name or number to hijack.\n            new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n            associated with the new syscall should be considered as well. Defaults to False.\n            **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n        Returns:\n            HandledSyscall: The HandledSyscall object.\n        \"\"\"\n        return self._internal_debugger.hijack_syscall(original_syscall, new_syscall, recursive, **kwargs)\n\n    def gdb(self: Debugger, open_in_new_process: bool = True) -&gt; None:\n        \"\"\"Migrates the current debugging session to GDB.\"\"\"\n        self._internal_debugger.gdb(open_in_new_process)\n\n    def r(self: Debugger) -&gt; PipeManager:\n        \"\"\"Alias for the `run` method.\n\n        Starts the process and waits for it to stop.\n        \"\"\"\n        return self._internal_debugger.run()\n\n    def c(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `cont` method.\n\n        Continues the process.\n        \"\"\"\n        self._internal_debugger.cont()\n\n    def int(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `interrupt` method.\n\n        Interrupts the process.\n        \"\"\"\n        self._internal_debugger.interrupt()\n\n    def w(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `wait` method.\n\n        Waits for the process to stop.\n        \"\"\"\n        self._internal_debugger.wait()\n\n    def bp(\n        self: Debugger,\n        position: int | str,\n        hardware: bool = False,\n        condition: str = \"x\",\n        length: int = 1,\n        callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Alias for the `breakpoint` method.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software.\n            Defaults to False.\n            condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n            length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n            callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n            breakpoint is hit. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n\n    def wp(\n        self: Debugger,\n        position: int | str,\n        condition: str = \"w\",\n        length: int = 1,\n        callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Alias for the `watchpoint` method.\n\n        Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\").\n            Defaults to \"w\".\n            length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n            callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n            watchpoint is hit. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(\n            position,\n            hardware=True,\n            condition=condition,\n            length=length,\n            callback=callback,\n            file=file,\n        )\n\n    @property\n    def arch(self: Debugger) -&gt; str:\n        \"\"\"Get the architecture of the process.\"\"\"\n        return self._internal_debugger.arch\n\n    @arch.setter\n    def arch(self: Debugger, value: str) -&gt; None:\n        \"\"\"Set the architecture of the process.\"\"\"\n        self._internal_debugger.arch = map_arch(value)\n\n    @property\n    def kill_on_exit(self: Debugger) -&gt; bool:\n        \"\"\"Get whether the process will be killed when the debugger exits.\"\"\"\n        return self._internal_debugger.kill_on_exit\n\n    @kill_on_exit.setter\n    def kill_on_exit(self: Debugger, value: bool) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"kill_on_exit must be a boolean\")\n\n        self._internal_debugger.kill_on_exit = value\n\n    @property\n    def threads(self: Debugger) -&gt; list[ThreadContext]:\n        \"\"\"Get the list of threads in the process.\"\"\"\n        return self._internal_debugger.threads\n\n    @property\n    def breakpoints(self: Debugger) -&gt; dict[int, Breakpoint]:\n        \"\"\"Get the breakpoints set on the process.\"\"\"\n        return self._internal_debugger.breakpoints\n\n    @property\n    def handled_syscalls(self: InternalDebugger) -&gt; dict[int, SyscallHandler]:\n        \"\"\"Get the handled syscalls dictionary.\n\n        Returns:\n            dict[int, HandledSyscall]: the handled syscalls dictionary.\n        \"\"\"\n        return self._internal_debugger.handled_syscalls\n\n    @property\n    def caught_signals(self: InternalDebugger) -&gt; dict[int, SignalCatcher]:\n        \"\"\"Get the caught signals dictionary.\n\n        Returns:\n            dict[int, CaughtSignal]: the caught signals dictionary.\n        \"\"\"\n        return self._internal_debugger.caught_signals\n\n    @property\n    def pprint_syscalls(self: Debugger) -&gt; bool:\n        \"\"\"Get the state of the pprint_syscalls flag.\n\n        Returns:\n            bool: True if the debugger should pretty print syscalls, False otherwise.\n        \"\"\"\n        return self._internal_debugger.pprint_syscalls\n\n    @pprint_syscalls.setter\n    def pprint_syscalls(self: Debugger, value: bool) -&gt; None:\n        \"\"\"Set the state of the pprint_syscalls flag.\n\n        Args:\n            value (bool): the value to set.\n        \"\"\"\n        if not isinstance(value, bool):\n            raise TypeError(\"pprint_syscalls must be a boolean\")\n        if value:\n            self._internal_debugger.enable_pretty_print()\n        else:\n            self._internal_debugger.disable_pretty_print()\n\n        self._internal_debugger.pprint_syscalls = value\n\n    @contextmanager\n    def pprint_syscalls_context(self: Debugger, value: bool) -&gt; ...:\n        \"\"\"A context manager to temporarily change the state of the pprint_syscalls flag.\n\n        Args:\n            value (bool): the value to set.\n\n        Yields:\n            None\n        \"\"\"\n        old_value = self.pprint_syscalls\n        self.pprint_syscalls = value\n        yield\n        self.pprint_syscalls = old_value\n\n    @property\n    def syscalls_to_pprint(self: Debugger) -&gt; list[str] | None:\n        \"\"\"Get the syscalls to pretty print.\n\n        Returns:\n            list[str]: The syscalls to pretty print.\n        \"\"\"\n        if self._internal_debugger.syscalls_to_pprint is None:\n            return None\n        else:\n            return [\n                resolve_syscall_name(self._internal_debugger.arch, v)\n                for v in self._internal_debugger.syscalls_to_pprint\n            ]\n\n    @syscalls_to_pprint.setter\n    def syscalls_to_pprint(self: Debugger, value: list[int | str] | None) -&gt; None:\n        \"\"\"Get the syscalls to pretty print.\n\n        Args:\n            value (list[int | str] | None): The syscalls to pretty print.\n        \"\"\"\n        if value is None:\n            self._internal_debugger.syscalls_to_pprint = None\n        elif isinstance(value, list):\n            self._internal_debugger.syscalls_to_pprint = [\n                v if isinstance(v, int) else resolve_syscall_number(self._internal_debugger.arch, v) for v in value\n            ]\n        else:\n            raise ValueError(\n                \"syscalls_to_pprint must be a list of integers or strings or None.\",\n            )\n        if self._internal_debugger.pprint_syscalls:\n            self._internal_debugger.enable_pretty_print()\n\n    @property\n    def syscalls_to_not_pprint(self: Debugger) -&gt; list[str] | None:\n        \"\"\"Get the syscalls to not pretty print.\n\n        Returns:\n            list[str]: The syscalls to not pretty print.\n        \"\"\"\n        if self._internal_debugger.syscalls_to_not_pprint is None:\n            return None\n        else:\n            return [\n                resolve_syscall_name(self._internal_debugger.arch, v)\n                for v in self._internal_debugger.syscalls_to_not_pprint\n            ]\n\n    @syscalls_to_not_pprint.setter\n    def syscalls_to_not_pprint(self: Debugger, value: list[int | str] | None) -&gt; None:\n        \"\"\"Get the syscalls to not pretty print.\n\n        Args:\n            value (list[int | str] | None): The syscalls to not pretty print.\n        \"\"\"\n        if value is None:\n            self._internal_debugger.syscalls_to_not_pprint = None\n        elif isinstance(value, list):\n            self._internal_debugger.syscalls_to_not_pprint = [\n                v if isinstance(v, int) else resolve_syscall_number(self._internal_debugger.arch, v) for v in value\n            ]\n        else:\n            raise ValueError(\n                \"syscalls_to_not_pprint must be a list of integers or strings or None.\",\n            )\n        if self._internal_debugger.pprint_syscalls:\n            self._internal_debugger.enable_pretty_print()\n\n    @property\n    def signals_to_block(self: Debugger) -&gt; list[str]:\n        \"\"\"Get the signals to not forward to the process.\n\n        Returns:\n            list[str]: The signals to block.\n        \"\"\"\n        return [resolve_signal_name(v) for v in self._internal_debugger.signals_to_block]\n\n    @signals_to_block.setter\n    def signals_to_block(self: Debugger, signals: list[int | str]) -&gt; None:\n        \"\"\"Set the signal to not forward to the process.\n\n        Args:\n            signals (list[int | str]): The signals to block.\n        \"\"\"\n        if not isinstance(signals, list):\n            raise TypeError(\"signals_to_block must be a list of integers or strings\")\n\n        signals = [v if isinstance(v, int) else resolve_signal_number(v) for v in signals]\n\n        if not set(signals).issubset(get_all_signal_numbers()):\n            raise ValueError(\"Invalid signal number.\")\n\n        self._internal_debugger.signals_to_block = signals\n\n    @property\n    def fast_memory(self: Debugger) -&gt; bool:\n        \"\"\"Get the state of the fast_memory flag.\n\n        It is used to determine if the debugger should use a faster memory access method.\n\n        Returns:\n            bool: True if the debugger should use a faster memory access method, False otherwise.\n        \"\"\"\n        return self._internal_debugger.fast_memory\n\n    @fast_memory.setter\n    def fast_memory(self: Debugger, value: bool) -&gt; None:\n        \"\"\"Set the state of the fast_memory flag.\n\n        It is used to determine if the debugger should use a faster memory access method.\n\n        Args:\n            value (bool): the value to set.\n        \"\"\"\n        if not isinstance(value, bool):\n            raise TypeError(\"fast_memory must be a boolean\")\n        self._internal_debugger.fast_memory = value\n\n    def __getattr__(self: Debugger, name: str) -&gt; object:\n        \"\"\"This function is called when an attribute is not found in the `Debugger` object.\n\n        It is used to forward the call to the first `ThreadContext` object.\n        \"\"\"\n        if not self.threads:\n            raise AttributeError(f\"'debugger has no attribute '{name}'\")\n\n        thread_context = self.threads[0]\n\n        # hasattr internally calls getattr, so we use this to avoid double access to the attribute\n        # do not use None as default value, as it is a valid value\n        if (attr := getattr(thread_context, name, self._sentinel)) == self._sentinel:\n            raise AttributeError(f\"'Debugger has no attribute '{name}'\")\n        return attr\n\n    def __setattr__(self: Debugger, name: str, value: object) -&gt; None:\n        \"\"\"This function is called when an attribute is set in the `Debugger` object.\n\n        It is used to forward the call to the first `ThreadContext` object.\n        \"\"\"\n        # First we check if the attribute is available in the `Debugger` object\n        if hasattr(Debugger, name):\n            super().__setattr__(name, value)\n        else:\n            thread_context = self.threads[0]\n            setattr(thread_context, name, value)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.arch","title":"<code>arch: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the architecture of the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.breakpoints","title":"<code>breakpoints: dict[int, Breakpoint]</code>  <code>property</code>","text":"<p>Get the breakpoints set on the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.caught_signals","title":"<code>caught_signals: dict[int, SignalCatcher]</code>  <code>property</code>","text":"<p>Get the caught signals dictionary.</p> <p>Returns:</p> Type Description <code>dict[int, SignalCatcher]</code> <p>dict[int, CaughtSignal]: the caught signals dictionary.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.fast_memory","title":"<code>fast_memory: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the fast_memory flag.</p> <p>It is used to determine if the debugger should use a faster memory access method.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the debugger should use a faster memory access method, False otherwise.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.handled_syscalls","title":"<code>handled_syscalls: dict[int, SyscallHandler]</code>  <code>property</code>","text":"<p>Get the handled syscalls dictionary.</p> <p>Returns:</p> Type Description <code>dict[int, SyscallHandler]</code> <p>dict[int, HandledSyscall]: the handled syscalls dictionary.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.kill_on_exit","title":"<code>kill_on_exit: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get whether the process will be killed when the debugger exits.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_syscalls","title":"<code>pprint_syscalls: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the pprint_syscalls flag.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the debugger should pretty print syscalls, False otherwise.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.signals_to_block","title":"<code>signals_to_block: list[str]</code>  <code>property</code> <code>writable</code>","text":"<p>Get the signals to not forward to the process.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The signals to block.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscalls_to_not_pprint","title":"<code>syscalls_to_not_pprint: list[str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the syscalls to not pretty print.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>list[str]: The syscalls to not pretty print.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscalls_to_pprint","title":"<code>syscalls_to_pprint: list[str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the syscalls to pretty print.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>list[str]: The syscalls to pretty print.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.threads","title":"<code>threads: list[ThreadContext]</code>  <code>property</code>","text":"<p>Get the list of threads in the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>This function is called when an attribute is not found in the <code>Debugger</code> object.</p> <p>It is used to forward the call to the first <code>ThreadContext</code> object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def __getattr__(self: Debugger, name: str) -&gt; object:\n    \"\"\"This function is called when an attribute is not found in the `Debugger` object.\n\n    It is used to forward the call to the first `ThreadContext` object.\n    \"\"\"\n    if not self.threads:\n        raise AttributeError(f\"'debugger has no attribute '{name}'\")\n\n    thread_context = self.threads[0]\n\n    # hasattr internally calls getattr, so we use this to avoid double access to the attribute\n    # do not use None as default value, as it is a valid value\n    if (attr := getattr(thread_context, name, self._sentinel)) == self._sentinel:\n        raise AttributeError(f\"'Debugger has no attribute '{name}'\")\n    return attr\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>This function is called when an attribute is set in the <code>Debugger</code> object.</p> <p>It is used to forward the call to the first <code>ThreadContext</code> object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def __setattr__(self: Debugger, name: str, value: object) -&gt; None:\n    \"\"\"This function is called when an attribute is set in the `Debugger` object.\n\n    It is used to forward the call to the first `ThreadContext` object.\n    \"\"\"\n    # First we check if the attribute is available in the `Debugger` object\n    if hasattr(Debugger, name):\n        super().__setattr__(name, value)\n    else:\n        thread_context = self.threads[0]\n        setattr(thread_context, name, value)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.attach","title":"<code>attach(pid)</code>","text":"<p>Attaches to an existing process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def attach(self: Debugger, pid: int) -&gt; None:\n    \"\"\"Attaches to an existing process.\"\"\"\n    self._internal_debugger.attach(pid)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.bp","title":"<code>bp(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')</code>","text":"<p>Alias for the <code>breakpoint</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>hardware</code> <code>bool</code> <p>Whether the breakpoint should be hardware-assisted or purely software.</p> <code>False</code> <code>condition</code> <code>str</code> <p>The trigger condition for the breakpoint. Defaults to None.</p> <code>'x'</code> <code>length</code> <code>int</code> <p>The length of the breakpoint. Only for watchpoints. Defaults to 1.</p> <code>1</code> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\"</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def bp(\n    self: Debugger,\n    position: int | str,\n    hardware: bool = False,\n    condition: str = \"x\",\n    length: int = 1,\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Alias for the `breakpoint` method.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software.\n        Defaults to False.\n        condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n        length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n        callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n        breakpoint is hit. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n        (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n        the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.breakpoint","title":"<code>breakpoint(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')</code>","text":"<p>Sets a breakpoint at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>hardware</code> <code>bool</code> <p>Whether the breakpoint should be hardware-assisted or purely software.</p> <code>False</code> <code>condition</code> <code>str</code> <p>The trigger condition for the breakpoint. Defaults to None.</p> <code>'x'</code> <code>length</code> <code>int</code> <p>The length of the breakpoint. Only for watchpoints. Defaults to 1.</p> <code>1</code> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\"</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def breakpoint(\n    self: Debugger,\n    position: int | str,\n    hardware: bool = False,\n    condition: str = \"x\",\n    length: int = 1,\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Sets a breakpoint at the specified location.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software.\n        Defaults to False.\n        condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n        length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n        callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n        breakpoint is hit. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n        (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n        the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.c","title":"<code>c()</code>","text":"<p>Alias for the <code>cont</code> method.</p> <p>Continues the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def c(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `cont` method.\n\n    Continues the process.\n    \"\"\"\n    self._internal_debugger.cont()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.catch_signal","title":"<code>catch_signal(signal, callback=None, recursive=False)</code>","text":"<p>Catch a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>int | str</code> <p>The signal to catch.</p> required <code>callback</code> <code>Callable[[ThreadContext, CaughtSignal], None]</code> <p>A callback to be called when the signal</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CaughtSignal</code> <code>SignalCatcher</code> <p>The CaughtSignal object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def catch_signal(\n    self: Debugger,\n    signal: int | str,\n    callback: None | Callable[[ThreadContext, SignalCatcher], None] = None,\n    recursive: bool = False,\n) -&gt; SignalCatcher:\n    \"\"\"Catch a signal in the target process.\n\n    Args:\n        signal (int | str): The signal to catch.\n        callback (Callable[[ThreadContext, CaughtSignal], None], optional): A callback to be called when the signal\n        is caught. Defaults to None.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n        associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        CaughtSignal: The CaughtSignal object.\n    \"\"\"\n    return self._internal_debugger.catch_signal(signal, callback, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.cont","title":"<code>cont()</code>","text":"<p>Continues the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def cont(self: Debugger) -&gt; None:\n    \"\"\"Continues the process.\"\"\"\n    self._internal_debugger.cont()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.detach","title":"<code>detach()</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def detach(self: Debugger) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n    self._internal_debugger.detach()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.gdb","title":"<code>gdb(open_in_new_process=True)</code>","text":"<p>Migrates the current debugging session to GDB.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def gdb(self: Debugger, open_in_new_process: bool = True) -&gt; None:\n    \"\"\"Migrates the current debugging session to GDB.\"\"\"\n    self._internal_debugger.gdb(open_in_new_process)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.handle_syscall","title":"<code>handle_syscall(syscall, on_enter=None, on_exit=None, recursive=False)</code>","text":"<p>Handle a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>syscall</code> <code>int | str</code> <p>The syscall name or number to handle.</p> required <code>on_enter</code> <code>Callable[[ThreadContext, HandledSyscall], None]</code> <p>The callback to execute when the</p> <code>None</code> <code>on_exit</code> <code>Callable[[ThreadContext, HandledSyscall], None]</code> <p>The callback to execute when the</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler</p> <code>False</code> <p>Returns:</p> Name Type Description <code>HandledSyscall</code> <code>SyscallHandler</code> <p>The HandledSyscall object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def handle_syscall(\n    self: Debugger,\n    syscall: int | str,\n    on_enter: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n    on_exit: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n    recursive: bool = False,\n) -&gt; SyscallHandler:\n    \"\"\"Handle a syscall in the target process.\n\n    Args:\n        syscall (int | str): The syscall name or number to handle.\n        on_enter (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n        syscall is entered. Defaults to None.\n        on_exit (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n        syscall is exited. Defaults to None.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n        associated with the new syscall should be considered as well. Defaults to False.\n\n    Returns:\n        HandledSyscall: The HandledSyscall object.\n    \"\"\"\n    return self._internal_debugger.handle_syscall(syscall, on_enter, on_exit, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.hijack_signal","title":"<code>hijack_signal(original_signal, new_signal, recursive=False)</code>","text":"<p>Hijack a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_signal</code> <code>int | str</code> <p>The signal to hijack.</p> required <code>new_signal</code> <code>int | str</code> <p>The signal to hijack the original signal with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CaughtSignal</code> <code>SyscallHandler</code> <p>The CaughtSignal object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def hijack_signal(\n    self: Debugger,\n    original_signal: int | str,\n    new_signal: int | str,\n    recursive: bool = False,\n) -&gt; SyscallHandler:\n    \"\"\"Hijack a signal in the target process.\n\n    Args:\n        original_signal (int | str): The signal to hijack.\n        new_signal (int | str): The signal to hijack the original signal with.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n        associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        CaughtSignal: The CaughtSignal object.\n    \"\"\"\n    return self._internal_debugger.hijack_signal(original_signal, new_signal, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.hijack_syscall","title":"<code>hijack_syscall(original_syscall, new_syscall, recursive=False, **kwargs)</code>","text":"<p>Hijacks a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack.</p> required <code>new_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack the original syscall with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler</p> <code>False</code> <code>**kwargs</code> <code>int</code> <p>(int, optional): The arguments to pass to the new syscall.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HandledSyscall</code> <code>SyscallHandler</code> <p>The HandledSyscall object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def hijack_syscall(\n    self: Debugger,\n    original_syscall: int | str,\n    new_syscall: int | str,\n    recursive: bool = False,\n    **kwargs: int,\n) -&gt; SyscallHandler:\n    \"\"\"Hijacks a syscall in the target process.\n\n    Args:\n        original_syscall (int | str): The syscall name or number to hijack.\n        new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n        associated with the new syscall should be considered as well. Defaults to False.\n        **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n    Returns:\n        HandledSyscall: The HandledSyscall object.\n    \"\"\"\n    return self._internal_debugger.hijack_syscall(original_syscall, new_syscall, recursive, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.int","title":"<code>int()</code>","text":"<p>Alias for the <code>interrupt</code> method.</p> <p>Interrupts the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def int(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `interrupt` method.\n\n    Interrupts the process.\n    \"\"\"\n    self._internal_debugger.interrupt()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.interrupt","title":"<code>interrupt()</code>","text":"<p>Interrupts the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def interrupt(self: Debugger) -&gt; None:\n    \"\"\"Interrupts the process.\"\"\"\n    self._internal_debugger.interrupt()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.kill","title":"<code>kill()</code>","text":"<p>Kills the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def kill(self: Debugger) -&gt; None:\n    \"\"\"Kills the process.\"\"\"\n    self._internal_debugger.kill()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.maps","title":"<code>maps()</code>","text":"<p>Returns the memory maps of the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def maps(self: Debugger) -&gt; list[MemoryMap]:\n    \"\"\"Returns the memory maps of the process.\"\"\"\n    return self._internal_debugger.maps()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.post_init_","title":"<code>post_init_(internal_debugger)</code>","text":"<p>Do not use this constructor directly. Use the <code>debugger</code> function instead.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def post_init_(self: Debugger, internal_debugger: InternalDebugger) -&gt; None:\n    \"\"\"Do not use this constructor directly. Use the `debugger` function instead.\"\"\"\n    self._internal_debugger = internal_debugger\n    self._internal_debugger.start_up()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_syscalls_context","title":"<code>pprint_syscalls_context(value)</code>","text":"<p>A context manager to temporarily change the state of the pprint_syscalls flag.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>the value to set.</p> required <p>Yields:</p> Type Description <code>...</code> <p>None</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>@contextmanager\ndef pprint_syscalls_context(self: Debugger, value: bool) -&gt; ...:\n    \"\"\"A context manager to temporarily change the state of the pprint_syscalls flag.\n\n    Args:\n        value (bool): the value to set.\n\n    Yields:\n        None\n    \"\"\"\n    old_value = self.pprint_syscalls\n    self.pprint_syscalls = value\n    yield\n    self.pprint_syscalls = old_value\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.print_maps","title":"<code>print_maps()</code>","text":"<p>Prints the memory maps of the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def print_maps(self: Debugger) -&gt; None:\n    \"\"\"Prints the memory maps of the process.\"\"\"\n    self._internal_debugger.print_maps()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.r","title":"<code>r()</code>","text":"<p>Alias for the <code>run</code> method.</p> <p>Starts the process and waits for it to stop.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def r(self: Debugger) -&gt; PipeManager:\n    \"\"\"Alias for the `run` method.\n\n    Starts the process and waits for it to stop.\n    \"\"\"\n    return self._internal_debugger.run()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.run","title":"<code>run()</code>","text":"<p>Starts the process and waits for it to stop.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def run(self: Debugger) -&gt; PipeManager:\n    \"\"\"Starts the process and waits for it to stop.\"\"\"\n    return self._internal_debugger.run()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.terminate","title":"<code>terminate()</code>","text":"<p>Interrupts the process, kills it and then terminates the background thread.</p> <p>The debugger object will not be usable after this method is called. This method should only be called to free up resources when the debugger object is no longer needed.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def terminate(self: Debugger) -&gt; None:\n    \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n    The debugger object will not be usable after this method is called.\n    This method should only be called to free up resources when the debugger object is no longer needed.\n    \"\"\"\n    self._internal_debugger.terminate()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.w","title":"<code>w()</code>","text":"<p>Alias for the <code>wait</code> method.</p> <p>Waits for the process to stop.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def w(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `wait` method.\n\n    Waits for the process to stop.\n    \"\"\"\n    self._internal_debugger.wait()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.wait","title":"<code>wait()</code>","text":"<p>Waits for the process to stop.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def wait(self: Debugger) -&gt; None:\n    \"\"\"Waits for the process to stop.\"\"\"\n    self._internal_debugger.wait()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.watchpoint","title":"<code>watchpoint(position, condition='w', length=1, callback=None, file='hybrid')</code>","text":"<p>Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>condition</code> <code>str</code> <p>The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\").</p> <code>'w'</code> <code>length</code> <code>int</code> <p>The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.</p> <code>1</code> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\"</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def watchpoint(\n    self: Debugger,\n    position: int | str,\n    condition: str = \"w\",\n    length: int = 1,\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\").\n        Defaults to \"w\".\n        length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n        callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n        watchpoint is hit. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n        (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n        the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(\n        position,\n        hardware=True,\n        condition=condition,\n        length=length,\n        callback=callback,\n        file=file,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.wp","title":"<code>wp(position, condition='w', length=1, callback=None, file='hybrid')</code>","text":"<p>Alias for the <code>watchpoint</code> method.</p> <p>Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>condition</code> <code>str</code> <p>The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\").</p> <code>'w'</code> <code>length</code> <code>int</code> <p>The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.</p> <code>1</code> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\"</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def wp(\n    self: Debugger,\n    position: int | str,\n    condition: str = \"w\",\n    length: int = 1,\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Alias for the `watchpoint` method.\n\n    Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\").\n        Defaults to \"w\".\n        length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n        callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n        watchpoint is hit. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n        (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n        the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(\n        position,\n        hardware=True,\n        condition=condition,\n        length=length,\n        callback=callback,\n        file=file,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/","title":"libdebug.debugger.internal_debugger","text":""},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger","title":"<code>InternalDebugger</code>","text":"<p>A class that holds the global debugging state.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>class InternalDebugger:\n    \"\"\"A class that holds the global debugging state.\"\"\"\n\n    aslr_enabled: bool\n    \"\"\"A flag that indicates if ASLR is enabled or not.\"\"\"\n\n    arch: str\n    \"\"\"The architecture of the debugged process.\"\"\"\n\n    argv: list[str]\n    \"\"\"The command line arguments of the debugged process.\"\"\"\n\n    env: dict[str, str] | None\n    \"\"\"The environment variables of the debugged process.\"\"\"\n\n    escape_antidebug: bool\n    \"\"\"A flag that indicates if the debugger should escape anti-debugging techniques.\"\"\"\n\n    fast_memory: bool\n    \"\"\"A flag that indicates if the debugger should use a faster memory access method.\"\"\"\n\n    autoreach_entrypoint: bool\n    \"\"\"A flag that indicates if the debugger should automatically reach the entry point of the debugged process.\"\"\"\n\n    auto_interrupt_on_command: bool\n    \"\"\"A flag that indicates if the debugger should automatically interrupt the debugged process when a command is issued.\"\"\"\n\n    breakpoints: dict[int, Breakpoint]\n    \"\"\"A dictionary of all the breakpoints set on the process.\n    Key: the address of the breakpoint.\"\"\"\n\n    handled_syscalls: dict[int, SyscallHandler]\n    \"\"\"A dictionary of all the syscall handled in the process.\n    Key: the syscall number.\"\"\"\n\n    caught_signals: dict[int, SignalCatcher]\n    \"\"\"A dictionary of all the signals caught in the process.\n    Key: the signal number.\"\"\"\n\n    signals_to_block: list[int]\n    \"\"\"The signals to not forward to the process.\"\"\"\n\n    syscalls_to_pprint: list[int] | None\n    \"\"\"The syscalls to pretty print.\"\"\"\n\n    syscalls_to_not_pprint: list[int] | None\n    \"\"\"The syscalls to not pretty print.\"\"\"\n\n    kill_on_exit: bool\n    \"\"\"A flag that indicates if the debugger should kill the debugged process when it exits.\"\"\"\n\n    threads: list[ThreadContext]\n    \"\"\"A list of all the threads of the debugged process.\"\"\"\n\n    process_id: int\n    \"\"\"The PID of the debugged process.\"\"\"\n\n    pipe_manager: PipeManager\n    \"\"\"The pipe manager used to communicate with the debugged process.\"\"\"\n\n    memory: AbstractMemoryView\n    \"\"\"The memory view of the debugged process.\"\"\"\n\n    debugging_interface: DebuggingInterface\n    \"\"\"The debugging interface used to communicate with the debugged process.\"\"\"\n\n    instanced: bool = False\n    \"\"\"Whether the process was started and has not been killed yet.\"\"\"\n\n    pprint_syscalls: bool\n    \"\"\"A flag that indicates if the debugger should pretty print syscalls.\"\"\"\n\n    resume_context: ResumeContext\n    \"\"\"Context that indicates if the debugger should resume the debugged process.\"\"\"\n\n    __polling_thread: Thread | None\n    \"\"\"The background thread used to poll the process for state change.\"\"\"\n\n    __polling_thread_command_queue: Queue | None\n    \"\"\"The queue used to send commands to the background thread.\"\"\"\n\n    __polling_thread_response_queue: Queue | None\n    \"\"\"The queue used to receive responses from the background thread.\"\"\"\n\n    _is_running: bool\n    \"\"\"The overall state of the debugged process. True if the process is running, False otherwise.\"\"\"\n\n    _fast_memory: DirectMemoryView\n    \"\"\"The memory view of the debugged process using the fast memory access method.\"\"\"\n\n    _slow_memory: ChunkedMemoryView\n    \"\"\"The memory view of the debugged process using the slow memory access method.\"\"\"\n\n    def __init__(self: InternalDebugger) -&gt; None:\n        \"\"\"Initialize the context.\"\"\"\n        # These must be reinitialized on every call to \"debugger\"\n        self.aslr_enabled = False\n        self.autoreach_entrypoint = True\n        self.argv = []\n        self.env = {}\n        self.escape_antidebug = False\n        self.breakpoints = {}\n        self.handled_syscalls = {}\n        self.caught_signals = {}\n        self.syscalls_to_pprint = None\n        self.syscalls_to_not_pprint = None\n        self.signals_to_block = []\n        self.pprint_syscalls = False\n        self.pipe_manager = None\n        self.process_id = 0\n        self.threads = []\n        self.instanced = False\n        self._is_running = False\n        self.resume_context = ResumeContext()\n        self.arch = map_arch(libcontext.platform)\n        self.kill_on_exit = True\n        self._process_memory_manager = ProcessMemoryManager()\n        self.fast_memory = False\n        self.__polling_thread_command_queue = Queue()\n        self.__polling_thread_response_queue = Queue()\n\n    def clear(self: InternalDebugger) -&gt; None:\n        \"\"\"Reinitializes the context, so it is ready for a new run.\"\"\"\n        # These must be reinitialized on every call to \"run\"\n        self.breakpoints.clear()\n        self.handled_syscalls.clear()\n        self.caught_signals.clear()\n        self.syscalls_to_pprint = None\n        self.syscalls_to_not_pprint = None\n        self.signals_to_block.clear()\n        self.pprint_syscalls = False\n        self.pipe_manager = None\n        self.process_id = 0\n        self.threads.clear()\n        self.instanced = False\n        self._is_running = False\n        self.resume_context.clear()\n\n    def start_up(self: InternalDebugger) -&gt; None:\n        \"\"\"Starts up the context.\"\"\"\n        # The context is linked to itself\n        link_to_internal_debugger(self, self)\n\n        self.start_processing_thread()\n        with extend_internal_debugger(self):\n            self.debugging_interface = provide_debugging_interface()\n            self._fast_memory = DirectMemoryView(self._fast_read_memory, self._fast_write_memory)\n            self._slow_memory = ChunkedMemoryView(\n                self._peek_memory,\n                self._poke_memory,\n                unit_size=get_platform_register_size(libcontext.platform),\n            )\n\n    def start_processing_thread(self: InternalDebugger) -&gt; None:\n        \"\"\"Starts the thread that will poll the traced process for state change.\"\"\"\n        # Set as daemon so that the Python interpreter can exit even if the thread is still running\n        self.__polling_thread = Thread(\n            target=self.__polling_thread_function,\n            name=\"libdebug__polling_thread\",\n            daemon=True,\n        )\n        self.__polling_thread.start()\n\n    def _background_invalid_call(self: InternalDebugger, *_: ..., **__: ...) -&gt; None:\n        \"\"\"Raises an error when an invalid call is made in background mode.\"\"\"\n        raise RuntimeError(\"This method is not available in a callback.\")\n\n    def run(self: InternalDebugger) -&gt; PipeManager:\n        \"\"\"Starts the process and waits for it to stop.\"\"\"\n        if not self.argv:\n            raise RuntimeError(\"No binary file specified.\")\n\n        if not Path(self.argv[0]).is_file():\n            raise RuntimeError(f\"File {self.argv[0]} does not exist.\")\n\n        if not os.access(self.argv[0], os.X_OK):\n            raise RuntimeError(\n                f\"File {self.argv[0]} is not executable.\",\n            )\n\n        if self.instanced:\n            liblog.debugger(\"Process already running, stopping it before restarting.\")\n            self.kill()\n        if self.threads:\n            self.clear()\n            self.debugging_interface.reset()\n\n        self.instanced = True\n\n        if not self.__polling_thread_command_queue.empty():\n            raise RuntimeError(\"Polling thread command queue not empty.\")\n\n        self.__polling_thread_command_queue.put((self.__threaded_run, ()))\n\n        self._join_and_check_status()\n\n        if self.escape_antidebug:\n            liblog.debugger(\"Enabling anti-debugging escape mechanism.\")\n            self._enable_antidebug_escaping()\n\n        if not self.pipe_manager:\n            raise RuntimeError(\"Something went wrong during pipe initialization.\")\n\n        self._process_memory_manager.open(self.process_id)\n\n        return self.pipe_manager\n\n    def attach(self: InternalDebugger, pid: int) -&gt; None:\n        \"\"\"Attaches to an existing process.\"\"\"\n        if self.instanced:\n            liblog.debugger(\"Process already running, stopping it before restarting.\")\n            self.kill()\n        if self.threads:\n            self.clear()\n            self.debugging_interface.reset()\n\n        self.instanced = True\n\n        if not self.__polling_thread_command_queue.empty():\n            raise RuntimeError(\"Polling thread command queue not empty.\")\n\n        self.__polling_thread_command_queue.put((self.__threaded_attach, (pid,)))\n\n        self._join_and_check_status()\n\n        self._process_memory_manager.open(self.process_id)\n\n    def detach(self: InternalDebugger) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot detach.\")\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put((self.__threaded_detach, ()))\n\n        self._join_and_check_status()\n\n        self._process_memory_manager.close()\n\n    @background_alias(_background_invalid_call)\n    def kill(self: InternalDebugger) -&gt; None:\n        \"\"\"Kills the process.\"\"\"\n        try:\n            self._ensure_process_stopped()\n        except (OSError, RuntimeError):\n            # This exception might occur if the process has already died\n            liblog.debugger(\"OSError raised during kill\")\n\n        self._process_memory_manager.close()\n\n        self.__polling_thread_command_queue.put((self.__threaded_kill, ()))\n\n        self.instanced = False\n\n        if self.pipe_manager:\n            self.pipe_manager.close()\n\n        self._join_and_check_status()\n\n    def terminate(self: InternalDebugger) -&gt; None:\n        \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n        The debugger object will not be usable after this method is called.\n        This method should only be called to free up resources when the debugger object is no longer needed.\n        \"\"\"\n        if self.instanced and self.running:\n            self.interrupt()\n\n        if self.instanced:\n            self.kill()\n\n        self.instanced = False\n\n        if self.__polling_thread is not None:\n            self.__polling_thread_command_queue.put((THREAD_TERMINATE, ()))\n            self.__polling_thread.join()\n            del self.__polling_thread\n            self.__polling_thread = None\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def cont(self: InternalDebugger) -&gt; None:\n        \"\"\"Continues the process.\n\n        Args:\n            auto_wait (bool, optional): Whether to automatically wait for the process to stop after continuing. Defaults to True.\n        \"\"\"\n        self.__polling_thread_command_queue.put((self.__threaded_cont, ()))\n\n        self._join_and_check_status()\n\n        self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n\n    @background_alias(_background_invalid_call)\n    def interrupt(self: InternalDebugger) -&gt; None:\n        \"\"\"Interrupts the process.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot interrupt.\")\n\n        # We have to ensure that at least one thread is alive before executing the method\n        if self.threads[0].dead:\n            raise RuntimeError(\"All threads are dead.\")\n\n        if not self.running:\n            return\n\n        self.resume_context.force_interrupt = True\n        os.kill(self.process_id, SIGSTOP)\n\n        self.wait()\n\n    @background_alias(_background_invalid_call)\n    def wait(self: InternalDebugger) -&gt; None:\n        \"\"\"Waits for the process to stop.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot wait.\")\n\n        self._join_and_check_status()\n\n        if self.threads[0].dead or not self.running:\n            # Most of the time the function returns here, as there was a wait already\n            # queued by the previous command\n            return\n\n        self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n\n        self._join_and_check_status()\n\n    def maps(self: InternalDebugger) -&gt; list[MemoryMap]:\n        \"\"\"Returns the memory maps of the process.\"\"\"\n        self._ensure_process_stopped()\n        return self.debugging_interface.maps()\n\n    @property\n    def memory(self: InternalDebugger) -&gt; AbstractMemoryView:\n        \"\"\"The memory view of the debugged process.\"\"\"\n        return self._fast_memory if self.fast_memory else self._slow_memory\n\n    def print_maps(self: InternalDebugger) -&gt; None:\n        \"\"\"Prints the memory maps of the process.\"\"\"\n        self._ensure_process_stopped()\n        maps = self.maps()\n        for memory_map in maps:\n            if \"x\" in memory_map.permissions:\n                print(f\"{PrintStyle.RED}{memory_map}{PrintStyle.RESET}\")\n            elif \"w\" in memory_map.permissions:\n                print(f\"{PrintStyle.YELLOW}{memory_map}{PrintStyle.RESET}\")\n            elif \"r\" in memory_map.permissions:\n                print(f\"{PrintStyle.GREEN}{memory_map}{PrintStyle.RESET}\")\n            else:\n                print(memory_map)\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def breakpoint(\n        self: InternalDebugger,\n        position: int | str,\n        hardware: bool = False,\n        condition: str = \"x\",\n        length: int = 1,\n        callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Sets a breakpoint at the specified location.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software.\n            Defaults to False.\n            condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n            length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n            callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n            breakpoint is hit. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        if isinstance(position, str):\n            address = self.resolve_symbol(position, file)\n        else:\n            address = self.resolve_address(position, file)\n            position = hex(address)\n\n        if condition != \"x\" and not hardware:\n            raise ValueError(\"Breakpoint condition is supported only for hardware watchpoints.\")\n\n        bp = Breakpoint(address, position, 0, hardware, callback, condition.lower(), length)\n\n        if hardware:\n            validate_hardware_breakpoint(self.arch, bp)\n\n        link_to_internal_debugger(bp, self)\n\n        self.__polling_thread_command_queue.put((self.__threaded_breakpoint, (bp,)))\n\n        self._join_and_check_status()\n\n        # the breakpoint should have been set by interface\n        if address not in self.breakpoints:\n            raise RuntimeError(\"Something went wrong while inserting the breakpoint.\")\n\n        return bp\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def catch_signal(\n        self: InternalDebugger,\n        signal: int | str,\n        callback: None | Callable[[ThreadContext, SignalCatcher], None] = None,\n        recursive: bool = False,\n    ) -&gt; SignalCatcher:\n        \"\"\"Catch a signal in the target process.\n\n        Args:\n            signal (int | str): The signal to catch.\n            callback (Callable[[ThreadContext, CaughtSignal], None], optional): A callback to be called when the signal is\n            caught. Defaults to None.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n            associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            CaughtSignal: The CaughtSignal object.\n        \"\"\"\n        if isinstance(signal, str):\n            signal_number = resolve_signal_number(signal)\n        elif isinstance(signal, int):\n            signal_number = signal\n        else:\n            raise TypeError(\"signal must be an int or a str\")\n\n        match signal_number:\n            case SIGKILL.value:\n                raise ValueError(\n                    f\"Cannot catch SIGKILL ({signal_number}) as it cannot be caught or ignored. This is a kernel restriction.\",\n                )\n            case SIGSTOP.value:\n                raise ValueError(\n                    f\"Cannot catch SIGSTOP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n                )\n            case SIGTRAP.value:\n                raise ValueError(\n                    f\"Cannot catch SIGTRAP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n                )\n\n        if signal_number in self.caught_signals:\n            liblog.warning(\n                f\"Signal {resolve_signal_name(signal_number)} ({signal_number}) has already been caught. Overriding it.\",\n            )\n\n        if not isinstance(recursive, bool):\n            raise TypeError(\"recursive must be a boolean\")\n\n        catcher = SignalCatcher(signal_number, callback, recursive)\n\n        link_to_internal_debugger(catcher, self)\n\n        self.__polling_thread_command_queue.put((self.__threaded_catch_signal, (catcher,)))\n\n        self._join_and_check_status()\n\n        return catcher\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def hijack_signal(\n        self: InternalDebugger,\n        original_signal: int | str,\n        new_signal: int | str,\n        recursive: bool = False,\n    ) -&gt; SignalCatcher:\n        \"\"\"Hijack a signal in the target process.\n\n        Args:\n            original_signal (int | str): The signal to hijack.\n            new_signal (int | str): The signal to hijack the original signal with.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n            associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            CaughtSignal: The CaughtSignal object.\n        \"\"\"\n        if isinstance(original_signal, str):\n            original_signal_number = resolve_signal_number(original_signal)\n        else:\n            original_signal_number = original_signal\n\n        new_signal_number = resolve_signal_number(new_signal) if isinstance(new_signal, str) else new_signal\n\n        if original_signal_number == new_signal_number:\n            raise ValueError(\n                \"The original signal and the new signal must be different during hijacking.\",\n            )\n\n        def callback(thread: ThreadContext, _: SignalCatcher) -&gt; None:\n            \"\"\"The callback to execute when the signal is received.\"\"\"\n            thread.signal = new_signal_number\n\n        return self.catch_signal(original_signal_number, callback, recursive)\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def handle_syscall(\n        self: InternalDebugger,\n        syscall: int | str,\n        on_enter: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n        on_exit: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n        recursive: bool = False,\n    ) -&gt; SyscallHandler:\n        \"\"\"Handle a syscall in the target process.\n\n        Args:\n            syscall (int | str): The syscall name or number to handle.\n            on_enter (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n            syscall is entered. Defaults to None.\n            on_exit (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n            syscall is exited. Defaults to None.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n            associated with the new syscall should be considered as well. Defaults to False.\n\n        Returns:\n            HandledSyscall: The HandledSyscall object.\n        \"\"\"\n        syscall_number = resolve_syscall_number(self.arch, syscall) if isinstance(syscall, str) else syscall\n\n        if not isinstance(recursive, bool):\n            raise TypeError(\"recursive must be a boolean\")\n\n        # Check if the syscall is already handled (by the user or by the pretty print handler)\n        if syscall_number in self.handled_syscalls:\n            handler = self.handled_syscalls[syscall_number]\n            if handler.on_enter_user or handler.on_exit_user:\n                liblog.warning(\n                    f\"Syscall {resolve_syscall_name(self.arch, syscall_number)} is already handled by a user-defined handler. Overriding it.\",\n                )\n            handler.on_enter_user = on_enter\n            handler.on_exit_user = on_exit\n            handler.recursive = recursive\n            handler.enabled = True\n        else:\n            handler = SyscallHandler(\n                syscall_number,\n                on_enter,\n                on_exit,\n                None,\n                None,\n                recursive,\n            )\n\n            link_to_internal_debugger(handler, self)\n\n            self.__polling_thread_command_queue.put(\n                (self.__threaded_handle_syscall, (handler,)),\n            )\n\n            self._join_and_check_status()\n\n        return handler\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def hijack_syscall(\n        self: InternalDebugger,\n        original_syscall: int | str,\n        new_syscall: int | str,\n        recursive: bool = True,\n        **kwargs: int,\n    ) -&gt; SyscallHandler:\n        \"\"\"Hijacks a syscall in the target process.\n\n        Args:\n            original_syscall (int | str): The syscall name or number to hijack.\n            new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n            associated with the new syscall should be considered as well. Defaults to False.\n            **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n        Returns:\n            HandledSyscall: The HandledSyscall object.\n        \"\"\"\n        if set(kwargs) - SyscallHijacker.allowed_args:\n            raise ValueError(\"Invalid keyword arguments in syscall hijack\")\n\n        if isinstance(original_syscall, str):\n            original_syscall_number = resolve_syscall_number(self.arch, original_syscall)\n        else:\n            original_syscall_number = original_syscall\n\n        new_syscall_number = (\n            resolve_syscall_number(self.arch, new_syscall) if isinstance(new_syscall, str) else new_syscall\n        )\n\n        if original_syscall_number == new_syscall_number:\n            raise ValueError(\n                \"The original syscall and the new syscall must be different during hijacking.\",\n            )\n\n        on_enter = SyscallHijacker().create_hijacker(\n            new_syscall_number,\n            **kwargs,\n        )\n\n        # Check if the syscall is already handled (by the user or by the pretty print handler)\n        if original_syscall_number in self.handled_syscalls:\n            handler = self.handled_syscalls[original_syscall_number]\n            if handler.on_enter_user or handler.on_exit_user:\n                liblog.warning(\n                    f\"Syscall {original_syscall_number} is already handled by a user-defined handler. Overriding it.\",\n                )\n            handler.on_enter_user = on_enter\n            handler.on_exit_user = None\n            handler.recursive = recursive\n            handler.enabled = True\n        else:\n            handler = SyscallHandler(\n                original_syscall_number,\n                on_enter,\n                None,\n                None,\n                None,\n                recursive,\n            )\n\n            link_to_internal_debugger(handler, self)\n\n            self.__polling_thread_command_queue.put(\n                (self.__threaded_handle_syscall, (handler,)),\n            )\n\n            self._join_and_check_status()\n\n        return handler\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def gdb(self: InternalDebugger, open_in_new_process: bool = True) -&gt; None:\n        \"\"\"Migrates the current debugging session to GDB.\"\"\"\n        # TODO: not needed?\n        self.interrupt()\n\n        self.__polling_thread_command_queue.put((self.__threaded_gdb, ()))\n\n        self._join_and_check_status()\n\n        if open_in_new_process and libcontext.terminal:\n            self._open_gdb_in_new_process()\n        else:\n            if open_in_new_process:\n                liblog.warning(\n                    \"Cannot open in a new process. Please configure the terminal in libcontext.terminal.\",\n                )\n            self._open_gdb_in_shell()\n\n        self.__polling_thread_command_queue.put((self.__threaded_migrate_from_gdb, ()))\n\n        self._join_and_check_status()\n\n    def _craft_gdb_migration_command(self: InternalDebugger) -&gt; list[str]:\n        \"\"\"Crafts the command to migrate to GDB.\"\"\"\n        gdb_command = [\n            \"/bin/gdb\",\n            \"-q\",\n            \"--pid\",\n            str(self.process_id),\n            \"-ex\",\n            \"source \" + GDB_GOBACK_LOCATION,\n            \"-ex\",\n            \"ni\",\n            \"-ex\",\n            \"ni\",\n        ]\n\n        bp_args = []\n        for bp in self.breakpoints.values():\n            if bp.enabled:\n                bp_args.append(\"-ex\")\n\n                if bp.hardware and bp.condition == \"rw\":\n                    bp_args.append(f\"awatch *(int{bp.length * 8}_t *) {bp.address:0x}\")\n                elif bp.hardware and bp.condition == \"w\":\n                    bp_args.append(f\"watch *(int{bp.length * 8}_t *) {bp.address:0x}\")\n                elif bp.hardware:\n                    bp_args.append(\"hb *\" + hex(bp.address))\n                else:\n                    bp_args.append(\"b *\" + hex(bp.address))\n\n                if self.threads[0].instruction_pointer == bp.address and not bp.hardware:\n                    # We have to enqueue an additional continue\n                    bp_args.append(\"-ex\")\n                    bp_args.append(\"ni\")\n\n        return gdb_command + bp_args\n\n    def _open_gdb_in_new_process(self: InternalDebugger) -&gt; None:\n        \"\"\"Opens GDB in a new process following the configuration in libcontext.terminal.\"\"\"\n        args = self._craft_gdb_migration_command()\n\n        initial_pid = Popen(libcontext.terminal + args).pid\n\n        os.waitpid(initial_pid, 0)\n\n        liblog.debugger(\"Waiting for GDB process to terminate...\")\n\n        for proc in psutil.process_iter():\n            try:\n                cmdline = proc.cmdline()\n            except psutil.ZombieProcess:\n                # This is a zombie process, which psutil tracks but we cannot interact with\n                continue\n\n            if args == cmdline:\n                gdb_process = proc\n                break\n        else:\n            raise RuntimeError(\"GDB process not found.\")\n\n        while gdb_process.is_running() and gdb_process.status() != psutil.STATUS_ZOMBIE:\n            # As the GDB process is in a different group, we do not have the authority to wait on it\n            # So we must keep polling it until it is no longer running\n            pass\n\n    def _open_gdb_in_shell(self: InternalDebugger) -&gt; None:\n        \"\"\"Open GDB in the current shell.\"\"\"\n        gdb_pid = os.fork()\n        if gdb_pid == 0:  # This is the child process.\n            args = self._craft_gdb_migration_command()\n            os.execv(\"/bin/gdb\", args)\n        else:  # This is the parent process.\n            # Parent ignores SIGINT, so only GDB (child) receives it\n            signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n            # Wait for the child process to finish\n            os.waitpid(gdb_pid, 0)\n\n            # Reset the SIGINT behavior to default handling after child exits\n            signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    def _background_step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n        \"\"\"\n        self.__threaded_step(thread)\n        self.__threaded_wait()\n\n    @background_alias(_background_step)\n    @change_state_function_thread\n    def step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n        \"\"\"\n        self._ensure_process_stopped()\n        self.__polling_thread_command_queue.put((self.__threaded_step, (thread,)))\n        self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n        self._join_and_check_status()\n\n    def _background_step_until(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Executes instructions of the process until the specified location is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        if isinstance(position, str):\n            address = self.resolve_symbol(position, file)\n        else:\n            address = self.resolve_address(position, file)\n\n        self.__threaded_step_until(thread, address, max_steps)\n\n    @background_alias(_background_step_until)\n    @change_state_function_thread\n    def step_until(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Executes instructions of the process until the specified location is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        if isinstance(position, str):\n            address = self.resolve_symbol(position, file)\n        else:\n            address = self.resolve_address(position, file)\n\n        arguments = (\n            thread,\n            address,\n            max_steps,\n        )\n\n        self.__polling_thread_command_queue.put((self.__threaded_step_until, arguments))\n\n        self._join_and_check_status()\n\n    def _background_finish(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        heuristic: str = \"backtrace\",\n    ) -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            thread (ThreadContext): The thread to finish.\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self.__threaded_finish(thread, heuristic)\n\n    @background_alias(_background_finish)\n    @change_state_function_thread\n    def finish(self: InternalDebugger, thread: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            thread (ThreadContext): The thread to finish.\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_finish, (thread, heuristic)),\n        )\n\n        self._join_and_check_status()\n\n    def _background_next(\n        self: InternalDebugger,\n        thread: ThreadContext,\n    ) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self.__threaded_next(thread)\n\n    @background_alias(_background_next)\n    @change_state_function_thread\n    def next(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._ensure_process_stopped()\n        self.__polling_thread_command_queue.put((self.__threaded_next, (thread,)))\n        self._join_and_check_status()\n\n    def enable_pretty_print(\n        self: InternalDebugger,\n    ) -&gt; SyscallHandler:\n        \"\"\"Handles a syscall in the target process to pretty prints its arguments and return value.\"\"\"\n        self._ensure_process_stopped()\n\n        syscall_numbers = get_all_syscall_numbers(self.arch)\n\n        for syscall_number in syscall_numbers:\n            # Check if the syscall is already handled (by the user or by the pretty print handler)\n            if syscall_number in self.handled_syscalls:\n                handler = self.handled_syscalls[syscall_number]\n                if syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n                    self.syscalls_to_pprint or syscall_numbers\n                ):\n                    handler.on_enter_pprint = pprint_on_enter\n                    handler.on_exit_pprint = pprint_on_exit\n                else:\n                    # Remove the pretty print handler from previous pretty print calls\n                    handler.on_enter_pprint = None\n                    handler.on_exit_pprint = None\n            elif syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n                self.syscalls_to_pprint or syscall_numbers\n            ):\n                handler = SyscallHandler(\n                    syscall_number,\n                    None,\n                    None,\n                    pprint_on_enter,\n                    pprint_on_exit,\n                )\n\n                link_to_internal_debugger(handler, self)\n\n                # We have to disable the handler since it is not user-defined\n                handler.disable()\n\n                self.__polling_thread_command_queue.put(\n                    (self.__threaded_handle_syscall, (handler,)),\n                )\n\n        self._join_and_check_status()\n\n    def disable_pretty_print(self: InternalDebugger) -&gt; None:\n        \"\"\"Disable the handler for all the syscalls that are pretty printed.\"\"\"\n        self._ensure_process_stopped()\n\n        installed_handlers = list(self.handled_syscalls.values())\n        for handler in installed_handlers:\n            if handler.on_enter_pprint or handler.on_exit_pprint:\n                if handler.on_enter_user or handler.on_exit_user:\n                    handler.on_enter_pprint = None\n                    handler.on_exit_pprint = None\n                else:\n                    self.__polling_thread_command_queue.put(\n                        (self.__threaded_unhandle_syscall, (handler,)),\n                    )\n\n        self._join_and_check_status()\n\n    def insert_new_thread(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Insert a new thread in the context.\n\n        Args:\n            thread (ThreadContext): the thread to insert.\n        \"\"\"\n        if thread in self.threads:\n            raise RuntimeError(\"Thread already registered.\")\n\n        self.threads.append(thread)\n\n    def set_thread_as_dead(\n        self: InternalDebugger,\n        thread_id: int,\n        exit_code: int | None,\n        exit_signal: int | None,\n    ) -&gt; None:\n        \"\"\"Set a thread as dead and update its exit code and exit signal.\n\n        Args:\n            thread_id (int): the ID of the thread to set as dead.\n            exit_code (int, optional): the exit code of the thread.\n            exit_signal (int, optional): the exit signal of the thread.\n        \"\"\"\n        for thread in self.threads:\n            if thread.thread_id == thread_id:\n                thread.set_as_dead()\n                thread._exit_code = exit_code\n                thread._exit_signal = exit_signal\n                break\n\n    def get_thread_by_id(self: InternalDebugger, thread_id: int) -&gt; ThreadContext:\n        \"\"\"Get a thread by its ID.\n\n        Args:\n            thread_id (int): the ID of the thread to get.\n\n        Returns:\n            ThreadContext: the thread with the specified ID.\n        \"\"\"\n        for thread in self.threads:\n            if thread.thread_id == thread_id and not thread.dead:\n                return thread\n\n        return None\n\n    def resolve_address(\n        self: InternalDebugger,\n        address: int,\n        backing_file: str,\n        skip_absolute_address_validation: bool = False,\n    ) -&gt; int:\n        \"\"\"Normalizes and validates the specified address.\n\n        Args:\n            address (int): The address to normalize and validate.\n            backing_file (str): The backing file to resolve the address in.\n            skip_absolute_address_validation (bool, optional): Whether to skip bounds checking for absolute addresses. Defaults to False.\n\n        Returns:\n            int: The normalized and validated address.\n\n        Raises:\n            ValueError: If the substring `backing_file` is present in multiple backing files.\n        \"\"\"\n        if skip_absolute_address_validation and backing_file == \"absolute\":\n            return address\n\n        maps = self.debugging_interface.maps()\n\n        if backing_file in [\"hybrid\", \"absolute\"]:\n            if check_absolute_address(address, maps):\n                # If the address is absolute, we can return it directly\n                return address\n            elif backing_file == \"absolute\":\n                # The address is explicitly an absolute address but we did not find it\n                raise ValueError(\n                    \"The specified absolute address does not exist. Check the address or specify a backing file.\",\n                )\n            else:\n                # If the address was not found and the backing file is not \"absolute\",\n                # we have to assume it is in the main map\n                backing_file = self._process_full_path\n                liblog.warning(\n                    f\"No backing file specified and no corresponding absolute address found for {hex(address)}. Assuming {backing_file}.\",\n                )\n        elif backing_file == (full_backing_path := self._process_full_path) or backing_file in [\n            \"binary\",\n            self._process_name,\n        ]:\n            backing_file = full_backing_path\n\n        filtered_maps = []\n        unique_files = set()\n\n        for vmap in maps:\n            if backing_file in vmap.backing_file:\n                filtered_maps.append(vmap)\n                unique_files.add(vmap.backing_file)\n\n        if len(unique_files) &gt; 1:\n            raise ValueError(\n                f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n            )\n\n        if not filtered_maps:\n            raise ValueError(\n                f\"The specified string {backing_file} does not correspond to any backing file. The available backing files are: {', '.join(set(vmap.backing_file for vmap in maps))}.\",\n            )\n        return normalize_and_validate_address(address, filtered_maps)\n\n    def resolve_symbol(self: InternalDebugger, symbol: str, backing_file: str) -&gt; int:\n        \"\"\"Resolves the address of the specified symbol.\n\n        Args:\n            symbol (str): The symbol to resolve.\n            backing_file (str): The backing file to resolve the symbol in.\n\n        Returns:\n            int: The address of the symbol.\n        \"\"\"\n        maps = self.debugging_interface.maps()\n\n        if backing_file == \"absolute\":\n            raise ValueError(\"Cannot use `absolute` backing file with symbols.\")\n\n        if backing_file == \"hybrid\":\n            # If no explicit backing file is specified, we have to assume it is in the main map\n            backing_file = self._process_full_path\n            liblog.debugger(f\"No backing file specified for the symbol {symbol}. Assuming {backing_file}.\")\n        elif backing_file == (full_backing_path := self._process_full_path) or backing_file in [\n            \"binary\",\n            self._process_name,\n        ]:\n            backing_file = full_backing_path\n\n        filtered_maps = []\n        unique_files = set()\n\n        for vmap in maps:\n            if backing_file in vmap.backing_file:\n                filtered_maps.append(vmap)\n                unique_files.add(vmap.backing_file)\n\n        if len(unique_files) &gt; 1:\n            raise ValueError(\n                f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n            )\n\n        if not filtered_maps:\n            raise ValueError(\n                f\"The specified string {backing_file} does not correspond to any backing file. The available backing files are: {', '.join(set(vmap.backing_file for vmap in maps))}.\",\n            )\n\n        return resolve_symbol_in_maps(symbol, filtered_maps)\n\n    def _background_ensure_process_stopped(self: InternalDebugger) -&gt; None:\n        \"\"\"Validates the state of the process.\"\"\"\n        # In background mode, there shouldn't be anything to do here\n\n    @background_alias(_background_ensure_process_stopped)\n    def _ensure_process_stopped(self: InternalDebugger) -&gt; None:\n        \"\"\"Validates the state of the process.\"\"\"\n        if not self.running:\n            return\n\n        if self.auto_interrupt_on_command:\n            self.interrupt()\n\n        self._join_and_check_status()\n\n    def _is_in_background(self: InternalDebugger) -&gt; None:\n        return current_thread() == self.__polling_thread\n\n    def __polling_thread_function(self: InternalDebugger) -&gt; None:\n        \"\"\"This function is run in a thread. It is used to poll the process for state change.\"\"\"\n        while True:\n            # Wait for the main thread to signal a command to execute\n            command, args = self.__polling_thread_command_queue.get()\n\n            if command == THREAD_TERMINATE:\n                # Signal that the command has been executed\n                self.__polling_thread_command_queue.task_done()\n                return\n\n            # Execute the command\n            try:\n                return_value = command(*args)\n            except BaseException as e:\n                return_value = e\n\n            if return_value is not None:\n                self.__polling_thread_response_queue.put(return_value)\n\n            # Signal that the command has been executed\n            self.__polling_thread_command_queue.task_done()\n\n            if return_value is not None:\n                self.__polling_thread_response_queue.join()\n\n    def _join_and_check_status(self: InternalDebugger) -&gt; None:\n        # Wait for the background thread to signal \"task done\" before returning\n        # We don't want any asynchronous behaviour here\n        self.__polling_thread_command_queue.join()\n\n        # Check for any exceptions raised by the background thread\n        if not self.__polling_thread_response_queue.empty():\n            response = self.__polling_thread_response_queue.get()\n            self.__polling_thread_response_queue.task_done()\n            if response is not None:\n                raise response\n\n    @functools.cached_property\n    def _process_full_path(self: InternalDebugger) -&gt; str:\n        \"\"\"Get the full path of the process.\n\n        Returns:\n            str: the full path of the process.\n        \"\"\"\n        return str(Path(f\"/proc/{self.process_id}/exe\").readlink())\n\n    @functools.cached_property\n    def _process_name(self: InternalDebugger) -&gt; str:\n        \"\"\"Get the name of the process.\n\n        Returns:\n            str: the name of the process.\n        \"\"\"\n        with Path(f\"/proc/{self.process_id}/comm\").open() as f:\n            return f.read().strip()\n\n    def __threaded_run(self: InternalDebugger) -&gt; None:\n        liblog.debugger(\"Starting process %s.\", self.argv[0])\n        self.debugging_interface.run()\n\n        self.set_stopped()\n\n    def __threaded_attach(self: InternalDebugger, pid: int) -&gt; None:\n        liblog.debugger(\"Attaching to process %d.\", pid)\n        self.debugging_interface.attach(pid)\n\n        self.set_stopped()\n\n    def __threaded_detach(self: InternalDebugger) -&gt; None:\n        liblog.debugger(\"Detaching from process %d.\", self.process_id)\n        self.debugging_interface.detach()\n\n        self.set_stopped()\n\n    def __threaded_kill(self: InternalDebugger) -&gt; None:\n        if self.argv:\n            liblog.debugger(\n                \"Killing process %s (%d).\",\n                self.argv[0],\n                self.process_id,\n            )\n        else:\n            liblog.debugger(\"Killing process %d.\", self.process_id)\n        self.debugging_interface.kill()\n\n    def __threaded_cont(self: InternalDebugger) -&gt; None:\n        if self.argv:\n            liblog.debugger(\n                \"Continuing process %s (%d).\",\n                self.argv[0],\n                self.process_id,\n            )\n        else:\n            liblog.debugger(\"Continuing process %d.\", self.process_id)\n\n        self.set_running()\n        self.debugging_interface.cont()\n\n    def __threaded_wait(self: InternalDebugger) -&gt; None:\n        if self.argv:\n            liblog.debugger(\n                \"Waiting for process %s (%d) to stop.\",\n                self.argv[0],\n                self.process_id,\n            )\n        else:\n            liblog.debugger(\"Waiting for process %d to stop.\", self.process_id)\n\n        while True:\n            if self.threads[0].dead:\n                # All threads are dead\n                liblog.debugger(\"All threads dead\")\n                break\n            self.resume_context.resume = True\n            self.debugging_interface.wait()\n            if self.resume_context.resume:\n                self.debugging_interface.cont()\n            else:\n                break\n        self.set_stopped()\n\n    def __threaded_breakpoint(self: InternalDebugger, bp: Breakpoint) -&gt; None:\n        liblog.debugger(\"Setting breakpoint at 0x%x.\", bp.address)\n        self.debugging_interface.set_breakpoint(bp)\n\n    def __threaded_catch_signal(self: InternalDebugger, catcher: SignalCatcher) -&gt; None:\n        liblog.debugger(\n            f\"Setting the catcher for signal {resolve_signal_name(catcher.signal_number)} ({catcher.signal_number}).\",\n        )\n        self.debugging_interface.set_signal_catcher(catcher)\n\n    def __threaded_handle_syscall(self: InternalDebugger, handler: SyscallHandler) -&gt; None:\n        liblog.debugger(f\"Setting the handler for syscall {handler.syscall_number}.\")\n        self.debugging_interface.set_syscall_handler(handler)\n\n    def __threaded_unhandle_syscall(self: InternalDebugger, handler: SyscallHandler) -&gt; None:\n        liblog.debugger(f\"Unsetting the handler for syscall {handler.syscall_number}.\")\n        self.debugging_interface.unset_syscall_handler(handler)\n\n    def __threaded_step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        liblog.debugger(\"Stepping thread %s.\", thread.thread_id)\n        self.debugging_interface.step(thread)\n        self.set_running()\n\n    def __threaded_step_until(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        address: int,\n        max_steps: int,\n    ) -&gt; None:\n        liblog.debugger(\"Stepping thread %s until 0x%x.\", thread.thread_id, address)\n        self.debugging_interface.step_until(thread, address, max_steps)\n        self.set_stopped()\n\n    def __threaded_finish(self: InternalDebugger, thread: ThreadContext, heuristic: str) -&gt; None:\n        prefix = heuristic.capitalize()\n\n        liblog.debugger(f\"{prefix} finish on thread %s\", thread.thread_id)\n        self.debugging_interface.finish(thread, heuristic=heuristic)\n\n        self.set_stopped()\n\n    def __threaded_next(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        liblog.debugger(\"Next on thread %s.\", thread.thread_id)\n        self.debugging_interface.next(thread)\n        self.set_stopped()\n\n    def __threaded_gdb(self: InternalDebugger) -&gt; None:\n        self.debugging_interface.migrate_to_gdb()\n\n    def __threaded_migrate_from_gdb(self: InternalDebugger) -&gt; None:\n        self.debugging_interface.migrate_from_gdb()\n\n    def __threaded_peek_memory(self: InternalDebugger, address: int) -&gt; bytes | BaseException:\n        value = self.debugging_interface.peek_memory(address)\n        return value.to_bytes(get_platform_register_size(libcontext.platform), sys.byteorder)\n\n    def __threaded_poke_memory(self: InternalDebugger, address: int, data: bytes) -&gt; None:\n        int_data = int.from_bytes(data, sys.byteorder)\n        self.debugging_interface.poke_memory(address, int_data)\n\n    def __threaded_fetch_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        self.debugging_interface.fetch_fp_registers(registers)\n\n    def __threaded_flush_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        self.debugging_interface.flush_fp_registers(registers)\n\n    @background_alias(__threaded_peek_memory)\n    def _peek_memory(self: InternalDebugger, address: int) -&gt; bytes:\n        \"\"\"Reads memory from the process.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before reading memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_peek_memory, (address,)),\n        )\n\n        # We cannot call _join_and_check_status here, as we need the return value which might not be an exception\n        self.__polling_thread_command_queue.join()\n\n        value = self.__polling_thread_response_queue.get()\n        self.__polling_thread_response_queue.task_done()\n\n        if isinstance(value, BaseException):\n            raise value\n\n        return value\n\n    def _fast_read_memory(self: InternalDebugger, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the process.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before reading memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        return self._process_memory_manager.read(address, size)\n\n    @background_alias(__threaded_poke_memory)\n    def _poke_memory(self: InternalDebugger, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the process.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before writing to memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_poke_memory, (address, data)),\n        )\n\n        self._join_and_check_status()\n\n    def _fast_write_memory(self: InternalDebugger, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the process.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before writing to memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        self._process_memory_manager.write(address, data)\n\n    @background_alias(__threaded_fetch_fp_registers)\n    def _fetch_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        \"\"\"Fetches the floating point registers of a thread.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot read floating-point registers.\")\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_fetch_fp_registers, (registers,)),\n        )\n\n        self._join_and_check_status()\n\n    @background_alias(__threaded_flush_fp_registers)\n    def _flush_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        \"\"\"Flushes the floating point registers of a thread.\"\"\"\n        if not self.instanced:\n            raise RuntimeError(\"Process not running, cannot write floating-point registers.\")\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_flush_fp_registers, (registers,)),\n        )\n\n        self._join_and_check_status()\n\n    def _enable_antidebug_escaping(self: InternalDebugger) -&gt; None:\n        \"\"\"Enables the anti-debugging escape mechanism.\"\"\"\n        handler = SyscallHandler(\n            resolve_syscall_number(self.arch, \"ptrace\"),\n            on_enter_ptrace,\n            on_exit_ptrace,\n            None,\n            None,\n        )\n\n        link_to_internal_debugger(handler, self)\n\n        self.__polling_thread_command_queue.put((self.__threaded_handle_syscall, (handler,)))\n\n        self._join_and_check_status()\n\n        # Seutp hidden state for the handler\n        handler._traceme_called = False\n        handler._command = None\n\n    @property\n    def running(self: InternalDebugger) -&gt; bool:\n        \"\"\"Get the state of the process.\n\n        Returns:\n            bool: True if the process is running, False otherwise.\n        \"\"\"\n        return self._is_running\n\n    def set_running(self: InternalDebugger) -&gt; None:\n        \"\"\"Set the state of the process to running.\"\"\"\n        self._is_running = True\n\n    def set_stopped(self: InternalDebugger) -&gt; None:\n        \"\"\"Set the state of the process to stopped.\"\"\"\n        self._is_running = False\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread","title":"<code>__polling_thread: Thread | None</code>  <code>instance-attribute</code>","text":"<p>The background thread used to poll the process for state change.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread_command_queue","title":"<code>__polling_thread_command_queue: Queue | None = Queue()</code>  <code>instance-attribute</code>","text":"<p>The queue used to send commands to the background thread.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread_response_queue","title":"<code>__polling_thread_response_queue: Queue | None = Queue()</code>  <code>instance-attribute</code>","text":"<p>The queue used to receive responses from the background thread.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.arch","title":"<code>arch: str = map_arch(libcontext.platform)</code>  <code>instance-attribute</code>","text":"<p>The architecture of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.argv","title":"<code>argv: list[str] = []</code>  <code>instance-attribute</code>","text":"<p>The command line arguments of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.aslr_enabled","title":"<code>aslr_enabled: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if ASLR is enabled or not.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.auto_interrupt_on_command","title":"<code>auto_interrupt_on_command: bool</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should automatically interrupt the debugged process when a command is issued.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.autoreach_entrypoint","title":"<code>autoreach_entrypoint: bool = True</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should automatically reach the entry point of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.breakpoints","title":"<code>breakpoints: dict[int, Breakpoint] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of all the breakpoints set on the process. Key: the address of the breakpoint.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.caught_signals","title":"<code>caught_signals: dict[int, SignalCatcher] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of all the signals caught in the process. Key: the signal number.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.debugging_interface","title":"<code>debugging_interface: DebuggingInterface</code>  <code>instance-attribute</code>","text":"<p>The debugging interface used to communicate with the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.env","title":"<code>env: dict[str, str] | None = {}</code>  <code>instance-attribute</code>","text":"<p>The environment variables of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.escape_antidebug","title":"<code>escape_antidebug: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should escape anti-debugging techniques.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.fast_memory","title":"<code>fast_memory: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should use a faster memory access method.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.handled_syscalls","title":"<code>handled_syscalls: dict[int, SyscallHandler] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of all the syscall handled in the process. Key: the syscall number.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.instanced","title":"<code>instanced: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the process was started and has not been killed yet.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.kill_on_exit","title":"<code>kill_on_exit: bool = True</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should kill the debugged process when it exits.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.memory","title":"<code>memory: AbstractMemoryView</code>  <code>property</code>","text":"<p>The memory view of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.pipe_manager","title":"<code>pipe_manager: PipeManager = None</code>  <code>instance-attribute</code>","text":"<p>The pipe manager used to communicate with the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.pprint_syscalls","title":"<code>pprint_syscalls: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should pretty print syscalls.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.process_id","title":"<code>process_id: int = 0</code>  <code>instance-attribute</code>","text":"<p>The PID of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.resume_context","title":"<code>resume_context: ResumeContext = ResumeContext()</code>  <code>instance-attribute</code>","text":"<p>Context that indicates if the debugger should resume the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Get the state of the process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the process is running, False otherwise.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.signals_to_block","title":"<code>signals_to_block: list[int] = []</code>  <code>instance-attribute</code>","text":"<p>The signals to not forward to the process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.syscalls_to_not_pprint","title":"<code>syscalls_to_not_pprint: list[int] | None = None</code>  <code>instance-attribute</code>","text":"<p>The syscalls to not pretty print.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.syscalls_to_pprint","title":"<code>syscalls_to_pprint: list[int] | None = None</code>  <code>instance-attribute</code>","text":"<p>The syscalls to pretty print.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.threads","title":"<code>threads: list[ThreadContext] = []</code>  <code>instance-attribute</code>","text":"<p>A list of all the threads of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the context.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def __init__(self: InternalDebugger) -&gt; None:\n    \"\"\"Initialize the context.\"\"\"\n    # These must be reinitialized on every call to \"debugger\"\n    self.aslr_enabled = False\n    self.autoreach_entrypoint = True\n    self.argv = []\n    self.env = {}\n    self.escape_antidebug = False\n    self.breakpoints = {}\n    self.handled_syscalls = {}\n    self.caught_signals = {}\n    self.syscalls_to_pprint = None\n    self.syscalls_to_not_pprint = None\n    self.signals_to_block = []\n    self.pprint_syscalls = False\n    self.pipe_manager = None\n    self.process_id = 0\n    self.threads = []\n    self.instanced = False\n    self._is_running = False\n    self.resume_context = ResumeContext()\n    self.arch = map_arch(libcontext.platform)\n    self.kill_on_exit = True\n    self._process_memory_manager = ProcessMemoryManager()\n    self.fast_memory = False\n    self.__polling_thread_command_queue = Queue()\n    self.__polling_thread_response_queue = Queue()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread_function","title":"<code>__polling_thread_function()</code>","text":"<p>This function is run in a thread. It is used to poll the process for state change.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def __polling_thread_function(self: InternalDebugger) -&gt; None:\n    \"\"\"This function is run in a thread. It is used to poll the process for state change.\"\"\"\n    while True:\n        # Wait for the main thread to signal a command to execute\n        command, args = self.__polling_thread_command_queue.get()\n\n        if command == THREAD_TERMINATE:\n            # Signal that the command has been executed\n            self.__polling_thread_command_queue.task_done()\n            return\n\n        # Execute the command\n        try:\n            return_value = command(*args)\n        except BaseException as e:\n            return_value = e\n\n        if return_value is not None:\n            self.__polling_thread_response_queue.put(return_value)\n\n        # Signal that the command has been executed\n        self.__polling_thread_command_queue.task_done()\n\n        if return_value is not None:\n            self.__polling_thread_response_queue.join()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.attach","title":"<code>attach(pid)</code>","text":"<p>Attaches to an existing process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def attach(self: InternalDebugger, pid: int) -&gt; None:\n    \"\"\"Attaches to an existing process.\"\"\"\n    if self.instanced:\n        liblog.debugger(\"Process already running, stopping it before restarting.\")\n        self.kill()\n    if self.threads:\n        self.clear()\n        self.debugging_interface.reset()\n\n    self.instanced = True\n\n    if not self.__polling_thread_command_queue.empty():\n        raise RuntimeError(\"Polling thread command queue not empty.\")\n\n    self.__polling_thread_command_queue.put((self.__threaded_attach, (pid,)))\n\n    self._join_and_check_status()\n\n    self._process_memory_manager.open(self.process_id)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.breakpoint","title":"<code>breakpoint(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')</code>","text":"<p>Sets a breakpoint at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>hardware</code> <code>bool</code> <p>Whether the breakpoint should be hardware-assisted or purely software.</p> <code>False</code> <code>condition</code> <code>str</code> <p>The trigger condition for the breakpoint. Defaults to None.</p> <code>'x'</code> <code>length</code> <code>int</code> <p>The length of the breakpoint. Only for watchpoints. Defaults to 1.</p> <code>1</code> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\"</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef breakpoint(\n    self: InternalDebugger,\n    position: int | str,\n    hardware: bool = False,\n    condition: str = \"x\",\n    length: int = 1,\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Sets a breakpoint at the specified location.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software.\n        Defaults to False.\n        condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n        length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n        callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the\n        breakpoint is hit. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n        (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n        the \"binary\" map file).\n    \"\"\"\n    if isinstance(position, str):\n        address = self.resolve_symbol(position, file)\n    else:\n        address = self.resolve_address(position, file)\n        position = hex(address)\n\n    if condition != \"x\" and not hardware:\n        raise ValueError(\"Breakpoint condition is supported only for hardware watchpoints.\")\n\n    bp = Breakpoint(address, position, 0, hardware, callback, condition.lower(), length)\n\n    if hardware:\n        validate_hardware_breakpoint(self.arch, bp)\n\n    link_to_internal_debugger(bp, self)\n\n    self.__polling_thread_command_queue.put((self.__threaded_breakpoint, (bp,)))\n\n    self._join_and_check_status()\n\n    # the breakpoint should have been set by interface\n    if address not in self.breakpoints:\n        raise RuntimeError(\"Something went wrong while inserting the breakpoint.\")\n\n    return bp\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.catch_signal","title":"<code>catch_signal(signal, callback=None, recursive=False)</code>","text":"<p>Catch a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>int | str</code> <p>The signal to catch.</p> required <code>callback</code> <code>Callable[[ThreadContext, CaughtSignal], None]</code> <p>A callback to be called when the signal is</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CaughtSignal</code> <code>SignalCatcher</code> <p>The CaughtSignal object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef catch_signal(\n    self: InternalDebugger,\n    signal: int | str,\n    callback: None | Callable[[ThreadContext, SignalCatcher], None] = None,\n    recursive: bool = False,\n) -&gt; SignalCatcher:\n    \"\"\"Catch a signal in the target process.\n\n    Args:\n        signal (int | str): The signal to catch.\n        callback (Callable[[ThreadContext, CaughtSignal], None], optional): A callback to be called when the signal is\n        caught. Defaults to None.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n        associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        CaughtSignal: The CaughtSignal object.\n    \"\"\"\n    if isinstance(signal, str):\n        signal_number = resolve_signal_number(signal)\n    elif isinstance(signal, int):\n        signal_number = signal\n    else:\n        raise TypeError(\"signal must be an int or a str\")\n\n    match signal_number:\n        case SIGKILL.value:\n            raise ValueError(\n                f\"Cannot catch SIGKILL ({signal_number}) as it cannot be caught or ignored. This is a kernel restriction.\",\n            )\n        case SIGSTOP.value:\n            raise ValueError(\n                f\"Cannot catch SIGSTOP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n            )\n        case SIGTRAP.value:\n            raise ValueError(\n                f\"Cannot catch SIGTRAP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n            )\n\n    if signal_number in self.caught_signals:\n        liblog.warning(\n            f\"Signal {resolve_signal_name(signal_number)} ({signal_number}) has already been caught. Overriding it.\",\n        )\n\n    if not isinstance(recursive, bool):\n        raise TypeError(\"recursive must be a boolean\")\n\n    catcher = SignalCatcher(signal_number, callback, recursive)\n\n    link_to_internal_debugger(catcher, self)\n\n    self.__polling_thread_command_queue.put((self.__threaded_catch_signal, (catcher,)))\n\n    self._join_and_check_status()\n\n    return catcher\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.clear","title":"<code>clear()</code>","text":"<p>Reinitializes the context, so it is ready for a new run.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def clear(self: InternalDebugger) -&gt; None:\n    \"\"\"Reinitializes the context, so it is ready for a new run.\"\"\"\n    # These must be reinitialized on every call to \"run\"\n    self.breakpoints.clear()\n    self.handled_syscalls.clear()\n    self.caught_signals.clear()\n    self.syscalls_to_pprint = None\n    self.syscalls_to_not_pprint = None\n    self.signals_to_block.clear()\n    self.pprint_syscalls = False\n    self.pipe_manager = None\n    self.process_id = 0\n    self.threads.clear()\n    self.instanced = False\n    self._is_running = False\n    self.resume_context.clear()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.cont","title":"<code>cont()</code>","text":"<p>Continues the process.</p> <p>Parameters:</p> Name Type Description Default <code>auto_wait</code> <code>bool</code> <p>Whether to automatically wait for the process to stop after continuing. Defaults to True.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef cont(self: InternalDebugger) -&gt; None:\n    \"\"\"Continues the process.\n\n    Args:\n        auto_wait (bool, optional): Whether to automatically wait for the process to stop after continuing. Defaults to True.\n    \"\"\"\n    self.__polling_thread_command_queue.put((self.__threaded_cont, ()))\n\n    self._join_and_check_status()\n\n    self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.detach","title":"<code>detach()</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def detach(self: InternalDebugger) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n    if not self.instanced:\n        raise RuntimeError(\"Process not running, cannot detach.\")\n\n    self._ensure_process_stopped()\n\n    self.__polling_thread_command_queue.put((self.__threaded_detach, ()))\n\n    self._join_and_check_status()\n\n    self._process_memory_manager.close()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.disable_pretty_print","title":"<code>disable_pretty_print()</code>","text":"<p>Disable the handler for all the syscalls that are pretty printed.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def disable_pretty_print(self: InternalDebugger) -&gt; None:\n    \"\"\"Disable the handler for all the syscalls that are pretty printed.\"\"\"\n    self._ensure_process_stopped()\n\n    installed_handlers = list(self.handled_syscalls.values())\n    for handler in installed_handlers:\n        if handler.on_enter_pprint or handler.on_exit_pprint:\n            if handler.on_enter_user or handler.on_exit_user:\n                handler.on_enter_pprint = None\n                handler.on_exit_pprint = None\n            else:\n                self.__polling_thread_command_queue.put(\n                    (self.__threaded_unhandle_syscall, (handler,)),\n                )\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.enable_pretty_print","title":"<code>enable_pretty_print()</code>","text":"<p>Handles a syscall in the target process to pretty prints its arguments and return value.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def enable_pretty_print(\n    self: InternalDebugger,\n) -&gt; SyscallHandler:\n    \"\"\"Handles a syscall in the target process to pretty prints its arguments and return value.\"\"\"\n    self._ensure_process_stopped()\n\n    syscall_numbers = get_all_syscall_numbers(self.arch)\n\n    for syscall_number in syscall_numbers:\n        # Check if the syscall is already handled (by the user or by the pretty print handler)\n        if syscall_number in self.handled_syscalls:\n            handler = self.handled_syscalls[syscall_number]\n            if syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n                self.syscalls_to_pprint or syscall_numbers\n            ):\n                handler.on_enter_pprint = pprint_on_enter\n                handler.on_exit_pprint = pprint_on_exit\n            else:\n                # Remove the pretty print handler from previous pretty print calls\n                handler.on_enter_pprint = None\n                handler.on_exit_pprint = None\n        elif syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n            self.syscalls_to_pprint or syscall_numbers\n        ):\n            handler = SyscallHandler(\n                syscall_number,\n                None,\n                None,\n                pprint_on_enter,\n                pprint_on_exit,\n            )\n\n            link_to_internal_debugger(handler, self)\n\n            # We have to disable the handler since it is not user-defined\n            handler.disable()\n\n            self.__polling_thread_command_queue.put(\n                (self.__threaded_handle_syscall, (handler,)),\n            )\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.finish","title":"<code>finish(thread, heuristic='backtrace')</code>","text":"<p>Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to finish.</p> required <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_finish)\n@change_state_function_thread\ndef finish(self: InternalDebugger, thread: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        thread (ThreadContext): The thread to finish.\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self.__polling_thread_command_queue.put(\n        (self.__threaded_finish, (thread, heuristic)),\n    )\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.gdb","title":"<code>gdb(open_in_new_process=True)</code>","text":"<p>Migrates the current debugging session to GDB.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef gdb(self: InternalDebugger, open_in_new_process: bool = True) -&gt; None:\n    \"\"\"Migrates the current debugging session to GDB.\"\"\"\n    # TODO: not needed?\n    self.interrupt()\n\n    self.__polling_thread_command_queue.put((self.__threaded_gdb, ()))\n\n    self._join_and_check_status()\n\n    if open_in_new_process and libcontext.terminal:\n        self._open_gdb_in_new_process()\n    else:\n        if open_in_new_process:\n            liblog.warning(\n                \"Cannot open in a new process. Please configure the terminal in libcontext.terminal.\",\n            )\n        self._open_gdb_in_shell()\n\n    self.__polling_thread_command_queue.put((self.__threaded_migrate_from_gdb, ()))\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.get_thread_by_id","title":"<code>get_thread_by_id(thread_id)</code>","text":"<p>Get a thread by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>the ID of the thread to get.</p> required <p>Returns:</p> Name Type Description <code>ThreadContext</code> <code>ThreadContext</code> <p>the thread with the specified ID.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def get_thread_by_id(self: InternalDebugger, thread_id: int) -&gt; ThreadContext:\n    \"\"\"Get a thread by its ID.\n\n    Args:\n        thread_id (int): the ID of the thread to get.\n\n    Returns:\n        ThreadContext: the thread with the specified ID.\n    \"\"\"\n    for thread in self.threads:\n        if thread.thread_id == thread_id and not thread.dead:\n            return thread\n\n    return None\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.handle_syscall","title":"<code>handle_syscall(syscall, on_enter=None, on_exit=None, recursive=False)</code>","text":"<p>Handle a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>syscall</code> <code>int | str</code> <p>The syscall name or number to handle.</p> required <code>on_enter</code> <code>Callable[[ThreadContext, HandledSyscall], None]</code> <p>The callback to execute when the</p> <code>None</code> <code>on_exit</code> <code>Callable[[ThreadContext, HandledSyscall], None]</code> <p>The callback to execute when the</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler</p> <code>False</code> <p>Returns:</p> Name Type Description <code>HandledSyscall</code> <code>SyscallHandler</code> <p>The HandledSyscall object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef handle_syscall(\n    self: InternalDebugger,\n    syscall: int | str,\n    on_enter: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n    on_exit: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n    recursive: bool = False,\n) -&gt; SyscallHandler:\n    \"\"\"Handle a syscall in the target process.\n\n    Args:\n        syscall (int | str): The syscall name or number to handle.\n        on_enter (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n        syscall is entered. Defaults to None.\n        on_exit (Callable[[ThreadContext, HandledSyscall], None], optional): The callback to execute when the\n        syscall is exited. Defaults to None.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n        associated with the new syscall should be considered as well. Defaults to False.\n\n    Returns:\n        HandledSyscall: The HandledSyscall object.\n    \"\"\"\n    syscall_number = resolve_syscall_number(self.arch, syscall) if isinstance(syscall, str) else syscall\n\n    if not isinstance(recursive, bool):\n        raise TypeError(\"recursive must be a boolean\")\n\n    # Check if the syscall is already handled (by the user or by the pretty print handler)\n    if syscall_number in self.handled_syscalls:\n        handler = self.handled_syscalls[syscall_number]\n        if handler.on_enter_user or handler.on_exit_user:\n            liblog.warning(\n                f\"Syscall {resolve_syscall_name(self.arch, syscall_number)} is already handled by a user-defined handler. Overriding it.\",\n            )\n        handler.on_enter_user = on_enter\n        handler.on_exit_user = on_exit\n        handler.recursive = recursive\n        handler.enabled = True\n    else:\n        handler = SyscallHandler(\n            syscall_number,\n            on_enter,\n            on_exit,\n            None,\n            None,\n            recursive,\n        )\n\n        link_to_internal_debugger(handler, self)\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_handle_syscall, (handler,)),\n        )\n\n        self._join_and_check_status()\n\n    return handler\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.hijack_signal","title":"<code>hijack_signal(original_signal, new_signal, recursive=False)</code>","text":"<p>Hijack a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_signal</code> <code>int | str</code> <p>The signal to hijack.</p> required <code>new_signal</code> <code>int | str</code> <p>The signal to hijack the original signal with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher</p> <code>False</code> <p>Returns:</p> Name Type Description <code>CaughtSignal</code> <code>SignalCatcher</code> <p>The CaughtSignal object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef hijack_signal(\n    self: InternalDebugger,\n    original_signal: int | str,\n    new_signal: int | str,\n    recursive: bool = False,\n) -&gt; SignalCatcher:\n    \"\"\"Hijack a signal in the target process.\n\n    Args:\n        original_signal (int | str): The signal to hijack.\n        new_signal (int | str): The signal to hijack the original signal with.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher\n        associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        CaughtSignal: The CaughtSignal object.\n    \"\"\"\n    if isinstance(original_signal, str):\n        original_signal_number = resolve_signal_number(original_signal)\n    else:\n        original_signal_number = original_signal\n\n    new_signal_number = resolve_signal_number(new_signal) if isinstance(new_signal, str) else new_signal\n\n    if original_signal_number == new_signal_number:\n        raise ValueError(\n            \"The original signal and the new signal must be different during hijacking.\",\n        )\n\n    def callback(thread: ThreadContext, _: SignalCatcher) -&gt; None:\n        \"\"\"The callback to execute when the signal is received.\"\"\"\n        thread.signal = new_signal_number\n\n    return self.catch_signal(original_signal_number, callback, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.hijack_syscall","title":"<code>hijack_syscall(original_syscall, new_syscall, recursive=True, **kwargs)</code>","text":"<p>Hijacks a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack.</p> required <code>new_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack the original syscall with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler</p> <code>True</code> <code>**kwargs</code> <code>int</code> <p>(int, optional): The arguments to pass to the new syscall.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>HandledSyscall</code> <code>SyscallHandler</code> <p>The HandledSyscall object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef hijack_syscall(\n    self: InternalDebugger,\n    original_syscall: int | str,\n    new_syscall: int | str,\n    recursive: bool = True,\n    **kwargs: int,\n) -&gt; SyscallHandler:\n    \"\"\"Hijacks a syscall in the target process.\n\n    Args:\n        original_syscall (int | str): The syscall name or number to hijack.\n        new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler\n        associated with the new syscall should be considered as well. Defaults to False.\n        **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n    Returns:\n        HandledSyscall: The HandledSyscall object.\n    \"\"\"\n    if set(kwargs) - SyscallHijacker.allowed_args:\n        raise ValueError(\"Invalid keyword arguments in syscall hijack\")\n\n    if isinstance(original_syscall, str):\n        original_syscall_number = resolve_syscall_number(self.arch, original_syscall)\n    else:\n        original_syscall_number = original_syscall\n\n    new_syscall_number = (\n        resolve_syscall_number(self.arch, new_syscall) if isinstance(new_syscall, str) else new_syscall\n    )\n\n    if original_syscall_number == new_syscall_number:\n        raise ValueError(\n            \"The original syscall and the new syscall must be different during hijacking.\",\n        )\n\n    on_enter = SyscallHijacker().create_hijacker(\n        new_syscall_number,\n        **kwargs,\n    )\n\n    # Check if the syscall is already handled (by the user or by the pretty print handler)\n    if original_syscall_number in self.handled_syscalls:\n        handler = self.handled_syscalls[original_syscall_number]\n        if handler.on_enter_user or handler.on_exit_user:\n            liblog.warning(\n                f\"Syscall {original_syscall_number} is already handled by a user-defined handler. Overriding it.\",\n            )\n        handler.on_enter_user = on_enter\n        handler.on_exit_user = None\n        handler.recursive = recursive\n        handler.enabled = True\n    else:\n        handler = SyscallHandler(\n            original_syscall_number,\n            on_enter,\n            None,\n            None,\n            None,\n            recursive,\n        )\n\n        link_to_internal_debugger(handler, self)\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_handle_syscall, (handler,)),\n        )\n\n        self._join_and_check_status()\n\n    return handler\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.insert_new_thread","title":"<code>insert_new_thread(thread)</code>","text":"<p>Insert a new thread in the context.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>the thread to insert.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def insert_new_thread(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n    \"\"\"Insert a new thread in the context.\n\n    Args:\n        thread (ThreadContext): the thread to insert.\n    \"\"\"\n    if thread in self.threads:\n        raise RuntimeError(\"Thread already registered.\")\n\n    self.threads.append(thread)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.interrupt","title":"<code>interrupt()</code>","text":"<p>Interrupts the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\ndef interrupt(self: InternalDebugger) -&gt; None:\n    \"\"\"Interrupts the process.\"\"\"\n    if not self.instanced:\n        raise RuntimeError(\"Process not running, cannot interrupt.\")\n\n    # We have to ensure that at least one thread is alive before executing the method\n    if self.threads[0].dead:\n        raise RuntimeError(\"All threads are dead.\")\n\n    if not self.running:\n        return\n\n    self.resume_context.force_interrupt = True\n    os.kill(self.process_id, SIGSTOP)\n\n    self.wait()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.kill","title":"<code>kill()</code>","text":"<p>Kills the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\ndef kill(self: InternalDebugger) -&gt; None:\n    \"\"\"Kills the process.\"\"\"\n    try:\n        self._ensure_process_stopped()\n    except (OSError, RuntimeError):\n        # This exception might occur if the process has already died\n        liblog.debugger(\"OSError raised during kill\")\n\n    self._process_memory_manager.close()\n\n    self.__polling_thread_command_queue.put((self.__threaded_kill, ()))\n\n    self.instanced = False\n\n    if self.pipe_manager:\n        self.pipe_manager.close()\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.maps","title":"<code>maps()</code>","text":"<p>Returns the memory maps of the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def maps(self: InternalDebugger) -&gt; list[MemoryMap]:\n    \"\"\"Returns the memory maps of the process.\"\"\"\n    self._ensure_process_stopped()\n    return self.debugging_interface.maps()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.next","title":"<code>next(thread)</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_next)\n@change_state_function_thread\ndef next(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._ensure_process_stopped()\n    self.__polling_thread_command_queue.put((self.__threaded_next, (thread,)))\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.print_maps","title":"<code>print_maps()</code>","text":"<p>Prints the memory maps of the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def print_maps(self: InternalDebugger) -&gt; None:\n    \"\"\"Prints the memory maps of the process.\"\"\"\n    self._ensure_process_stopped()\n    maps = self.maps()\n    for memory_map in maps:\n        if \"x\" in memory_map.permissions:\n            print(f\"{PrintStyle.RED}{memory_map}{PrintStyle.RESET}\")\n        elif \"w\" in memory_map.permissions:\n            print(f\"{PrintStyle.YELLOW}{memory_map}{PrintStyle.RESET}\")\n        elif \"r\" in memory_map.permissions:\n            print(f\"{PrintStyle.GREEN}{memory_map}{PrintStyle.RESET}\")\n        else:\n            print(memory_map)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.resolve_address","title":"<code>resolve_address(address, backing_file, skip_absolute_address_validation=False)</code>","text":"<p>Normalizes and validates the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to normalize and validate.</p> required <code>backing_file</code> <code>str</code> <p>The backing file to resolve the address in.</p> required <code>skip_absolute_address_validation</code> <code>bool</code> <p>Whether to skip bounds checking for absolute addresses. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The normalized and validated address.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the substring <code>backing_file</code> is present in multiple backing files.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def resolve_address(\n    self: InternalDebugger,\n    address: int,\n    backing_file: str,\n    skip_absolute_address_validation: bool = False,\n) -&gt; int:\n    \"\"\"Normalizes and validates the specified address.\n\n    Args:\n        address (int): The address to normalize and validate.\n        backing_file (str): The backing file to resolve the address in.\n        skip_absolute_address_validation (bool, optional): Whether to skip bounds checking for absolute addresses. Defaults to False.\n\n    Returns:\n        int: The normalized and validated address.\n\n    Raises:\n        ValueError: If the substring `backing_file` is present in multiple backing files.\n    \"\"\"\n    if skip_absolute_address_validation and backing_file == \"absolute\":\n        return address\n\n    maps = self.debugging_interface.maps()\n\n    if backing_file in [\"hybrid\", \"absolute\"]:\n        if check_absolute_address(address, maps):\n            # If the address is absolute, we can return it directly\n            return address\n        elif backing_file == \"absolute\":\n            # The address is explicitly an absolute address but we did not find it\n            raise ValueError(\n                \"The specified absolute address does not exist. Check the address or specify a backing file.\",\n            )\n        else:\n            # If the address was not found and the backing file is not \"absolute\",\n            # we have to assume it is in the main map\n            backing_file = self._process_full_path\n            liblog.warning(\n                f\"No backing file specified and no corresponding absolute address found for {hex(address)}. Assuming {backing_file}.\",\n            )\n    elif backing_file == (full_backing_path := self._process_full_path) or backing_file in [\n        \"binary\",\n        self._process_name,\n    ]:\n        backing_file = full_backing_path\n\n    filtered_maps = []\n    unique_files = set()\n\n    for vmap in maps:\n        if backing_file in vmap.backing_file:\n            filtered_maps.append(vmap)\n            unique_files.add(vmap.backing_file)\n\n    if len(unique_files) &gt; 1:\n        raise ValueError(\n            f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n        )\n\n    if not filtered_maps:\n        raise ValueError(\n            f\"The specified string {backing_file} does not correspond to any backing file. The available backing files are: {', '.join(set(vmap.backing_file for vmap in maps))}.\",\n        )\n    return normalize_and_validate_address(address, filtered_maps)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.resolve_symbol","title":"<code>resolve_symbol(symbol, backing_file)</code>","text":"<p>Resolves the address of the specified symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to resolve.</p> required <code>backing_file</code> <code>str</code> <p>The backing file to resolve the symbol in.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The address of the symbol.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def resolve_symbol(self: InternalDebugger, symbol: str, backing_file: str) -&gt; int:\n    \"\"\"Resolves the address of the specified symbol.\n\n    Args:\n        symbol (str): The symbol to resolve.\n        backing_file (str): The backing file to resolve the symbol in.\n\n    Returns:\n        int: The address of the symbol.\n    \"\"\"\n    maps = self.debugging_interface.maps()\n\n    if backing_file == \"absolute\":\n        raise ValueError(\"Cannot use `absolute` backing file with symbols.\")\n\n    if backing_file == \"hybrid\":\n        # If no explicit backing file is specified, we have to assume it is in the main map\n        backing_file = self._process_full_path\n        liblog.debugger(f\"No backing file specified for the symbol {symbol}. Assuming {backing_file}.\")\n    elif backing_file == (full_backing_path := self._process_full_path) or backing_file in [\n        \"binary\",\n        self._process_name,\n    ]:\n        backing_file = full_backing_path\n\n    filtered_maps = []\n    unique_files = set()\n\n    for vmap in maps:\n        if backing_file in vmap.backing_file:\n            filtered_maps.append(vmap)\n            unique_files.add(vmap.backing_file)\n\n    if len(unique_files) &gt; 1:\n        raise ValueError(\n            f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n        )\n\n    if not filtered_maps:\n        raise ValueError(\n            f\"The specified string {backing_file} does not correspond to any backing file. The available backing files are: {', '.join(set(vmap.backing_file for vmap in maps))}.\",\n        )\n\n    return resolve_symbol_in_maps(symbol, filtered_maps)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.run","title":"<code>run()</code>","text":"<p>Starts the process and waits for it to stop.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def run(self: InternalDebugger) -&gt; PipeManager:\n    \"\"\"Starts the process and waits for it to stop.\"\"\"\n    if not self.argv:\n        raise RuntimeError(\"No binary file specified.\")\n\n    if not Path(self.argv[0]).is_file():\n        raise RuntimeError(f\"File {self.argv[0]} does not exist.\")\n\n    if not os.access(self.argv[0], os.X_OK):\n        raise RuntimeError(\n            f\"File {self.argv[0]} is not executable.\",\n        )\n\n    if self.instanced:\n        liblog.debugger(\"Process already running, stopping it before restarting.\")\n        self.kill()\n    if self.threads:\n        self.clear()\n        self.debugging_interface.reset()\n\n    self.instanced = True\n\n    if not self.__polling_thread_command_queue.empty():\n        raise RuntimeError(\"Polling thread command queue not empty.\")\n\n    self.__polling_thread_command_queue.put((self.__threaded_run, ()))\n\n    self._join_and_check_status()\n\n    if self.escape_antidebug:\n        liblog.debugger(\"Enabling anti-debugging escape mechanism.\")\n        self._enable_antidebug_escaping()\n\n    if not self.pipe_manager:\n        raise RuntimeError(\"Something went wrong during pipe initialization.\")\n\n    self._process_memory_manager.open(self.process_id)\n\n    return self.pipe_manager\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.set_running","title":"<code>set_running()</code>","text":"<p>Set the state of the process to running.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def set_running(self: InternalDebugger) -&gt; None:\n    \"\"\"Set the state of the process to running.\"\"\"\n    self._is_running = True\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.set_stopped","title":"<code>set_stopped()</code>","text":"<p>Set the state of the process to stopped.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def set_stopped(self: InternalDebugger) -&gt; None:\n    \"\"\"Set the state of the process to stopped.\"\"\"\n    self._is_running = False\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.set_thread_as_dead","title":"<code>set_thread_as_dead(thread_id, exit_code, exit_signal)</code>","text":"<p>Set a thread as dead and update its exit code and exit signal.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>the ID of the thread to set as dead.</p> required <code>exit_code</code> <code>int</code> <p>the exit code of the thread.</p> required <code>exit_signal</code> <code>int</code> <p>the exit signal of the thread.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def set_thread_as_dead(\n    self: InternalDebugger,\n    thread_id: int,\n    exit_code: int | None,\n    exit_signal: int | None,\n) -&gt; None:\n    \"\"\"Set a thread as dead and update its exit code and exit signal.\n\n    Args:\n        thread_id (int): the ID of the thread to set as dead.\n        exit_code (int, optional): the exit code of the thread.\n        exit_signal (int, optional): the exit signal of the thread.\n    \"\"\"\n    for thread in self.threads:\n        if thread.thread_id == thread_id:\n            thread.set_as_dead()\n            thread._exit_code = exit_code\n            thread._exit_signal = exit_signal\n            break\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.start_processing_thread","title":"<code>start_processing_thread()</code>","text":"<p>Starts the thread that will poll the traced process for state change.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def start_processing_thread(self: InternalDebugger) -&gt; None:\n    \"\"\"Starts the thread that will poll the traced process for state change.\"\"\"\n    # Set as daemon so that the Python interpreter can exit even if the thread is still running\n    self.__polling_thread = Thread(\n        target=self.__polling_thread_function,\n        name=\"libdebug__polling_thread\",\n        daemon=True,\n    )\n    self.__polling_thread.start()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.start_up","title":"<code>start_up()</code>","text":"<p>Starts up the context.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def start_up(self: InternalDebugger) -&gt; None:\n    \"\"\"Starts up the context.\"\"\"\n    # The context is linked to itself\n    link_to_internal_debugger(self, self)\n\n    self.start_processing_thread()\n    with extend_internal_debugger(self):\n        self.debugging_interface = provide_debugging_interface()\n        self._fast_memory = DirectMemoryView(self._fast_read_memory, self._fast_write_memory)\n        self._slow_memory = ChunkedMemoryView(\n            self._peek_memory,\n            self._poke_memory,\n            unit_size=get_platform_register_size(libcontext.platform),\n        )\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.step","title":"<code>step(thread)</code>","text":"<p>Executes a single instruction of the process.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step. Defaults to None.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_step)\n@change_state_function_thread\ndef step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the process.\n\n    Args:\n        thread (ThreadContext): The thread to step. Defaults to None.\n    \"\"\"\n    self._ensure_process_stopped()\n    self.__polling_thread_command_queue.put((self.__threaded_step, (thread,)))\n    self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.step_until","title":"<code>step_until(thread, position, max_steps=-1, file='hybrid')</code>","text":"<p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step. Defaults to None.</p> required <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\"</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_step_until)\n@change_state_function_thread\ndef step_until(\n    self: InternalDebugger,\n    thread: ThreadContext,\n    position: int | str,\n    max_steps: int = -1,\n    file: str = \"hybrid\",\n) -&gt; None:\n    \"\"\"Executes instructions of the process until the specified location is reached.\n\n    Args:\n        thread (ThreadContext): The thread to step. Defaults to None.\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n        (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n        the \"binary\" map file).\n    \"\"\"\n    if isinstance(position, str):\n        address = self.resolve_symbol(position, file)\n    else:\n        address = self.resolve_address(position, file)\n\n    arguments = (\n        thread,\n        address,\n        max_steps,\n    )\n\n    self.__polling_thread_command_queue.put((self.__threaded_step_until, arguments))\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.terminate","title":"<code>terminate()</code>","text":"<p>Interrupts the process, kills it and then terminates the background thread.</p> <p>The debugger object will not be usable after this method is called. This method should only be called to free up resources when the debugger object is no longer needed.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def terminate(self: InternalDebugger) -&gt; None:\n    \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n    The debugger object will not be usable after this method is called.\n    This method should only be called to free up resources when the debugger object is no longer needed.\n    \"\"\"\n    if self.instanced and self.running:\n        self.interrupt()\n\n    if self.instanced:\n        self.kill()\n\n    self.instanced = False\n\n    if self.__polling_thread is not None:\n        self.__polling_thread_command_queue.put((THREAD_TERMINATE, ()))\n        self.__polling_thread.join()\n        del self.__polling_thread\n        self.__polling_thread = None\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.wait","title":"<code>wait()</code>","text":"<p>Waits for the process to stop.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\ndef wait(self: InternalDebugger) -&gt; None:\n    \"\"\"Waits for the process to stop.\"\"\"\n    if not self.instanced:\n        raise RuntimeError(\"Process not running, cannot wait.\")\n\n    self._join_and_check_status()\n\n    if self.threads[0].dead or not self.running:\n        # Most of the time the function returns here, as there was a wait already\n        # queued by the previous command\n        return\n\n    self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_holder/","title":"libdebug.debugger.internal_debugger_holder","text":""},{"location":"from_pydoc/generated/debugger/internal_debugger_holder/#libdebug.debugger.internal_debugger_holder.InternalDebuggerHolder","title":"<code>InternalDebuggerHolder</code>  <code>dataclass</code>","text":"<p>A holder for internal debuggers.</p> Source code in <code>libdebug/debugger/internal_debugger_holder.py</code> <pre><code>@dataclass\nclass InternalDebuggerHolder:\n    \"\"\"A holder for internal debuggers.\"\"\"\n\n    internal_debuggers: WeakKeyDictionary = field(default_factory=WeakKeyDictionary)\n    global_internal_debugger = None\n    internal_debugger_lock = Lock()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/","title":"libdebug.debugger.internal_debugger_instance_manager","text":""},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.extend_internal_debugger","title":"<code>extend_internal_debugger(referrer)</code>","text":"<p>Extend the internal debugger.</p> <p>Parameters:</p> Name Type Description Default <code>referrer</code> <code>object</code> <p>the referrer object.</p> required <p>Yields:</p> Name Type Description <code>InternalDebugger</code> <code>...</code> <p>the internal debugger.</p> Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>@contextmanager\ndef extend_internal_debugger(referrer: object) -&gt; ...:\n    \"\"\"Extend the internal debugger.\n\n    Args:\n        referrer (object): the referrer object.\n\n    Yields:\n        InternalDebugger: the internal debugger.\n    \"\"\"\n    with internal_debugger_holder.internal_debugger_lock:\n        if referrer not in internal_debugger_holder.internal_debuggers:\n            raise RuntimeError(\"Referrer isn't linked to any internal debugger.\")\n\n        internal_debugger_holder.global_internal_debugger = internal_debugger_holder.internal_debuggers[referrer]\n        yield\n        internal_debugger_holder.global_internal_debugger = None\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.get_global_internal_debugger","title":"<code>get_global_internal_debugger()</code>","text":"<p>Can be used to retrieve a temporarily-global internal debugger.</p> Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>def get_global_internal_debugger() -&gt; InternalDebugger:\n    \"\"\"Can be used to retrieve a temporarily-global internal debugger.\"\"\"\n    if internal_debugger_holder.global_internal_debugger is None:\n        raise RuntimeError(\"No internal debugger available\")\n    return internal_debugger_holder.global_internal_debugger\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.link_to_internal_debugger","title":"<code>link_to_internal_debugger(reference, internal_debugger)</code>","text":"<p>Link a reference to a InternalDebugger.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>object</code> <p>the object that needs the internal debugger.</p> required <code>internal_debugger</code> <code>InternalDebugger</code> <p>the internal debugger.</p> required Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>def link_to_internal_debugger(reference: object, internal_debugger: InternalDebugger) -&gt; None:\n    \"\"\"Link a reference to a InternalDebugger.\n\n    Args:\n        reference (object): the object that needs the internal debugger.\n        internal_debugger (InternalDebugger): the internal debugger.\n    \"\"\"\n    internal_debugger_holder.internal_debuggers[reference] = internal_debugger\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.provide_internal_debugger","title":"<code>provide_internal_debugger(reference)</code>","text":"<p>Provide a internal debugger.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>object</code> <p>the object that needs the internal debugger.</p> required <p>Returns:</p> Name Type Description <code>InternalDebugger</code> <code>InternalDebugger</code> <p>the internal debugger.</p> Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>def provide_internal_debugger(reference: object) -&gt; InternalDebugger:\n    \"\"\"Provide a internal debugger.\n\n    Args:\n        reference (object): the object that needs the internal debugger.\n\n    Returns:\n        InternalDebugger: the internal debugger.\n    \"\"\"\n    if reference in internal_debugger_holder.internal_debuggers:\n        return internal_debugger_holder.internal_debuggers[reference]\n\n    if internal_debugger_holder.global_internal_debugger is None:\n        raise RuntimeError(\"No internal debugger available\")\n\n    internal_debugger_holder.internal_debuggers[reference] = internal_debugger_holder.global_internal_debugger\n    return internal_debugger_holder.global_internal_debugger\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/","title":"libdebug.interfaces.debugging_interface","text":""},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface","title":"<code>DebuggingInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The interface used by <code>_InternalDebugger</code> to communicate with the available debugging backends, such as <code>ptrace</code> or <code>gdb</code>.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>class DebuggingInterface(ABC):\n    \"\"\"The interface used by `_InternalDebugger` to communicate with the available debugging backends, such as `ptrace` or `gdb`.\"\"\"\n\n    @abstractmethod\n    def __init__(self: DebuggingInterface) -&gt; None:\n        \"\"\"Initializes the DebuggingInterface classs.\"\"\"\n\n    @abstractmethod\n    def reset(self: DebuggingInterface) -&gt; None:\n        \"\"\"Resets the state of the interface.\"\"\"\n\n    @abstractmethod\n    def run(self: DebuggingInterface) -&gt; None:\n        \"\"\"Runs the specified process.\"\"\"\n\n    @abstractmethod\n    def attach(self: DebuggingInterface, pid: int) -&gt; None:\n        \"\"\"Attaches to the specified process.\n\n        Args:\n            pid (int): the pid of the process to attach to.\n        \"\"\"\n\n    @abstractmethod\n    def detach(self: DebuggingInterface) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n\n    @abstractmethod\n    def kill(self: DebuggingInterface) -&gt; None:\n        \"\"\"Instantly terminates the process.\"\"\"\n\n    @abstractmethod\n    def cont(self: DebuggingInterface) -&gt; None:\n        \"\"\"Continues the execution of the process.\"\"\"\n\n    @abstractmethod\n    def wait(self: DebuggingInterface) -&gt; None:\n        \"\"\"Waits for the process to stop.\"\"\"\n\n    @abstractmethod\n    def migrate_to_gdb(self: DebuggingInterface) -&gt; None:\n        \"\"\"Migrates the current process to GDB.\"\"\"\n\n    @abstractmethod\n    def migrate_from_gdb(self: DebuggingInterface) -&gt; None:\n        \"\"\"Migrates the current process from GDB.\"\"\"\n\n    @abstractmethod\n    def step(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the specified thread.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n        \"\"\"\n\n    @abstractmethod\n    def step_until(self: DebuggingInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n        \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n            address (int): The address to reach.\n            max_steps (int): The maximum number of steps to execute.\n        \"\"\"\n\n    @abstractmethod\n    def finish(self: DebuggingInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            thread (ThreadContext): The thread to finish.\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n\n    def next(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\n        \"\"\"\n\n    @abstractmethod\n    def maps(self: DebuggingInterface) -&gt; list[MemoryMap]:\n        \"\"\"Returns the memory maps of the process.\"\"\"\n\n    @abstractmethod\n    def set_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Sets a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to set.\n        \"\"\"\n\n    @abstractmethod\n    def unset_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Restores the original instruction flow at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to restore.\n        \"\"\"\n\n    @abstractmethod\n    def set_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Sets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to set.\n        \"\"\"\n\n    @abstractmethod\n    def unset_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Unsets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to unset.\n        \"\"\"\n\n    @abstractmethod\n    def set_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Sets a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to set.\n        \"\"\"\n\n    @abstractmethod\n    def unset_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Unset a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to unset.\n        \"\"\"\n\n    @abstractmethod\n    def peek_memory(self: DebuggingInterface, address: int) -&gt; int:\n        \"\"\"Reads the memory at the specified address.\n\n        Args:\n            address (int): The address to read.\n\n        Returns:\n            int: The read memory value.\n        \"\"\"\n\n    @abstractmethod\n    def poke_memory(self: DebuggingInterface, address: int, data: int) -&gt; None:\n        \"\"\"Writes the memory at the specified address.\n\n        Args:\n            address (int): The address to write.\n            data (int): The value to write.\n        \"\"\"\n\n    @abstractmethod\n    def fetch_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n        \"\"\"Fetches the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to update.\n        \"\"\"\n\n    @abstractmethod\n    def flush_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n        \"\"\"Flushes the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to flush.\n        \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.__init__","title":"<code>__init__()</code>  <code>abstractmethod</code>","text":"<p>Initializes the DebuggingInterface classs.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef __init__(self: DebuggingInterface) -&gt; None:\n    \"\"\"Initializes the DebuggingInterface classs.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.attach","title":"<code>attach(pid)</code>  <code>abstractmethod</code>","text":"<p>Attaches to the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>the pid of the process to attach to.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef attach(self: DebuggingInterface, pid: int) -&gt; None:\n    \"\"\"Attaches to the specified process.\n\n    Args:\n        pid (int): the pid of the process to attach to.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.cont","title":"<code>cont()</code>  <code>abstractmethod</code>","text":"<p>Continues the execution of the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef cont(self: DebuggingInterface) -&gt; None:\n    \"\"\"Continues the execution of the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.detach","title":"<code>detach()</code>  <code>abstractmethod</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef detach(self: DebuggingInterface) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.fetch_fp_registers","title":"<code>fetch_fp_registers(registers)</code>  <code>abstractmethod</code>","text":"<p>Fetches the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to update.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef fetch_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n    \"\"\"Fetches the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to update.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.finish","title":"<code>finish(thread, heuristic)</code>  <code>abstractmethod</code>","text":"<p>Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to finish.</p> required <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef finish(self: DebuggingInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n    \"\"\"Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        thread (ThreadContext): The thread to finish.\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.flush_fp_registers","title":"<code>flush_fp_registers(registers)</code>  <code>abstractmethod</code>","text":"<p>Flushes the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to flush.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef flush_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n    \"\"\"Flushes the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to flush.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.kill","title":"<code>kill()</code>  <code>abstractmethod</code>","text":"<p>Instantly terminates the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef kill(self: DebuggingInterface) -&gt; None:\n    \"\"\"Instantly terminates the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.maps","title":"<code>maps()</code>  <code>abstractmethod</code>","text":"<p>Returns the memory maps of the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef maps(self: DebuggingInterface) -&gt; list[MemoryMap]:\n    \"\"\"Returns the memory maps of the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.migrate_from_gdb","title":"<code>migrate_from_gdb()</code>  <code>abstractmethod</code>","text":"<p>Migrates the current process from GDB.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef migrate_from_gdb(self: DebuggingInterface) -&gt; None:\n    \"\"\"Migrates the current process from GDB.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.migrate_to_gdb","title":"<code>migrate_to_gdb()</code>  <code>abstractmethod</code>","text":"<p>Migrates the current process to GDB.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef migrate_to_gdb(self: DebuggingInterface) -&gt; None:\n    \"\"\"Migrates the current process to GDB.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.next","title":"<code>next(thread)</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>def next(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.peek_memory","title":"<code>peek_memory(address)</code>  <code>abstractmethod</code>","text":"<p>Reads the memory at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The read memory value.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef peek_memory(self: DebuggingInterface, address: int) -&gt; int:\n    \"\"\"Reads the memory at the specified address.\n\n    Args:\n        address (int): The address to read.\n\n    Returns:\n        int: The read memory value.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.poke_memory","title":"<code>poke_memory(address, data)</code>  <code>abstractmethod</code>","text":"<p>Writes the memory at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write.</p> required <code>data</code> <code>int</code> <p>The value to write.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef poke_memory(self: DebuggingInterface, address: int, data: int) -&gt; None:\n    \"\"\"Writes the memory at the specified address.\n\n    Args:\n        address (int): The address to write.\n        data (int): The value to write.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Resets the state of the interface.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef reset(self: DebuggingInterface) -&gt; None:\n    \"\"\"Resets the state of the interface.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"<p>Runs the specified process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef run(self: DebuggingInterface) -&gt; None:\n    \"\"\"Runs the specified process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.set_breakpoint","title":"<code>set_breakpoint(bp)</code>  <code>abstractmethod</code>","text":"<p>Sets a breakpoint at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to set.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef set_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n    \"\"\"Sets a breakpoint at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to set.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.set_signal_catcher","title":"<code>set_signal_catcher(catcher)</code>  <code>abstractmethod</code>","text":"<p>Sets a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to set.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef set_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Sets a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to set.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.set_syscall_handler","title":"<code>set_syscall_handler(handler)</code>  <code>abstractmethod</code>","text":"<p>Sets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to set.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef set_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Sets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to set.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.step","title":"<code>step(thread)</code>  <code>abstractmethod</code>","text":"<p>Executes a single instruction of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef step(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the specified thread.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.step_until","title":"<code>step_until(thread, address, max_steps)</code>  <code>abstractmethod</code>","text":"<p>Executes instructions of the specified thread until the specified address is reached.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required <code>address</code> <code>int</code> <p>The address to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef step_until(self: DebuggingInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n    \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n        address (int): The address to reach.\n        max_steps (int): The maximum number of steps to execute.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.unset_breakpoint","title":"<code>unset_breakpoint(bp)</code>  <code>abstractmethod</code>","text":"<p>Restores the original instruction flow at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to restore.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef unset_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n    \"\"\"Restores the original instruction flow at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to restore.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.unset_signal_catcher","title":"<code>unset_signal_catcher(catcher)</code>  <code>abstractmethod</code>","text":"<p>Unset a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to unset.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef unset_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Unset a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to unset.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.unset_syscall_handler","title":"<code>unset_syscall_handler(handler)</code>  <code>abstractmethod</code>","text":"<p>Unsets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to unset.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef unset_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Unsets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to unset.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.wait","title":"<code>wait()</code>  <code>abstractmethod</code>","text":"<p>Waits for the process to stop.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef wait(self: DebuggingInterface) -&gt; None:\n    \"\"\"Waits for the process to stop.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/interface_helper/","title":"libdebug.interfaces.interface_helper","text":""},{"location":"from_pydoc/generated/interfaces/interface_helper/#libdebug.interfaces.interface_helper.provide_debugging_interface","title":"<code>provide_debugging_interface(interface=AvailableInterfaces.PTRACE)</code>","text":"<p>Returns an instance of the debugging interface to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/interfaces/interface_helper.py</code> <pre><code>def provide_debugging_interface(\n    interface: AvailableInterfaces = AvailableInterfaces.PTRACE,\n) -&gt; DebuggingInterface:\n    \"\"\"Returns an instance of the debugging interface to be used by the `_InternalDebugger` class.\"\"\"\n    match interface:\n        case AvailableInterfaces.PTRACE:\n            return PtraceInterface()\n        case _:\n            raise NotImplementedError(f\"Interface {interface} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/interfaces/","title":"libdebug.interfaces.interfaces","text":""},{"location":"from_pydoc/generated/interfaces/interfaces/#libdebug.interfaces.interfaces.AvailableInterfaces","title":"<code>AvailableInterfaces</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of the available backend interfaces.</p> Source code in <code>libdebug/interfaces/interfaces.py</code> <pre><code>class AvailableInterfaces(Enum):\n    \"\"\"An enumeration of the available backend interfaces.\"\"\"\n\n    PTRACE = 1\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/","title":"libdebug.memory.abstract_memory_view","text":""},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView","title":"<code>AbstractMemoryView</code>","text":"<p>               Bases: <code>MutableSequence</code>, <code>ABC</code></p> <p>An abstract memory interface for the target process.</p> <p>An implementation of class must be used to read and write memory of the target process.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>class AbstractMemoryView(MutableSequence, ABC):\n    \"\"\"An abstract memory interface for the target process.\n\n    An implementation of class must be used to read and write memory of the target process.\n    \"\"\"\n\n    def __init__(self: AbstractMemoryView) -&gt; None:\n        \"\"\"Initializes the MemoryView.\"\"\"\n        self._internal_debugger = provide_internal_debugger(self)\n        self.maps_provider = self._internal_debugger.debugging_interface.maps\n\n    @abstractmethod\n    def read(self: AbstractMemoryView, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n\n    @abstractmethod\n    def write(self: AbstractMemoryView, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n\n    def __getitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; bytes:\n        \"\"\"Read from memory, either a single byte or a byte string.\n\n        Args:\n            key (int | slice | str | tuple): The key to read from memory.\n        \"\"\"\n        return self._manage_memory_read_type(key)\n\n    def __setitem__(self: AbstractMemoryView, key: int | slice | str | tuple, value: bytes) -&gt; None:\n        \"\"\"Write to memory, either a single byte or a byte string.\n\n        Args:\n            key (int | slice | str | tuple): The key to write to memory.\n            value (bytes): The value to write.\n        \"\"\"\n        if not isinstance(value, bytes):\n            raise TypeError(\"Invalid type for the value to write to memory. Expected bytes.\")\n        self._manage_memory_write_type(key, value)\n\n    def _manage_memory_read_type(\n        self: AbstractMemoryView,\n        key: int | slice | str | tuple,\n        file: str = \"hybrid\",\n    ) -&gt; bytes:\n        \"\"\"Manage the read from memory, according to the typing.\n\n        Args:\n            key (int | slice | str | tuple): The key to read from memory.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        if isinstance(key, int):\n            address = self._internal_debugger.resolve_address(key, file, skip_absolute_address_validation=True)\n            try:\n                return self.read(address, 1)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n        elif isinstance(key, slice):\n            if isinstance(key.start, str):\n                start = self._internal_debugger.resolve_symbol(key.start, file)\n            else:\n                start = self._internal_debugger.resolve_address(key.start, file, skip_absolute_address_validation=True)\n\n            if isinstance(key.stop, str):\n                stop = self._internal_debugger.resolve_symbol(key.stop, file)\n            else:\n                stop = self._internal_debugger.resolve_address(key.stop, file, skip_absolute_address_validation=True)\n\n            if stop &lt; start:\n                raise ValueError(\"Invalid slice range.\")\n\n            try:\n                return self.read(start, stop - start)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n        elif isinstance(key, str):\n            address = self._internal_debugger.resolve_symbol(key, file)\n\n            return self.read(address, 1)\n        elif isinstance(key, tuple):\n            return self._manage_memory_read_tuple(key)\n        else:\n            raise TypeError(\"Invalid key type.\")\n\n    def _manage_memory_read_tuple(self: AbstractMemoryView, key: tuple) -&gt; bytes:\n        \"\"\"Manage the read from memory, when the access is through a tuple.\n\n        Args:\n            key (tuple): The key to read from memory.\n        \"\"\"\n        if len(key) == 3:\n            # It can only be a tuple of the type (address, size, file)\n            address, size, file = key\n            if not isinstance(file, str):\n                raise TypeError(\"Invalid type for the backing file. Expected string.\")\n        elif len(key) == 2:\n            left, right = key\n            if isinstance(right, str):\n                # The right element can only be the backing file\n                return self._manage_memory_read_type(left, right)\n            elif isinstance(right, int):\n                # The right element must be the size\n                address = left\n                size = right\n                file = \"hybrid\"\n        else:\n            raise TypeError(\"Tuple must have 2 or 3 elements.\")\n\n        if not isinstance(size, int):\n            raise TypeError(\"Invalid type for the size. Expected int.\")\n\n        if isinstance(address, str):\n            address = self._internal_debugger.resolve_symbol(address, file)\n        elif isinstance(address, int):\n            address = self._internal_debugger.resolve_address(address, file, skip_absolute_address_validation=True)\n        else:\n            raise TypeError(\"Invalid type for the address. Expected int or string.\")\n\n        try:\n            return self.read(address, size)\n        except OSError as e:\n            raise ValueError(\"Invalid address.\") from e\n\n    def _manage_memory_write_type(\n        self: AbstractMemoryView,\n        key: int | slice | str | tuple,\n        value: bytes,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Manage the write to memory, according to the typing.\n\n        Args:\n            key (int | slice | str | tuple): The key to read from memory.\n            value (bytes): The value to write.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        if isinstance(key, int):\n            address = self._internal_debugger.resolve_address(key, file, skip_absolute_address_validation=True)\n            try:\n                self.write(address, value)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n        elif isinstance(key, slice):\n            if isinstance(key.start, str):\n                start = self._internal_debugger.resolve_symbol(key.start, file)\n            else:\n                start = self._internal_debugger.resolve_address(key.start, file, skip_absolute_address_validation=True)\n\n            if key.stop is not None:\n                if isinstance(key.stop, str):\n                    stop = self._internal_debugger.resolve_symbol(key.stop, file)\n                else:\n                    stop = self._internal_debugger.resolve_address(\n                        key.stop,\n                        file,\n                        skip_absolute_address_validation=True,\n                    )\n\n                if stop &lt; start:\n                    raise ValueError(\"Invalid slice range\")\n\n                if len(value) != stop - start:\n                    liblog.warning(f\"Mismatch between slice width and value size, writing {len(value)} bytes.\")\n\n            try:\n                self.write(start, value)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n\n        elif isinstance(key, str):\n            address = self._internal_debugger.resolve_symbol(key, file)\n\n            self.write(address, value)\n        elif isinstance(key, tuple):\n            self._manage_memory_write_tuple(key, value)\n        else:\n            raise TypeError(\"Invalid key type.\")\n\n    def _manage_memory_write_tuple(self: AbstractMemoryView, key: tuple, value: bytes) -&gt; None:\n        \"\"\"Manage the write to memory, when the access is through a tuple.\n\n        Args:\n            key (tuple): The key to read from memory.\n            value (bytes): The value to write.\n        \"\"\"\n        if len(key) == 3:\n            # It can only be a tuple of the type (address, size, file)\n            address, size, file = key\n            if not isinstance(file, str):\n                raise TypeError(\"Invalid type for the backing file. Expected string.\")\n        elif len(key) == 2:\n            left, right = key\n            if isinstance(right, str):\n                # The right element can only be the backing file\n                self._manage_memory_write_type(left, value, right)\n                return\n            elif isinstance(right, int):\n                # The right element must be the size\n                address = left\n                size = right\n                file = \"hybrid\"\n        else:\n            raise TypeError(\"Tuple must have 2 or 3 elements.\")\n\n        if not isinstance(size, int):\n            raise TypeError(\"Invalid type for the size. Expected int.\")\n\n        if isinstance(address, str):\n            address = self._internal_debugger.resolve_symbol(address, file)\n        elif isinstance(address, int):\n            address = self._internal_debugger.resolve_address(address, file, skip_absolute_address_validation=True)\n        else:\n            raise TypeError(\"Invalid type for the address. Expected int or string.\")\n\n        if len(value) != size:\n            liblog.warning(f\"Mismatch between specified size and actual value size, writing {len(value)} bytes.\")\n\n        try:\n            self.write(address, value)\n        except OSError as e:\n            raise ValueError(\"Invalid address.\") from e\n\n    def __delitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; None:\n        \"\"\"MemoryView doesn't support deletion.\"\"\"\n        raise NotImplementedError(\"MemoryView doesn't support deletion\")\n\n    def __len__(self: AbstractMemoryView) -&gt; None:\n        \"\"\"MemoryView doesn't support length.\"\"\"\n        raise NotImplementedError(\"MemoryView doesn't support length\")\n\n    def insert(self: AbstractMemoryView, index: int, value: int) -&gt; None:\n        \"\"\"MemoryView doesn't support insertion.\"\"\"\n        raise NotImplementedError(\"MemoryView doesn't support insertion\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>MemoryView doesn't support deletion.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __delitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; None:\n    \"\"\"MemoryView doesn't support deletion.\"\"\"\n    raise NotImplementedError(\"MemoryView doesn't support deletion\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Read from memory, either a single byte or a byte string.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice | str | tuple</code> <p>The key to read from memory.</p> required Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __getitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; bytes:\n    \"\"\"Read from memory, either a single byte or a byte string.\n\n    Args:\n        key (int | slice | str | tuple): The key to read from memory.\n    \"\"\"\n    return self._manage_memory_read_type(key)\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the MemoryView.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __init__(self: AbstractMemoryView) -&gt; None:\n    \"\"\"Initializes the MemoryView.\"\"\"\n    self._internal_debugger = provide_internal_debugger(self)\n    self.maps_provider = self._internal_debugger.debugging_interface.maps\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__len__","title":"<code>__len__()</code>","text":"<p>MemoryView doesn't support length.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __len__(self: AbstractMemoryView) -&gt; None:\n    \"\"\"MemoryView doesn't support length.\"\"\"\n    raise NotImplementedError(\"MemoryView doesn't support length\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Write to memory, either a single byte or a byte string.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice | str | tuple</code> <p>The key to write to memory.</p> required <code>value</code> <code>bytes</code> <p>The value to write.</p> required Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __setitem__(self: AbstractMemoryView, key: int | slice | str | tuple, value: bytes) -&gt; None:\n    \"\"\"Write to memory, either a single byte or a byte string.\n\n    Args:\n        key (int | slice | str | tuple): The key to write to memory.\n        value (bytes): The value to write.\n    \"\"\"\n    if not isinstance(value, bytes):\n        raise TypeError(\"Invalid type for the value to write to memory. Expected bytes.\")\n    self._manage_memory_write_type(key, value)\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.insert","title":"<code>insert(index, value)</code>","text":"<p>MemoryView doesn't support insertion.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def insert(self: AbstractMemoryView, index: int, value: int) -&gt; None:\n    \"\"\"MemoryView doesn't support insertion.\"\"\"\n    raise NotImplementedError(\"MemoryView doesn't support insertion\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.read","title":"<code>read(address, size)</code>  <code>abstractmethod</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>@abstractmethod\ndef read(self: AbstractMemoryView, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.write","title":"<code>write(address, data)</code>  <code>abstractmethod</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>@abstractmethod\ndef write(self: AbstractMemoryView, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/","title":"libdebug.memory.chunked_memory_view","text":""},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView","title":"<code>ChunkedMemoryView</code>","text":"<p>               Bases: <code>AbstractMemoryView</code></p> <p>A memory interface for the target process, intended for chunk-based memory access.</p> <p>Attributes:</p> Name Type Description <code>getter</code> <code>Callable[[int], bytes]</code> <p>A function that reads a chunk of memory from the target process.</p> <code>setter</code> <code>Callable[[int, bytes], None]</code> <p>A function that writes a chunk of memory to the target process.</p> <code>unit_size</code> <code>int</code> <p>The chunk size used by the getter and setter functions. Defaults to 8.</p> <code>align_to</code> <code>int</code> <p>The address alignment that must be used when reading and writing memory. Defaults to 1.</p> Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>class ChunkedMemoryView(AbstractMemoryView):\n    \"\"\"A memory interface for the target process, intended for chunk-based memory access.\n\n    Attributes:\n            getter (Callable[[int], bytes]): A function that reads a chunk of memory from the target process.\n            setter (Callable[[int, bytes], None]): A function that writes a chunk of memory to the target process.\n            unit_size (int, optional): The chunk size used by the getter and setter functions. Defaults to 8.\n            align_to (int, optional): The address alignment that must be used when reading and writing memory. Defaults to 1.\n    \"\"\"\n\n    def __init__(\n        self: ChunkedMemoryView,\n        getter: Callable[[int], bytes],\n        setter: Callable[[int, bytes], None],\n        unit_size: int = 8,\n        align_to: int = 1,\n    ) -&gt; None:\n        \"\"\"Initializes the MemoryView.\"\"\"\n        super().__init__()\n        self.getter = getter\n        self.setter = setter\n        self.unit_size = unit_size\n        self.align_to = align_to\n\n    def read(self: ChunkedMemoryView, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n        if self.align_to == 1:\n            data = b\"\"\n\n            remainder = size % self.unit_size\n\n            for i in range(address, address + size - remainder, self.unit_size):\n                data += self.getter(i)\n\n            if remainder:\n                data += self.getter(address + size - remainder)[:remainder]\n\n            return data\n        else:\n            prefix = address % self.align_to\n            prefix_size = self.unit_size - prefix\n\n            data = self.getter(address - prefix)[prefix:]\n\n            remainder = (size - prefix_size) % self.unit_size\n\n            for i in range(\n                address + prefix_size,\n                address + size - remainder,\n                self.unit_size,\n            ):\n                data += self.getter(i)\n\n            if remainder:\n                data += self.getter(address + size - remainder)[:remainder]\n\n            return data\n\n    def write(self: ChunkedMemoryView, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n        size = len(data)\n\n        if self.align_to == 1:\n            remainder = size % self.unit_size\n            base = address\n        else:\n            prefix = address % self.align_to\n            prefix_size = self.unit_size - prefix\n\n            prev_data = self.getter(address - prefix)\n\n            self.setter(address - prefix, prev_data[:prefix_size] + data[:prefix])\n\n            remainder = (size - prefix_size) % self.unit_size\n            base = address + prefix_size\n\n        for i in range(base, address + size - remainder, self.unit_size):\n            self.setter(i, data[i - address : i - address + self.unit_size])\n\n        if remainder:\n            prev_data = self.getter(address + size - remainder)\n            self.setter(\n                address + size - remainder,\n                data[size - remainder :] + prev_data[remainder:],\n            )\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView.__init__","title":"<code>__init__(getter, setter, unit_size=8, align_to=1)</code>","text":"<p>Initializes the MemoryView.</p> Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>def __init__(\n    self: ChunkedMemoryView,\n    getter: Callable[[int], bytes],\n    setter: Callable[[int, bytes], None],\n    unit_size: int = 8,\n    align_to: int = 1,\n) -&gt; None:\n    \"\"\"Initializes the MemoryView.\"\"\"\n    super().__init__()\n    self.getter = getter\n    self.setter = setter\n    self.unit_size = unit_size\n    self.align_to = align_to\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView.read","title":"<code>read(address, size)</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>def read(self: ChunkedMemoryView, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n    if self.align_to == 1:\n        data = b\"\"\n\n        remainder = size % self.unit_size\n\n        for i in range(address, address + size - remainder, self.unit_size):\n            data += self.getter(i)\n\n        if remainder:\n            data += self.getter(address + size - remainder)[:remainder]\n\n        return data\n    else:\n        prefix = address % self.align_to\n        prefix_size = self.unit_size - prefix\n\n        data = self.getter(address - prefix)[prefix:]\n\n        remainder = (size - prefix_size) % self.unit_size\n\n        for i in range(\n            address + prefix_size,\n            address + size - remainder,\n            self.unit_size,\n        ):\n            data += self.getter(i)\n\n        if remainder:\n            data += self.getter(address + size - remainder)[:remainder]\n\n        return data\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView.write","title":"<code>write(address, data)</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>def write(self: ChunkedMemoryView, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n    size = len(data)\n\n    if self.align_to == 1:\n        remainder = size % self.unit_size\n        base = address\n    else:\n        prefix = address % self.align_to\n        prefix_size = self.unit_size - prefix\n\n        prev_data = self.getter(address - prefix)\n\n        self.setter(address - prefix, prev_data[:prefix_size] + data[:prefix])\n\n        remainder = (size - prefix_size) % self.unit_size\n        base = address + prefix_size\n\n    for i in range(base, address + size - remainder, self.unit_size):\n        self.setter(i, data[i - address : i - address + self.unit_size])\n\n    if remainder:\n        prev_data = self.getter(address + size - remainder)\n        self.setter(\n            address + size - remainder,\n            data[size - remainder :] + prev_data[remainder:],\n        )\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/","title":"libdebug.memory.direct_memory_view","text":""},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView","title":"<code>DirectMemoryView</code>","text":"<p>               Bases: <code>AbstractMemoryView</code></p> <p>A memory interface for the target process, intended for direct memory access.</p> <p>Attributes:</p> Name Type Description <code>getter</code> <code>Callable[[int, int], bytes]</code> <p>A function that reads a variable amount of data from the target's memory.</p> <code>setter</code> <code>Callable[[int, bytes], None]</code> <p>A function that writes memory to the target process.</p> <code>align_to</code> <code>int</code> <p>The address alignment that must be used when reading and writing memory. Defaults to 1.</p> Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>class DirectMemoryView(AbstractMemoryView):\n    \"\"\"A memory interface for the target process, intended for direct memory access.\n\n    Attributes:\n            getter (Callable[[int, int], bytes]): A function that reads a variable amount of data from the target's memory.\n            setter (Callable[[int, bytes], None]): A function that writes memory to the target process.\n            align_to (int, optional): The address alignment that must be used when reading and writing memory. Defaults to 1.\n    \"\"\"\n\n    def __init__(\n        self: DirectMemoryView,\n        getter: Callable[[int, int], bytes],\n        setter: Callable[[int, bytes], None],\n        align_to: int = 1,\n    ) -&gt; None:\n        \"\"\"Initializes the MemoryView.\"\"\"\n        super().__init__()\n        self.getter = getter\n        self.setter = setter\n        self.align_to = align_to\n\n    def read(self: DirectMemoryView, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n        if self.align_to == 1:\n            return self.getter(address, size)\n        else:\n            prefix = address % self.align_to\n            base_address = address - prefix\n            new_size = size + prefix\n            data = self.getter(base_address, new_size)\n            return data[prefix : prefix + size]\n\n    def write(self: DirectMemoryView, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n        size = len(data)\n\n        if self.align_to == 1:\n            self.setter(address, data)\n        else:\n            prefix = address % self.align_to\n            base_address = address - prefix\n            new_size = size + prefix\n            prefix_data = self.getter(base_address, new_size)\n            new_data = prefix_data[:prefix] + data + prefix_data[prefix + size :]\n            self.setter(base_address, new_data)\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView.__init__","title":"<code>__init__(getter, setter, align_to=1)</code>","text":"<p>Initializes the MemoryView.</p> Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>def __init__(\n    self: DirectMemoryView,\n    getter: Callable[[int, int], bytes],\n    setter: Callable[[int, bytes], None],\n    align_to: int = 1,\n) -&gt; None:\n    \"\"\"Initializes the MemoryView.\"\"\"\n    super().__init__()\n    self.getter = getter\n    self.setter = setter\n    self.align_to = align_to\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView.read","title":"<code>read(address, size)</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>def read(self: DirectMemoryView, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n    if self.align_to == 1:\n        return self.getter(address, size)\n    else:\n        prefix = address % self.align_to\n        base_address = address - prefix\n        new_size = size + prefix\n        data = self.getter(base_address, new_size)\n        return data[prefix : prefix + size]\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView.write","title":"<code>write(address, data)</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>def write(self: DirectMemoryView, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n    size = len(data)\n\n    if self.align_to == 1:\n        self.setter(address, data)\n    else:\n        prefix = address % self.align_to\n        base_address = address - prefix\n        new_size = size + prefix\n        prefix_data = self.getter(base_address, new_size)\n        new_data = prefix_data[:prefix] + data + prefix_data[prefix + size :]\n        self.setter(base_address, new_data)\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/","title":"libdebug.memory.process_memory_manager","text":""},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager","title":"<code>ProcessMemoryManager</code>","text":"<p>A class that provides accessors to the memory of a process, through /proc/pid/mem.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>class ProcessMemoryManager:\n    \"\"\"A class that provides accessors to the memory of a process, through /proc/pid/mem.\"\"\"\n\n    def open(self: ProcessMemoryManager, process_id: int) -&gt; None:\n        \"\"\"Initializes the ProcessMemoryManager.\"\"\"\n        self.process_id = process_id\n        self._mem_file = None\n\n    def _open(self: ProcessMemoryManager) -&gt; None:\n        self._mem_file = open(f\"/proc/{self.process_id}/mem\", \"r+b\", buffering=0)\n\n    def read(self: ProcessMemoryManager, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n        if not self._mem_file:\n            self._open()\n\n        self._mem_file.seek(address)\n        return self._mem_file.read(size)\n\n    def write(self: ProcessMemoryManager, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n        if not self._mem_file:\n            self._open()\n\n        self._mem_file.seek(address)\n        self._mem_file.write(data)\n\n    def close(self: ProcessMemoryManager) -&gt; None:\n        \"\"\"Closes the memory file.\"\"\"\n        if self._mem_file:\n            self._mem_file.close()\n            self._mem_file = None\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.close","title":"<code>close()</code>","text":"<p>Closes the memory file.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def close(self: ProcessMemoryManager) -&gt; None:\n    \"\"\"Closes the memory file.\"\"\"\n    if self._mem_file:\n        self._mem_file.close()\n        self._mem_file = None\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.open","title":"<code>open(process_id)</code>","text":"<p>Initializes the ProcessMemoryManager.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def open(self: ProcessMemoryManager, process_id: int) -&gt; None:\n    \"\"\"Initializes the ProcessMemoryManager.\"\"\"\n    self.process_id = process_id\n    self._mem_file = None\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.read","title":"<code>read(address, size)</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def read(self: ProcessMemoryManager, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n    if not self._mem_file:\n        self._open()\n\n    self._mem_file.seek(address)\n    return self._mem_file.read(size)\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.write","title":"<code>write(address, data)</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def write(self: ProcessMemoryManager, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n    if not self._mem_file:\n        self._open()\n\n    self._mem_file.seek(address)\n    self._mem_file.write(data)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_constants/","title":"libdebug.ptrace.ptrace_constants","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_constants/#libdebug.ptrace.ptrace_constants.Commands","title":"<code>Commands</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration of the available ptrace commands.</p> Source code in <code>libdebug/ptrace/ptrace_constants.py</code> <pre><code>class Commands(IntEnum):\n    \"\"\"An enumeration of the available ptrace commands.\"\"\"\n\n    PTRACE_TRACEME = 0\n    PTRACE_PEEKTEXT = 1\n    PTRACE_PEEKDATA = 2\n    PTRACE_PEEKUSER = 3\n    PTRACE_POKETEXT = 4\n    PTRACE_POKEDATA = 5\n    PTRACE_POKEUSER = 6\n    PTRACE_CONT = 7\n    PTRACE_KILL = 8\n    PTRACE_SINGLESTEP = 9\n    PTRACE_GETREGS = 12\n    PTRACE_SETREGS = 13\n    PTRACE_GETFPREGS = 14\n    PTRACE_SETFPREGS = 15\n    PTRACE_ATTACH = 16\n    PTRACE_DETACH = 17\n    PTRACE_GETFPXREGS = 18\n    PTRACE_SETFPXREGS = 19\n    PTRACE_SYSCALL = 24\n    PTRACE_SETOPTIONS = 0x4200\n    PTRACE_GETEVENTMSG = 0x4201\n    PTRACE_GETSIGINFO = 0x4202\n    PTRACE_SETSIGINFO = 0x4203\n    PTRACE_GETREGSET = 0x4204\n    PTRACE_SETREGSET = 0x4205\n    PTRACE_SEIZE = 0x4206\n    PTRACE_INTERRUPT = 0x4207\n    PTRACE_LISTEN = 0x4208\n    PTRACE_PEEKSIGINFO = 0x4209\n    PTRACE_GETSIGMASK = 0x420A\n    PTRACE_SETSIGMASK = 0x420B\n    PTRACE_SECCOMP_GET_FILTER = 0x420C\n    PTRACE_SECCOMP_GET_METADATA = 0x420D\n    PTRACE_GET_SYSCALL_INFO = 0x420E\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_constants/#libdebug.ptrace.ptrace_constants.StopEvents","title":"<code>StopEvents</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration of the stop events that ptrace can return.</p> Source code in <code>libdebug/ptrace/ptrace_constants.py</code> <pre><code>class StopEvents(IntEnum):\n    \"\"\"An enumeration of the stop events that ptrace can return.\"\"\"\n\n    CLONE_EVENT = SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; 8)\n    EXEC_EVENT = SIGTRAP | (PTRACE_EVENT_EXEC &lt;&lt; 8)\n    EXIT_EVENT = SIGTRAP | (PTRACE_EVENT_EXIT &lt;&lt; 8)\n    FORK_EVENT = SIGTRAP | (PTRACE_EVENT_FORK &lt;&lt; 8)\n    VFORK_EVENT = SIGTRAP | (PTRACE_EVENT_VFORK &lt;&lt; 8)\n    VFORK_DONE_EVENT = SIGTRAP | (PTRACE_EVENT_VFORK_DONE &lt;&lt; 8)\n    SECCOMP_EVENT = SIGTRAP | (PTRACE_EVENT_SECCOMP &lt;&lt; 8)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/","title":"libdebug.ptrace.ptrace_interface","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface","title":"<code>PtraceInterface</code>","text":"<p>               Bases: <code>DebuggingInterface</code></p> <p>The interface used by <code>_InternalDebugger</code> to communicate with the <code>ptrace</code> debugging backend.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>class PtraceInterface(DebuggingInterface):\n    \"\"\"The interface used by `_InternalDebugger` to communicate with the `ptrace` debugging backend.\"\"\"\n\n    process_id: int | None\n    \"\"\"The process ID of the debugged process.\"\"\"\n\n    detached: bool\n    \"\"\"Whether the process was detached or not.\"\"\"\n\n    _internal_debugger: InternalDebugger\n    \"\"\"The internal debugger instance.\"\"\"\n\n    def __init__(self: PtraceInterface) -&gt; None:\n        super().__init__()\n\n        self.lib_trace = _ptrace_cffi.lib\n        self.ffi = _ptrace_cffi.ffi\n\n        self._internal_debugger = provide_internal_debugger(self)\n\n        self._global_state = self.ffi.new(\"struct global_state*\")\n        self._global_state.t_HEAD = self.ffi.NULL\n        self._global_state.dead_t_HEAD = self.ffi.NULL\n        self._global_state.sw_b_HEAD = self.ffi.NULL\n        self._global_state.hw_b_HEAD = self.ffi.NULL\n\n        self.process_id = 0\n        self.detached = False\n\n        self._disabled_aslr = False\n\n        self.reset()\n\n    def reset(self: PtraceInterface) -&gt; None:\n        \"\"\"Resets the state of the interface.\"\"\"\n        self.lib_trace.free_thread_list(self._global_state)\n        self.lib_trace.free_breakpoints(self._global_state)\n\n    def _set_options(self: PtraceInterface) -&gt; None:\n        \"\"\"Sets the tracer options.\"\"\"\n        self.lib_trace.ptrace_set_options(self.process_id)\n\n    def run(self: PtraceInterface) -&gt; None:\n        \"\"\"Runs the specified process.\"\"\"\n        if not self._disabled_aslr and not self._internal_debugger.aslr_enabled:\n            disable_self_aslr()\n            self._disabled_aslr = True\n\n        argv = self._internal_debugger.argv\n        env = self._internal_debugger.env\n\n        liblog.debugger(\"Running %s\", argv)\n\n        # Setup ptrace wait status handler after debugging_context has been properly initialized\n        with extend_internal_debugger(self):\n            self.status_handler = PtraceStatusHandler()\n\n        # Creating pipes for stdin, stdout, stderr\n        self.stdin_read, self.stdin_write = os.pipe()\n        self.stdout_read, self.stdout_write = pty.openpty()\n        self.stderr_read, self.stderr_write = pty.openpty()\n\n        # Setting stdout, stderr to raw mode to avoid terminal control codes interfering with the\n        # output\n        tty.setraw(self.stdout_read)\n        tty.setraw(self.stderr_read)\n\n        # argv[1] is the length of the custom environment variables\n        # argv[2:2 + env_len] is the custom environment variables\n        # argv[2 + env_len] should be NULL\n        # argv[2 + env_len + 1:] is the new argv\n        if env is None:\n            env_len = -1\n            env = {}\n        else:\n            env_len = len(env)\n\n        argv = [\n            JUMPSTART_LOCATION,\n            str(env_len),\n            *[f\"{key}={value}\" for key, value in env.items()],\n            \"NULL\",\n            *argv,\n        ]\n\n        child_pid = posix_spawn(\n            JUMPSTART_LOCATION,\n            argv,\n            os.environ,\n            file_actions=[\n                (POSIX_SPAWN_CLOSE, self.stdin_write),\n                (POSIX_SPAWN_CLOSE, self.stdout_read),\n                (POSIX_SPAWN_CLOSE, self.stderr_read),\n                (POSIX_SPAWN_DUP2, self.stdin_read, 0),\n                (POSIX_SPAWN_DUP2, self.stdout_write, 1),\n                (POSIX_SPAWN_DUP2, self.stderr_write, 2),\n                (POSIX_SPAWN_CLOSE, self.stdin_read),\n                (POSIX_SPAWN_CLOSE, self.stdout_write),\n                (POSIX_SPAWN_CLOSE, self.stderr_write),\n            ],\n            setpgroup=0,\n        )\n\n        self.process_id = child_pid\n        self.detached = False\n        self._internal_debugger.process_id = child_pid\n        self.register_new_thread(child_pid)\n        continue_to_entry_point = self._internal_debugger.autoreach_entrypoint\n        self._setup_parent(continue_to_entry_point)\n        self._internal_debugger.pipe_manager = self._setup_pipe()\n\n    def attach(self: PtraceInterface, pid: int) -&gt; None:\n        \"\"\"Attaches to the specified process.\n\n        Args:\n            pid (int): the pid of the process to attach to.\n        \"\"\"\n        # Setup ptrace wait status handler after debugging_context has been properly initialized\n        with extend_internal_debugger(self):\n            self.status_handler = PtraceStatusHandler()\n\n        res = self.lib_trace.ptrace_attach(pid)\n        if res == -1:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n        self.process_id = pid\n        self.detached = False\n        self._internal_debugger.process_id = pid\n        self.register_new_thread(pid)\n        # If we are attaching to a process, we don't want to continue to the entry point\n        # which we have probably already passed\n        self._setup_parent(False)\n\n    def detach(self: PtraceInterface) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n        # We must disable all breakpoints before detaching\n        for bp in list(self._internal_debugger.breakpoints.values()):\n            if bp.enabled:\n                self.unset_breakpoint(bp, delete=True)\n\n        self.lib_trace.ptrace_detach_and_cont(self._global_state, self.process_id)\n\n        self.detached = True\n\n    def kill(self: PtraceInterface) -&gt; None:\n        \"\"\"Instantly terminates the process.\"\"\"\n        if not self.detached:\n            self.lib_trace.ptrace_detach_for_kill(self._global_state, self.process_id)\n        else:\n            # If we detached from the process, there's no reason to attempt to detach again\n            # We can just kill the process\n            os.kill(self.process_id, 9)\n            os.waitpid(self.process_id, 0)\n\n    def cont(self: PtraceInterface) -&gt; None:\n        \"\"\"Continues the execution of the process.\"\"\"\n        # Forward signals to the threads\n        if self._internal_debugger.resume_context.threads_with_signals_to_forward:\n            self.forward_signal()\n\n        # Enable all breakpoints if they were disabled for a single step\n        changed = []\n\n        for bp in self._internal_debugger.breakpoints.values():\n            bp._disabled_for_step = False\n            if bp._changed:\n                changed.append(bp)\n                bp._changed = False\n\n        for bp in changed:\n            if bp.enabled:\n                self.set_breakpoint(bp, insert=False)\n            else:\n                self.unset_breakpoint(bp, delete=False)\n\n        for handler in self._internal_debugger.handled_syscalls.values():\n            if handler.enabled or handler.on_enter_pprint or handler.on_exit_pprint:\n                self._global_state.handle_syscall_enabled = True\n                break\n        else:\n            self._global_state.handle_syscall_enabled = False\n\n        result = self.lib_trace.cont_all_and_set_bps(\n            self._global_state,\n            self.process_id,\n        )\n\n        if result &lt; 0:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n    def step(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n        \"\"\"\n        # Disable all breakpoints for the single step\n        for bp in self._internal_debugger.breakpoints.values():\n            bp._disabled_for_step = True\n\n        result = self.lib_trace.singlestep(self._global_state, thread.thread_id)\n        if result == -1:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n        self._internal_debugger.resume_context.is_a_step = True\n\n    def step_until(self: PtraceInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n        \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n            address (int): The address to reach.\n            max_steps (int): The maximum number of steps to execute.\n        \"\"\"\n        # Disable all breakpoints for the single step\n        for bp in self._internal_debugger.breakpoints.values():\n            bp._disabled_for_step = True\n\n        result = self.lib_trace.step_until(\n            self._global_state,\n            thread.thread_id,\n            address,\n            max_steps,\n        )\n        if result == -1:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n        # As the wait is done internally, we must invalidate the cache\n        invalidate_process_cache()\n\n    def finish(self: PtraceInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n        \"\"\"Continues execution until the current function returns.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n            heuristic (str): The heuristic to use.\n        \"\"\"\n        if heuristic == \"step-mode\":\n            result = self.lib_trace.stepping_finish(\n                self._global_state,\n                thread.thread_id,\n            )\n\n            if result == -1:\n                errno_val = self.ffi.errno\n                raise OSError(errno_val, errno.errorcode[errno_val])\n\n            # As the wait is done internally, we must invalidate the cache\n            invalidate_process_cache()\n        elif heuristic == \"backtrace\":\n            # Breakpoint to return address\n            last_saved_instruction_pointer = thread.saved_ip\n\n            # If a breakpoint already exists at the return address, we don't need to set a new one\n            found = False\n            ip_breakpoint = None\n\n            for bp in self._internal_debugger.breakpoints.values():\n                if bp.address == last_saved_instruction_pointer:\n                    found = True\n                    ip_breakpoint = bp\n                    break\n\n            # If we find an existing breakpoint that is disabled, we enable it\n            # but we need to disable it back after the command\n            should_disable = False\n\n            if not found:\n                # Check if we have enough hardware breakpoints available\n                # Otherwise we use a software breakpoint\n                install_hw_bp = (\n                    self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n                )\n\n                ip_breakpoint = Breakpoint(last_saved_instruction_pointer, hardware=install_hw_bp)\n                self.set_breakpoint(ip_breakpoint)\n            elif not ip_breakpoint.enabled:\n                self._enable_breakpoint(ip_breakpoint)\n                should_disable = True\n\n            self.cont()\n            self.wait()\n\n            # Remove the breakpoint if it was set by us\n            if not found:\n                self.unset_breakpoint(ip_breakpoint)\n            # Disable the breakpoint if it was just enabled by us\n            elif should_disable:\n                self._disable_breakpoint(ip_breakpoint)\n        else:\n            raise ValueError(f\"Unimplemented heuristic {heuristic}\")\n\n    def next(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n\n        opcode_window = thread.memory.read(thread.instruction_pointer, 8)\n\n        # Check if the current instruction is a call and its skip amount\n        is_call, skip = call_utilities_provider(self._internal_debugger.arch).get_call_and_skip_amount(opcode_window)\n\n        if is_call:\n            skip_address = thread.instruction_pointer + skip\n\n            # If a breakpoint already exists at the return address, we don't need to set a new one\n            found = False\n            ip_breakpoint = self._internal_debugger.breakpoints.get(skip_address)\n\n            if ip_breakpoint is not None:\n                found = True\n\n            # If we find an existing breakpoint that is disabled, we enable it\n            # but we need to disable it back after the command\n            should_disable = False\n\n            if not found:\n                # Check if we have enough hardware breakpoints available\n                # Otherwise we use a software breakpoint\n                install_hw_bp = (\n                    self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n                )\n                ip_breakpoint = Breakpoint(skip_address, hardware=install_hw_bp)\n                self.set_breakpoint(ip_breakpoint)\n            elif not ip_breakpoint.enabled:\n                self._enable_breakpoint(ip_breakpoint)\n                should_disable = True\n\n            self.cont()\n            self.wait()\n\n            # Remove the breakpoint if it was set by us\n            if not found:\n                self.unset_breakpoint(ip_breakpoint)\n            # Disable the breakpoint if it was just enabled by us\n            elif should_disable:\n                self._disable_breakpoint(ip_breakpoint)\n        else:\n            # Step forward\n            self.step(thread)\n            self.wait()\n\n    def _setup_pipe(self: PtraceInterface) -&gt; None:\n        \"\"\"Sets up the pipe manager for the child process.\n\n        Close the read end for stdin and the write ends for stdout and stderr\n        in the parent process since we are going to write to stdin and read from\n        stdout and stderr\n        \"\"\"\n        try:\n            os.close(self.stdin_read)\n            os.close(self.stdout_write)\n            os.close(self.stderr_write)\n        except Exception as e:\n            # TODO: custom exception\n            raise Exception(\"Closing fds failed: %r\", e) from e\n        return PipeManager(self.stdin_write, self.stdout_read, self.stderr_read)\n\n    def _setup_parent(self: PtraceInterface, continue_to_entry_point: bool) -&gt; None:\n        \"\"\"Sets up the parent process after the child process has been created or attached to.\"\"\"\n        liblog.debugger(\"Polling child process status\")\n        self._internal_debugger.resume_context.is_startup = True\n        self.wait()\n        self._internal_debugger.resume_context.is_startup = False\n        liblog.debugger(\"Child process ready, setting options\")\n        self._set_options()\n        liblog.debugger(\"Options set\")\n\n        if continue_to_entry_point:\n            # Now that the process is running, we must continue until we have reached the entry point\n            entry_point = get_entry_point(self._internal_debugger.argv[0])\n\n            # For PIE binaries, the entry point is a relative address\n            entry_point = normalize_and_validate_address(entry_point, self.maps())\n\n            bp = Breakpoint(entry_point, hardware=True)\n            self.set_breakpoint(bp)\n            self.cont()\n            self.wait()\n\n            self.unset_breakpoint(bp)\n\n        invalidate_process_cache()\n\n    def wait(self: PtraceInterface) -&gt; None:\n        \"\"\"Waits for the process to stop. Returns True if the wait has to be repeated.\"\"\"\n        result = self.lib_trace.wait_all_and_update_regs(\n            self._global_state,\n            self.process_id,\n        )\n\n        cursor = result\n\n        invalidate_process_cache()\n\n        results = []\n\n        while cursor != self.ffi.NULL:\n            results.append((cursor.tid, cursor.status))\n            cursor = cursor.next\n\n        # Check the result of the waitpid and handle the changes.\n        self.status_handler.manage_change(results)\n\n        self.lib_trace.free_thread_status_list(result)\n\n    def forward_signal(self: PtraceInterface) -&gt; None:\n        \"\"\"Set the signals to forward to the threads.\"\"\"\n        # change the global_state\n        cursor = self._global_state.t_HEAD\n        threads = self._internal_debugger.resume_context.threads_with_signals_to_forward\n\n        while cursor != self.ffi.NULL:\n            if cursor.tid in threads:\n                thread = self._internal_debugger.get_thread_by_id(cursor.tid)\n                if thread is None:\n                    # The thread is dead in the meantime\n                    continue\n                if thread._signal_number != 0 and thread._signal_number not in self._internal_debugger.signals_to_block:\n                    liblog.debugger(\n                        f\"Forwarding signal {thread._signal_number} to thread {cursor.tid}\",\n                    )\n                    # Set the signal to forward\n                    cursor.signal_to_forward = thread._signal_number\n                    # Reset the signal to forward\n                    thread._signal_number = 0\n            cursor = cursor.next\n\n        # Clear the list of threads with signals to forward\n        self._internal_debugger.resume_context.threads_with_signals_to_forward.clear()\n\n    def migrate_to_gdb(self: PtraceInterface) -&gt; None:\n        \"\"\"Migrates the current process to GDB.\"\"\"\n        # Delete any hardware breakpoint\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.hardware:\n                for thread in self._internal_debugger.threads:\n                    self.lib_trace.unregister_hw_breakpoint(\n                        self._global_state,\n                        thread.thread_id,\n                        bp.address,\n                    )\n\n        self.lib_trace.ptrace_detach_for_migration(self._global_state, self.process_id)\n\n    def migrate_from_gdb(self: PtraceInterface) -&gt; None:\n        \"\"\"Migrates the current process from GDB.\"\"\"\n        self.lib_trace.ptrace_reattach_from_gdb(self._global_state, self.process_id)\n\n        invalidate_process_cache()\n        self.status_handler.check_for_new_threads(self.process_id)\n\n        # We have to reinstall any hardware breakpoint\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.hardware:\n                for thread in self._internal_debugger.threads:\n                    self.lib_trace.register_hw_breakpoint(\n                        self._global_state,\n                        thread.thread_id,\n                        bp.address,\n                        bp.condition.encode().ljust(2, b\"\\x00\"),\n                        chr(bp.length).encode(),\n                    )\n\n    def register_new_thread(self: PtraceInterface, new_thread_id: int) -&gt; None:\n        \"\"\"Registers a new thread.\n\n        Args:\n            new_thread_id (int): The new thread ID.\n        \"\"\"\n        # The FFI implementation returns a pointer to the register file\n        register_file = self.lib_trace.register_thread(\n            self._global_state,\n            new_thread_id,\n        )\n\n        fp_register_file = self.lib_trace.get_thread_fp_regs(self._global_state, new_thread_id)\n\n        register_holder = register_holder_provider(self._internal_debugger.arch, register_file, fp_register_file)\n\n        with extend_internal_debugger(self._internal_debugger):\n            thread = ThreadContext(new_thread_id, register_holder)\n\n        self._internal_debugger.insert_new_thread(thread)\n\n        # For any hardware breakpoints, we need to reapply them to the new thread\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.hardware:\n                self.lib_trace.register_hw_breakpoint(\n                    self._global_state,\n                    new_thread_id,\n                    bp.address,\n                    bp.condition.encode().ljust(2, b\"\\x00\"),\n                    chr(bp.length).encode(),\n                )\n\n    def unregister_thread(\n        self: PtraceInterface,\n        thread_id: int,\n        exit_code: int | None,\n        exit_signal: int | None,\n    ) -&gt; None:\n        \"\"\"Unregisters a thread.\n\n        Args:\n            thread_id (int): The thread ID.\n            exit_code (int): The exit code of the thread.\n            exit_signal (int): The exit signal of the thread.\n        \"\"\"\n        self.lib_trace.unregister_thread(self._global_state, thread_id)\n\n        self._internal_debugger.set_thread_as_dead(thread_id, exit_code=exit_code, exit_signal=exit_signal)\n\n    def _set_sw_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Sets a software breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to set.\n        \"\"\"\n        self.lib_trace.register_breakpoint(\n            self._global_state,\n            self.process_id,\n            bp.address,\n        )\n\n    def _unset_sw_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Unsets a software breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to unset.\n        \"\"\"\n        self.lib_trace.unregister_breakpoint(self._global_state, bp.address)\n\n    def _enable_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Enables a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to enable.\n        \"\"\"\n        self.lib_trace.enable_breakpoint(self._global_state, bp.address)\n\n    def _disable_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Disables a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to disable.\n        \"\"\"\n        self.lib_trace.disable_breakpoint(self._global_state, bp.address)\n\n    def set_breakpoint(self: PtraceInterface, bp: Breakpoint, insert: bool = True) -&gt; None:\n        \"\"\"Sets a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to set.\n            insert (bool): Whether the breakpoint has to be inserted or just enabled.\n        \"\"\"\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                if bp.condition == \"x\":\n                    remaining = self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id)\n                else:\n                    remaining = self.lib_trace.get_remaining_hw_watchpoint_count(self._global_state, thread.thread_id)\n\n                if not remaining:\n                    raise ValueError(\"No more hardware breakpoints of this type available\")\n\n                self.lib_trace.register_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                    bp.condition.encode().ljust(2, b\"\\x00\"),\n                    chr(bp.length).encode(),\n                )\n        elif insert:\n            self._set_sw_breakpoint(bp)\n        else:\n            self._enable_breakpoint(bp)\n\n        if insert:\n            self._internal_debugger.breakpoints[bp.address] = bp\n\n    def unset_breakpoint(self: PtraceInterface, bp: Breakpoint, delete: bool = True) -&gt; None:\n        \"\"\"Restores the breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to unset.\n            delete (bool): Whether the breakpoint has to be deleted or just disabled.\n        \"\"\"\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                self.lib_trace.unregister_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                )\n        elif delete:\n            self._unset_sw_breakpoint(bp)\n        else:\n            self._disable_breakpoint(bp)\n\n        if delete:\n            del self._internal_debugger.breakpoints[bp.address]\n\n    def set_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Sets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to set.\n        \"\"\"\n        self._internal_debugger.handled_syscalls[handler.syscall_number] = handler\n\n    def unset_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Unsets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to unset.\n        \"\"\"\n        del self._internal_debugger.handled_syscalls[handler.syscall_number]\n\n    def set_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Sets a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to set.\n        \"\"\"\n        self._internal_debugger.caught_signals[catcher.signal_number] = catcher\n\n    def unset_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Unset a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to unset.\n        \"\"\"\n        del self._internal_debugger.caught_signals[catcher.signal_number]\n\n    def peek_memory(self: PtraceInterface, address: int) -&gt; int:\n        \"\"\"Reads the memory at the specified address.\"\"\"\n        result = self.lib_trace.ptrace_peekdata(self.process_id, address)\n        liblog.debugger(\n            \"PEEKDATA at address %d returned with result %x\",\n            address,\n            result,\n        )\n\n        error = self.ffi.errno\n        if error:\n            raise OSError(error, errno.errorcode[error])\n\n        return result\n\n    def poke_memory(self: PtraceInterface, address: int, value: int) -&gt; None:\n        \"\"\"Writes the memory at the specified address.\"\"\"\n        result = self.lib_trace.ptrace_pokedata(self.process_id, address, value)\n        liblog.debugger(\n            \"POKEDATA at address %d returned with result %d\",\n            address,\n            result,\n        )\n\n        if result == -1:\n            error = self.ffi.errno\n            raise OSError(error, errno.errorcode[error])\n\n    def fetch_fp_registers(self: PtraceInterface, registers: Registers) -&gt; None:\n        \"\"\"Fetches the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to update.\n        \"\"\"\n        liblog.debugger(\"Fetching floating-point registers for thread %d\", registers._thread_id)\n        self.lib_trace.get_fp_regs(registers._thread_id, registers._fp_register_file)\n\n    def flush_fp_registers(self: PtraceInterface, _: Registers) -&gt; None:\n        \"\"\"Flushes the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to update.\n        \"\"\"\n        raise NotImplementedError(\"Flushing floating-point registers is automatically handled by the native code.\")\n\n    def _get_event_msg(self: PtraceInterface, thread_id: int) -&gt; int:\n        \"\"\"Returns the event message.\"\"\"\n        return self.lib_trace.ptrace_geteventmsg(thread_id)\n\n    def maps(self: PtraceInterface) -&gt; list[MemoryMap]:\n        \"\"\"Returns the memory maps of the process.\"\"\"\n        return get_process_maps(self.process_id)\n\n    def get_hit_watchpoint(self: PtraceInterface, thread_id: int) -&gt; Breakpoint:\n        \"\"\"Returns the watchpoint that has been hit.\"\"\"\n        address = self.lib_trace.get_hit_hw_breakpoint(self._global_state, thread_id)\n\n        if not address:\n            return None\n\n        bp = self._internal_debugger.breakpoints[address]\n\n        if bp.condition != \"x\":\n            return bp\n\n        return None\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.detached","title":"<code>detached: bool = False</code>  <code>instance-attribute</code>","text":"<p>Whether the process was detached or not.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.process_id","title":"<code>process_id: int | None = 0</code>  <code>instance-attribute</code>","text":"<p>The process ID of the debugged process.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.attach","title":"<code>attach(pid)</code>","text":"<p>Attaches to the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>the pid of the process to attach to.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def attach(self: PtraceInterface, pid: int) -&gt; None:\n    \"\"\"Attaches to the specified process.\n\n    Args:\n        pid (int): the pid of the process to attach to.\n    \"\"\"\n    # Setup ptrace wait status handler after debugging_context has been properly initialized\n    with extend_internal_debugger(self):\n        self.status_handler = PtraceStatusHandler()\n\n    res = self.lib_trace.ptrace_attach(pid)\n    if res == -1:\n        errno_val = self.ffi.errno\n        raise OSError(errno_val, errno.errorcode[errno_val])\n\n    self.process_id = pid\n    self.detached = False\n    self._internal_debugger.process_id = pid\n    self.register_new_thread(pid)\n    # If we are attaching to a process, we don't want to continue to the entry point\n    # which we have probably already passed\n    self._setup_parent(False)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.cont","title":"<code>cont()</code>","text":"<p>Continues the execution of the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def cont(self: PtraceInterface) -&gt; None:\n    \"\"\"Continues the execution of the process.\"\"\"\n    # Forward signals to the threads\n    if self._internal_debugger.resume_context.threads_with_signals_to_forward:\n        self.forward_signal()\n\n    # Enable all breakpoints if they were disabled for a single step\n    changed = []\n\n    for bp in self._internal_debugger.breakpoints.values():\n        bp._disabled_for_step = False\n        if bp._changed:\n            changed.append(bp)\n            bp._changed = False\n\n    for bp in changed:\n        if bp.enabled:\n            self.set_breakpoint(bp, insert=False)\n        else:\n            self.unset_breakpoint(bp, delete=False)\n\n    for handler in self._internal_debugger.handled_syscalls.values():\n        if handler.enabled or handler.on_enter_pprint or handler.on_exit_pprint:\n            self._global_state.handle_syscall_enabled = True\n            break\n    else:\n        self._global_state.handle_syscall_enabled = False\n\n    result = self.lib_trace.cont_all_and_set_bps(\n        self._global_state,\n        self.process_id,\n    )\n\n    if result &lt; 0:\n        errno_val = self.ffi.errno\n        raise OSError(errno_val, errno.errorcode[errno_val])\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.detach","title":"<code>detach()</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def detach(self: PtraceInterface) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n    # We must disable all breakpoints before detaching\n    for bp in list(self._internal_debugger.breakpoints.values()):\n        if bp.enabled:\n            self.unset_breakpoint(bp, delete=True)\n\n    self.lib_trace.ptrace_detach_and_cont(self._global_state, self.process_id)\n\n    self.detached = True\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.fetch_fp_registers","title":"<code>fetch_fp_registers(registers)</code>","text":"<p>Fetches the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to update.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def fetch_fp_registers(self: PtraceInterface, registers: Registers) -&gt; None:\n    \"\"\"Fetches the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to update.\n    \"\"\"\n    liblog.debugger(\"Fetching floating-point registers for thread %d\", registers._thread_id)\n    self.lib_trace.get_fp_regs(registers._thread_id, registers._fp_register_file)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.finish","title":"<code>finish(thread, heuristic)</code>","text":"<p>Continues execution until the current function returns.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required <code>heuristic</code> <code>str</code> <p>The heuristic to use.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def finish(self: PtraceInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n    \"\"\"Continues execution until the current function returns.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n        heuristic (str): The heuristic to use.\n    \"\"\"\n    if heuristic == \"step-mode\":\n        result = self.lib_trace.stepping_finish(\n            self._global_state,\n            thread.thread_id,\n        )\n\n        if result == -1:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n        # As the wait is done internally, we must invalidate the cache\n        invalidate_process_cache()\n    elif heuristic == \"backtrace\":\n        # Breakpoint to return address\n        last_saved_instruction_pointer = thread.saved_ip\n\n        # If a breakpoint already exists at the return address, we don't need to set a new one\n        found = False\n        ip_breakpoint = None\n\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.address == last_saved_instruction_pointer:\n                found = True\n                ip_breakpoint = bp\n                break\n\n        # If we find an existing breakpoint that is disabled, we enable it\n        # but we need to disable it back after the command\n        should_disable = False\n\n        if not found:\n            # Check if we have enough hardware breakpoints available\n            # Otherwise we use a software breakpoint\n            install_hw_bp = (\n                self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n            )\n\n            ip_breakpoint = Breakpoint(last_saved_instruction_pointer, hardware=install_hw_bp)\n            self.set_breakpoint(ip_breakpoint)\n        elif not ip_breakpoint.enabled:\n            self._enable_breakpoint(ip_breakpoint)\n            should_disable = True\n\n        self.cont()\n        self.wait()\n\n        # Remove the breakpoint if it was set by us\n        if not found:\n            self.unset_breakpoint(ip_breakpoint)\n        # Disable the breakpoint if it was just enabled by us\n        elif should_disable:\n            self._disable_breakpoint(ip_breakpoint)\n    else:\n        raise ValueError(f\"Unimplemented heuristic {heuristic}\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.flush_fp_registers","title":"<code>flush_fp_registers(_)</code>","text":"<p>Flushes the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to update.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def flush_fp_registers(self: PtraceInterface, _: Registers) -&gt; None:\n    \"\"\"Flushes the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to update.\n    \"\"\"\n    raise NotImplementedError(\"Flushing floating-point registers is automatically handled by the native code.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.forward_signal","title":"<code>forward_signal()</code>","text":"<p>Set the signals to forward to the threads.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def forward_signal(self: PtraceInterface) -&gt; None:\n    \"\"\"Set the signals to forward to the threads.\"\"\"\n    # change the global_state\n    cursor = self._global_state.t_HEAD\n    threads = self._internal_debugger.resume_context.threads_with_signals_to_forward\n\n    while cursor != self.ffi.NULL:\n        if cursor.tid in threads:\n            thread = self._internal_debugger.get_thread_by_id(cursor.tid)\n            if thread is None:\n                # The thread is dead in the meantime\n                continue\n            if thread._signal_number != 0 and thread._signal_number not in self._internal_debugger.signals_to_block:\n                liblog.debugger(\n                    f\"Forwarding signal {thread._signal_number} to thread {cursor.tid}\",\n                )\n                # Set the signal to forward\n                cursor.signal_to_forward = thread._signal_number\n                # Reset the signal to forward\n                thread._signal_number = 0\n        cursor = cursor.next\n\n    # Clear the list of threads with signals to forward\n    self._internal_debugger.resume_context.threads_with_signals_to_forward.clear()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.get_hit_watchpoint","title":"<code>get_hit_watchpoint(thread_id)</code>","text":"<p>Returns the watchpoint that has been hit.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def get_hit_watchpoint(self: PtraceInterface, thread_id: int) -&gt; Breakpoint:\n    \"\"\"Returns the watchpoint that has been hit.\"\"\"\n    address = self.lib_trace.get_hit_hw_breakpoint(self._global_state, thread_id)\n\n    if not address:\n        return None\n\n    bp = self._internal_debugger.breakpoints[address]\n\n    if bp.condition != \"x\":\n        return bp\n\n    return None\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.kill","title":"<code>kill()</code>","text":"<p>Instantly terminates the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def kill(self: PtraceInterface) -&gt; None:\n    \"\"\"Instantly terminates the process.\"\"\"\n    if not self.detached:\n        self.lib_trace.ptrace_detach_for_kill(self._global_state, self.process_id)\n    else:\n        # If we detached from the process, there's no reason to attempt to detach again\n        # We can just kill the process\n        os.kill(self.process_id, 9)\n        os.waitpid(self.process_id, 0)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.maps","title":"<code>maps()</code>","text":"<p>Returns the memory maps of the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def maps(self: PtraceInterface) -&gt; list[MemoryMap]:\n    \"\"\"Returns the memory maps of the process.\"\"\"\n    return get_process_maps(self.process_id)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.migrate_from_gdb","title":"<code>migrate_from_gdb()</code>","text":"<p>Migrates the current process from GDB.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def migrate_from_gdb(self: PtraceInterface) -&gt; None:\n    \"\"\"Migrates the current process from GDB.\"\"\"\n    self.lib_trace.ptrace_reattach_from_gdb(self._global_state, self.process_id)\n\n    invalidate_process_cache()\n    self.status_handler.check_for_new_threads(self.process_id)\n\n    # We have to reinstall any hardware breakpoint\n    for bp in self._internal_debugger.breakpoints.values():\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                self.lib_trace.register_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                    bp.condition.encode().ljust(2, b\"\\x00\"),\n                    chr(bp.length).encode(),\n                )\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.migrate_to_gdb","title":"<code>migrate_to_gdb()</code>","text":"<p>Migrates the current process to GDB.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def migrate_to_gdb(self: PtraceInterface) -&gt; None:\n    \"\"\"Migrates the current process to GDB.\"\"\"\n    # Delete any hardware breakpoint\n    for bp in self._internal_debugger.breakpoints.values():\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                self.lib_trace.unregister_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                )\n\n    self.lib_trace.ptrace_detach_for_migration(self._global_state, self.process_id)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.next","title":"<code>next(thread)</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def next(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n\n    opcode_window = thread.memory.read(thread.instruction_pointer, 8)\n\n    # Check if the current instruction is a call and its skip amount\n    is_call, skip = call_utilities_provider(self._internal_debugger.arch).get_call_and_skip_amount(opcode_window)\n\n    if is_call:\n        skip_address = thread.instruction_pointer + skip\n\n        # If a breakpoint already exists at the return address, we don't need to set a new one\n        found = False\n        ip_breakpoint = self._internal_debugger.breakpoints.get(skip_address)\n\n        if ip_breakpoint is not None:\n            found = True\n\n        # If we find an existing breakpoint that is disabled, we enable it\n        # but we need to disable it back after the command\n        should_disable = False\n\n        if not found:\n            # Check if we have enough hardware breakpoints available\n            # Otherwise we use a software breakpoint\n            install_hw_bp = (\n                self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n            )\n            ip_breakpoint = Breakpoint(skip_address, hardware=install_hw_bp)\n            self.set_breakpoint(ip_breakpoint)\n        elif not ip_breakpoint.enabled:\n            self._enable_breakpoint(ip_breakpoint)\n            should_disable = True\n\n        self.cont()\n        self.wait()\n\n        # Remove the breakpoint if it was set by us\n        if not found:\n            self.unset_breakpoint(ip_breakpoint)\n        # Disable the breakpoint if it was just enabled by us\n        elif should_disable:\n            self._disable_breakpoint(ip_breakpoint)\n    else:\n        # Step forward\n        self.step(thread)\n        self.wait()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.peek_memory","title":"<code>peek_memory(address)</code>","text":"<p>Reads the memory at the specified address.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def peek_memory(self: PtraceInterface, address: int) -&gt; int:\n    \"\"\"Reads the memory at the specified address.\"\"\"\n    result = self.lib_trace.ptrace_peekdata(self.process_id, address)\n    liblog.debugger(\n        \"PEEKDATA at address %d returned with result %x\",\n        address,\n        result,\n    )\n\n    error = self.ffi.errno\n    if error:\n        raise OSError(error, errno.errorcode[error])\n\n    return result\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.poke_memory","title":"<code>poke_memory(address, value)</code>","text":"<p>Writes the memory at the specified address.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def poke_memory(self: PtraceInterface, address: int, value: int) -&gt; None:\n    \"\"\"Writes the memory at the specified address.\"\"\"\n    result = self.lib_trace.ptrace_pokedata(self.process_id, address, value)\n    liblog.debugger(\n        \"POKEDATA at address %d returned with result %d\",\n        address,\n        result,\n    )\n\n    if result == -1:\n        error = self.ffi.errno\n        raise OSError(error, errno.errorcode[error])\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.register_new_thread","title":"<code>register_new_thread(new_thread_id)</code>","text":"<p>Registers a new thread.</p> <p>Parameters:</p> Name Type Description Default <code>new_thread_id</code> <code>int</code> <p>The new thread ID.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def register_new_thread(self: PtraceInterface, new_thread_id: int) -&gt; None:\n    \"\"\"Registers a new thread.\n\n    Args:\n        new_thread_id (int): The new thread ID.\n    \"\"\"\n    # The FFI implementation returns a pointer to the register file\n    register_file = self.lib_trace.register_thread(\n        self._global_state,\n        new_thread_id,\n    )\n\n    fp_register_file = self.lib_trace.get_thread_fp_regs(self._global_state, new_thread_id)\n\n    register_holder = register_holder_provider(self._internal_debugger.arch, register_file, fp_register_file)\n\n    with extend_internal_debugger(self._internal_debugger):\n        thread = ThreadContext(new_thread_id, register_holder)\n\n    self._internal_debugger.insert_new_thread(thread)\n\n    # For any hardware breakpoints, we need to reapply them to the new thread\n    for bp in self._internal_debugger.breakpoints.values():\n        if bp.hardware:\n            self.lib_trace.register_hw_breakpoint(\n                self._global_state,\n                new_thread_id,\n                bp.address,\n                bp.condition.encode().ljust(2, b\"\\x00\"),\n                chr(bp.length).encode(),\n            )\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.reset","title":"<code>reset()</code>","text":"<p>Resets the state of the interface.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def reset(self: PtraceInterface) -&gt; None:\n    \"\"\"Resets the state of the interface.\"\"\"\n    self.lib_trace.free_thread_list(self._global_state)\n    self.lib_trace.free_breakpoints(self._global_state)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.run","title":"<code>run()</code>","text":"<p>Runs the specified process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def run(self: PtraceInterface) -&gt; None:\n    \"\"\"Runs the specified process.\"\"\"\n    if not self._disabled_aslr and not self._internal_debugger.aslr_enabled:\n        disable_self_aslr()\n        self._disabled_aslr = True\n\n    argv = self._internal_debugger.argv\n    env = self._internal_debugger.env\n\n    liblog.debugger(\"Running %s\", argv)\n\n    # Setup ptrace wait status handler after debugging_context has been properly initialized\n    with extend_internal_debugger(self):\n        self.status_handler = PtraceStatusHandler()\n\n    # Creating pipes for stdin, stdout, stderr\n    self.stdin_read, self.stdin_write = os.pipe()\n    self.stdout_read, self.stdout_write = pty.openpty()\n    self.stderr_read, self.stderr_write = pty.openpty()\n\n    # Setting stdout, stderr to raw mode to avoid terminal control codes interfering with the\n    # output\n    tty.setraw(self.stdout_read)\n    tty.setraw(self.stderr_read)\n\n    # argv[1] is the length of the custom environment variables\n    # argv[2:2 + env_len] is the custom environment variables\n    # argv[2 + env_len] should be NULL\n    # argv[2 + env_len + 1:] is the new argv\n    if env is None:\n        env_len = -1\n        env = {}\n    else:\n        env_len = len(env)\n\n    argv = [\n        JUMPSTART_LOCATION,\n        str(env_len),\n        *[f\"{key}={value}\" for key, value in env.items()],\n        \"NULL\",\n        *argv,\n    ]\n\n    child_pid = posix_spawn(\n        JUMPSTART_LOCATION,\n        argv,\n        os.environ,\n        file_actions=[\n            (POSIX_SPAWN_CLOSE, self.stdin_write),\n            (POSIX_SPAWN_CLOSE, self.stdout_read),\n            (POSIX_SPAWN_CLOSE, self.stderr_read),\n            (POSIX_SPAWN_DUP2, self.stdin_read, 0),\n            (POSIX_SPAWN_DUP2, self.stdout_write, 1),\n            (POSIX_SPAWN_DUP2, self.stderr_write, 2),\n            (POSIX_SPAWN_CLOSE, self.stdin_read),\n            (POSIX_SPAWN_CLOSE, self.stdout_write),\n            (POSIX_SPAWN_CLOSE, self.stderr_write),\n        ],\n        setpgroup=0,\n    )\n\n    self.process_id = child_pid\n    self.detached = False\n    self._internal_debugger.process_id = child_pid\n    self.register_new_thread(child_pid)\n    continue_to_entry_point = self._internal_debugger.autoreach_entrypoint\n    self._setup_parent(continue_to_entry_point)\n    self._internal_debugger.pipe_manager = self._setup_pipe()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.set_breakpoint","title":"<code>set_breakpoint(bp, insert=True)</code>","text":"<p>Sets a breakpoint at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to set.</p> required <code>insert</code> <code>bool</code> <p>Whether the breakpoint has to be inserted or just enabled.</p> <code>True</code> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def set_breakpoint(self: PtraceInterface, bp: Breakpoint, insert: bool = True) -&gt; None:\n    \"\"\"Sets a breakpoint at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to set.\n        insert (bool): Whether the breakpoint has to be inserted or just enabled.\n    \"\"\"\n    if bp.hardware:\n        for thread in self._internal_debugger.threads:\n            if bp.condition == \"x\":\n                remaining = self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id)\n            else:\n                remaining = self.lib_trace.get_remaining_hw_watchpoint_count(self._global_state, thread.thread_id)\n\n            if not remaining:\n                raise ValueError(\"No more hardware breakpoints of this type available\")\n\n            self.lib_trace.register_hw_breakpoint(\n                self._global_state,\n                thread.thread_id,\n                bp.address,\n                bp.condition.encode().ljust(2, b\"\\x00\"),\n                chr(bp.length).encode(),\n            )\n    elif insert:\n        self._set_sw_breakpoint(bp)\n    else:\n        self._enable_breakpoint(bp)\n\n    if insert:\n        self._internal_debugger.breakpoints[bp.address] = bp\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.set_signal_catcher","title":"<code>set_signal_catcher(catcher)</code>","text":"<p>Sets a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to set.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def set_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Sets a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to set.\n    \"\"\"\n    self._internal_debugger.caught_signals[catcher.signal_number] = catcher\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.set_syscall_handler","title":"<code>set_syscall_handler(handler)</code>","text":"<p>Sets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to set.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def set_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Sets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to set.\n    \"\"\"\n    self._internal_debugger.handled_syscalls[handler.syscall_number] = handler\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.step","title":"<code>step(thread)</code>","text":"<p>Executes a single instruction of the process.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def step(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the process.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n    \"\"\"\n    # Disable all breakpoints for the single step\n    for bp in self._internal_debugger.breakpoints.values():\n        bp._disabled_for_step = True\n\n    result = self.lib_trace.singlestep(self._global_state, thread.thread_id)\n    if result == -1:\n        errno_val = self.ffi.errno\n        raise OSError(errno_val, errno.errorcode[errno_val])\n\n    self._internal_debugger.resume_context.is_a_step = True\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.step_until","title":"<code>step_until(thread, address, max_steps)</code>","text":"<p>Executes instructions of the specified thread until the specified address is reached.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required <code>address</code> <code>int</code> <p>The address to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def step_until(self: PtraceInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n    \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n        address (int): The address to reach.\n        max_steps (int): The maximum number of steps to execute.\n    \"\"\"\n    # Disable all breakpoints for the single step\n    for bp in self._internal_debugger.breakpoints.values():\n        bp._disabled_for_step = True\n\n    result = self.lib_trace.step_until(\n        self._global_state,\n        thread.thread_id,\n        address,\n        max_steps,\n    )\n    if result == -1:\n        errno_val = self.ffi.errno\n        raise OSError(errno_val, errno.errorcode[errno_val])\n\n    # As the wait is done internally, we must invalidate the cache\n    invalidate_process_cache()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unregister_thread","title":"<code>unregister_thread(thread_id, exit_code, exit_signal)</code>","text":"<p>Unregisters a thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>The thread ID.</p> required <code>exit_code</code> <code>int</code> <p>The exit code of the thread.</p> required <code>exit_signal</code> <code>int</code> <p>The exit signal of the thread.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unregister_thread(\n    self: PtraceInterface,\n    thread_id: int,\n    exit_code: int | None,\n    exit_signal: int | None,\n) -&gt; None:\n    \"\"\"Unregisters a thread.\n\n    Args:\n        thread_id (int): The thread ID.\n        exit_code (int): The exit code of the thread.\n        exit_signal (int): The exit signal of the thread.\n    \"\"\"\n    self.lib_trace.unregister_thread(self._global_state, thread_id)\n\n    self._internal_debugger.set_thread_as_dead(thread_id, exit_code=exit_code, exit_signal=exit_signal)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unset_breakpoint","title":"<code>unset_breakpoint(bp, delete=True)</code>","text":"<p>Restores the breakpoint at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to unset.</p> required <code>delete</code> <code>bool</code> <p>Whether the breakpoint has to be deleted or just disabled.</p> <code>True</code> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unset_breakpoint(self: PtraceInterface, bp: Breakpoint, delete: bool = True) -&gt; None:\n    \"\"\"Restores the breakpoint at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to unset.\n        delete (bool): Whether the breakpoint has to be deleted or just disabled.\n    \"\"\"\n    if bp.hardware:\n        for thread in self._internal_debugger.threads:\n            self.lib_trace.unregister_hw_breakpoint(\n                self._global_state,\n                thread.thread_id,\n                bp.address,\n            )\n    elif delete:\n        self._unset_sw_breakpoint(bp)\n    else:\n        self._disable_breakpoint(bp)\n\n    if delete:\n        del self._internal_debugger.breakpoints[bp.address]\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unset_signal_catcher","title":"<code>unset_signal_catcher(catcher)</code>","text":"<p>Unset a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to unset.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unset_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Unset a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to unset.\n    \"\"\"\n    del self._internal_debugger.caught_signals[catcher.signal_number]\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unset_syscall_handler","title":"<code>unset_syscall_handler(handler)</code>","text":"<p>Unsets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to unset.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unset_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Unsets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to unset.\n    \"\"\"\n    del self._internal_debugger.handled_syscalls[handler.syscall_number]\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.wait","title":"<code>wait()</code>","text":"<p>Waits for the process to stop. Returns True if the wait has to be repeated.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def wait(self: PtraceInterface) -&gt; None:\n    \"\"\"Waits for the process to stop. Returns True if the wait has to be repeated.\"\"\"\n    result = self.lib_trace.wait_all_and_update_regs(\n        self._global_state,\n        self.process_id,\n    )\n\n    cursor = result\n\n    invalidate_process_cache()\n\n    results = []\n\n    while cursor != self.ffi.NULL:\n        results.append((cursor.tid, cursor.status))\n        cursor = cursor.next\n\n    # Check the result of the waitpid and handle the changes.\n    self.status_handler.manage_change(results)\n\n    self.lib_trace.free_thread_status_list(result)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/","title":"libdebug.ptrace.ptrace_register_holder","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder","title":"<code>PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RegisterHolder</code></p> <p>An abstract class that holds the state of the registers of a process, providing setters and getters for them.</p> <p>Intended for use with the Ptrace debugging backend.</p> Source code in <code>libdebug/ptrace/ptrace_register_holder.py</code> <pre><code>@dataclass\nclass PtraceRegisterHolder(RegisterHolder):\n    \"\"\"An abstract class that holds the state of the registers of a process, providing setters and getters for them.\n\n    Intended for use with the Ptrace debugging backend.\n    \"\"\"\n\n    register_file: object\n    \"\"\"The register file of the target process, as returned by ptrace.\"\"\"\n\n    fp_register_file: object\n    \"\"\"The floating-point register file of the target process, as returned by ptrace.\"\"\"\n\n    def poll(self: PtraceRegisterHolder, target: ThreadContext) -&gt; None:\n        \"\"\"Poll the register values from the specified target.\"\"\"\n        raise NotImplementedError(\"Do not call this method.\")\n\n    def flush(self: PtraceRegisterHolder, source: ThreadContext) -&gt; None:\n        \"\"\"Flush the register values from the specified source.\"\"\"\n        raise NotImplementedError(\"Do not call this method.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.fp_register_file","title":"<code>fp_register_file: object</code>  <code>instance-attribute</code>","text":"<p>The floating-point register file of the target process, as returned by ptrace.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.register_file","title":"<code>register_file: object</code>  <code>instance-attribute</code>","text":"<p>The register file of the target process, as returned by ptrace.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.flush","title":"<code>flush(source)</code>","text":"<p>Flush the register values from the specified source.</p> Source code in <code>libdebug/ptrace/ptrace_register_holder.py</code> <pre><code>def flush(self: PtraceRegisterHolder, source: ThreadContext) -&gt; None:\n    \"\"\"Flush the register values from the specified source.\"\"\"\n    raise NotImplementedError(\"Do not call this method.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.poll","title":"<code>poll(target)</code>","text":"<p>Poll the register values from the specified target.</p> Source code in <code>libdebug/ptrace/ptrace_register_holder.py</code> <pre><code>def poll(self: PtraceRegisterHolder, target: ThreadContext) -&gt; None:\n    \"\"\"Poll the register values from the specified target.\"\"\"\n    raise NotImplementedError(\"Do not call this method.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/","title":"libdebug.ptrace.ptrace_status_handler","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler","title":"<code>PtraceStatusHandler</code>","text":"<p>This class handles the states return by the waitpid calls on the debugger process.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>class PtraceStatusHandler:\n    \"\"\"This class handles the states return by the waitpid calls on the debugger process.\"\"\"\n\n    def __init__(self: PtraceStatusHandler) -&gt; None:\n        \"\"\"Initializes the PtraceStatusHandler class.\"\"\"\n        self.internal_debugger = provide_internal_debugger(self)\n        self.ptrace_interface: DebuggingInterface = self.internal_debugger.debugging_interface\n        self.forward_signal: bool = True\n        self._assume_race_sigstop: bool = (\n            True  # Assume the stop is due to a race condition with SIGSTOP sent by the debugger\n        )\n\n    def _handle_clone(self: PtraceStatusHandler, thread_id: int, results: list) -&gt; None:\n        # https://go.googlesource.com/debug/+/a09ead70f05c87ad67bd9a131ff8352cf39a6082/doc/ptrace-nptl.txt\n        # \"At this time, the new thread will exist, but will initially\n        # be stopped with a SIGSTOP.  The new thread will automatically be\n        # traced and will inherit the PTRACE_O_TRACECLONE option from its\n        # parent.  The attached process should wait on the new thread to receive\n        # the SIGSTOP notification.\"\n\n        # Check if we received the SIGSTOP notification for the new thread\n        # If not, we need to wait for it\n        # 4991 == (WIFSTOPPED &amp;&amp; WSTOPSIG(status) == SIGSTOP)\n        if (thread_id, 4991) not in results:\n            os.waitpid(thread_id, 0)\n        self.ptrace_interface.register_new_thread(thread_id)\n\n    def _handle_exit(\n        self: PtraceStatusHandler,\n        thread_id: int,\n        exit_code: int | None,\n        exit_signal: int | None,\n    ) -&gt; None:\n        if self.internal_debugger.get_thread_by_id(thread_id):\n            self.ptrace_interface.unregister_thread(thread_id, exit_code=exit_code, exit_signal=exit_signal)\n\n    def _handle_breakpoints(self: PtraceStatusHandler, thread_id: int) -&gt; bool:\n        thread = self.internal_debugger.get_thread_by_id(thread_id)\n\n        if not hasattr(thread, \"instruction_pointer\"):\n            # This is a signal trap hit on process startup\n            # Do not resume the process until the user decides to do so\n            self.internal_debugger.resume_context.resume = False\n            self.forward_signal = False\n            return\n\n        ip = thread.instruction_pointer\n\n        bp: None | Breakpoint\n\n        bp = self.internal_debugger.breakpoints.get(ip)\n        if bp and bp.enabled and not bp._disabled_for_step:\n            # Hardware breakpoint hit\n            liblog.debugger(\"Hardware breakpoint hit at 0x%x\", ip)\n        else:\n            # If the trap was caused by a software breakpoint, we need to restore the original instruction\n            # and set the instruction pointer to the previous instruction.\n            ip -= software_breakpoint_byte_size(self.internal_debugger.arch)\n\n            bp = self.internal_debugger.breakpoints.get(ip)\n            if bp and bp.enabled and not bp._disabled_for_step:\n                # Software breakpoint hit\n                liblog.debugger(\"Software breakpoint hit at 0x%x\", ip)\n\n                # Set the instruction pointer to the previous instruction\n                thread.instruction_pointer = ip\n\n                # Link the breakpoint to the thread, so that we can step over it\n                bp._linked_thread_ids.append(thread_id)\n            else:\n                # If the breakpoint has been hit but is not enabled, we need to reset the bp variable\n                bp = None\n\n        # Manage watchpoints\n        if not bp:\n            bp = self.ptrace_interface.get_hit_watchpoint(thread_id)\n            if bp:\n                liblog.debugger(\"Watchpoint hit at 0x%x\", bp.address)\n\n        if bp:\n            self.forward_signal = False\n            bp.hit_count += 1\n\n            if bp.callback:\n                bp.callback(thread, bp)\n            else:\n                # If the breakpoint has no callback, we need to stop the process despite the other signals\n                self.internal_debugger.resume_context.resume = False\n\n    def _manage_syscall_on_enter(\n        self: PtraceStatusHandler,\n        handler: SyscallHandler,\n        thread: ThreadContext,\n        syscall_number: int,\n        hijacked_set: set[int],\n    ) -&gt; None:\n        \"\"\"Manage the on_enter callback of a syscall.\"\"\"\n        # Call the user-defined callback if it exists\n        if handler.on_enter_user and handler.enabled:\n            old_args = [\n                thread.syscall_arg0,\n                thread.syscall_arg1,\n                thread.syscall_arg2,\n                thread.syscall_arg3,\n                thread.syscall_arg4,\n                thread.syscall_arg5,\n            ]\n            handler.on_enter_user(thread, handler)\n\n            # Check if the syscall number has changed\n            syscall_number_after_callback = thread.syscall_number\n\n            if syscall_number_after_callback != syscall_number:\n                # Pretty print the syscall number before the callback\n                if handler.on_enter_pprint:\n                    handler.on_enter_pprint(\n                        thread,\n                        syscall_number,\n                        hijacked=True,\n                        old_args=old_args,\n                    )\n                # The syscall number has changed\n                if syscall_number_after_callback in self.internal_debugger.handled_syscalls:\n                    callback_hijack = self.internal_debugger.handled_syscalls[syscall_number_after_callback]\n\n                    # Check if the new syscall has to be handled recursively\n                    if handler.recursive:\n                        if syscall_number_after_callback not in hijacked_set:\n                            hijacked_set.add(syscall_number_after_callback)\n                        else:\n                            # The syscall has already been hijacked in the current chain\n                            raise RuntimeError(\n                                \"Syscall hijacking loop detected. Check your code to avoid infinite loops.\",\n                            )\n\n                        # Call recursively the function to manage the new syscall\n                        self._manage_syscall_on_enter(\n                            callback_hijack,\n                            thread,\n                            syscall_number_after_callback,\n                            hijacked_set,\n                        )\n                    elif callback_hijack.on_enter_pprint:\n                        # Pretty print the syscall number\n                        callback_hijack.on_enter_pprint(thread, syscall_number_after_callback)\n                        callback_hijack._has_entered = True\n                        callback_hijack._skip_exit = True\n                    else:\n                        # Skip the exit callback of the syscall that has been hijacked\n                        callback_hijack._has_entered = True\n                        callback_hijack._skip_exit = True\n            elif handler.on_enter_pprint:\n                # Pretty print the syscall number\n                handler.on_enter_pprint(thread, syscall_number, callback=True)\n                handler._has_entered = True\n            else:\n                handler._has_entered = True\n        elif handler.on_enter_pprint:\n            # Pretty print the syscall number\n            handler.on_enter_pprint(thread, syscall_number)\n            handler._has_entered = True\n        elif handler.on_exit_pprint or handler.on_exit_user:\n            # The syscall has been entered but the user did not define an on_enter callback\n            handler._has_entered = True\n        if not handler.on_enter_user and not handler.on_exit_user and handler.enabled:\n            # If the syscall has no callback, we need to stop the process despite the other signals\n            handler._has_entered = True\n            self.internal_debugger.resume_context.resume = False\n\n    def _handle_syscall(self: PtraceStatusHandler, thread_id: int) -&gt; bool:\n        \"\"\"Handle a syscall trap.\"\"\"\n        thread = self.internal_debugger.get_thread_by_id(thread_id)\n        if not hasattr(thread, \"syscall_number\"):\n            # This is another spurious trap, we don't know what to do with it\n            return\n\n        syscall_number = thread.syscall_number\n\n        if syscall_number not in self.internal_debugger.handled_syscalls:\n            # This is a syscall we don't care about\n            # Resume the execution\n            return\n\n        handler = self.internal_debugger.handled_syscalls[syscall_number]\n\n        if not handler._has_entered:\n            # The syscall is being entered\n            liblog.debugger(\n                \"Syscall %d entered on thread %d\",\n                syscall_number,\n                thread_id,\n            )\n\n            self._manage_syscall_on_enter(\n                handler,\n                thread,\n                syscall_number,\n                {syscall_number},\n            )\n\n        else:\n            # The syscall is being exited\n            liblog.debugger(\"Syscall %d exited on thread %d\", syscall_number, thread_id)\n\n            if handler.enabled and not handler._skip_exit:\n                # Increment the hit count only if the syscall has been handled\n                handler.hit_count += 1\n\n            # Call the user-defined callback if it exists\n            if handler.on_exit_user and handler.enabled and not handler._skip_exit:\n                # Pretty print the return value before the callback\n                if handler.on_exit_pprint:\n                    return_value_before_callback = thread.syscall_return\n                handler.on_exit_user(thread, handler)\n                if handler.on_exit_pprint:\n                    return_value_after_callback = thread.syscall_return\n                    if return_value_after_callback != return_value_before_callback:\n                        handler.on_exit_pprint(\n                            (return_value_before_callback, return_value_after_callback),\n                        )\n                    else:\n                        handler.on_exit_pprint(return_value_after_callback)\n            elif handler.on_exit_pprint:\n                # Pretty print the return value\n                handler.on_exit_pprint(thread.syscall_return)\n\n            handler._has_entered = False\n            handler._skip_exit = False\n            if not handler.on_enter_user and not handler.on_exit_user and handler.enabled:\n                # If the syscall has no callback, we need to stop the process despite the other signals\n                self.internal_debugger.resume_context.resume = False\n\n    def _manage_caught_signal(\n        self: PtraceStatusHandler,\n        catcher: SignalCatcher,\n        thread: ThreadContext,\n        signal_number: int,\n        hijacked_set: set[int],\n    ) -&gt; None:\n        if catcher.enabled:\n            catcher.hit_count += 1\n            liblog.debugger(\n                \"Caught signal %s (%d) hit on thread %d\",\n                resolve_signal_name(signal_number),\n                signal_number,\n                thread.thread_id,\n            )\n            if catcher.callback:\n                # Execute the user-defined callback\n                catcher.callback(thread, catcher)\n\n                new_signal_number = thread._signal_number\n\n                if new_signal_number != signal_number:\n                    # The signal number has changed\n                    liblog.debugger(\n                        \"Signal %s (%d) has been hijacked to %s (%d)\",\n                        resolve_signal_name(signal_number),\n                        signal_number,\n                        resolve_signal_name(new_signal_number),\n                        new_signal_number,\n                    )\n\n                    if catcher.recursive and new_signal_number in self.internal_debugger.caught_signals:\n                        hijack_cath_signal = self.internal_debugger.caught_signals[new_signal_number]\n                        if new_signal_number not in hijacked_set:\n                            hijacked_set.add(new_signal_number)\n                        else:\n                            # The signal has already been replaced in the current chain\n                            raise RuntimeError(\n                                \"Signal hijacking loop detected. Check your script to avoid infinite loops.\",\n                            )\n                        # Call recursively the function to manage the new signal\n                        self._manage_caught_signal(\n                            hijack_cath_signal,\n                            thread,\n                            new_signal_number,\n                            hijacked_set,\n                        )\n            else:\n                # If the caught signal has no callback, we need to stop the process despite the other signals\n                self.internal_debugger.resume_context.resume = False\n\n    def _handle_signal(self: PtraceStatusHandler, thread: ThreadContext) -&gt; bool:\n        \"\"\"Handle the signal trap.\"\"\"\n        signal_number = thread._signal_number\n\n        if signal_number in self.internal_debugger.caught_signals:\n            catcher = self.internal_debugger.caught_signals[signal_number]\n\n            self._manage_caught_signal(catcher, thread, signal_number, {signal_number})\n\n    def _internal_signal_handler(\n        self: PtraceStatusHandler,\n        pid: int,\n        signum: int,\n        results: list,\n        status: int,\n    ) -&gt; None:\n        \"\"\"Internal handler for signals used by the debugger.\"\"\"\n        if signum == SYSCALL_SIGTRAP:\n            # We hit a syscall\n            liblog.debugger(\"Child thread %d stopped on syscall\", pid)\n            self._handle_syscall(pid)\n            self.forward_signal = False\n        elif signum == signal.SIGSTOP and self.internal_debugger.resume_context.force_interrupt:\n            # The user has requested an interrupt, we need to stop the process despite the ohter signals\n            liblog.debugger(\n                \"Child thread %d stopped with signal %s\",\n                pid,\n                resolve_signal_name(signum),\n            )\n            self.internal_debugger.resume_context.resume = False\n            self.internal_debugger.resume_context.force_interrupt = False\n            self.forward_signal = False\n        elif signum == signal.SIGTRAP:\n            # The trap decides if we hit a breakpoint. If so, it decides whether we should stop or\n            # continue the execution and wait for the next trap\n            self._handle_breakpoints(pid)\n\n            if self.internal_debugger.resume_context.is_a_step:\n                # The process is stepping, we need to stop the execution\n                self.internal_debugger.resume_context.resume = False\n                self.internal_debugger.resume_context.is_a_step = False\n                self.forward_signal = False\n\n            event = status &gt;&gt; 8\n            match event:\n                case StopEvents.CLONE_EVENT:\n                    # The process has been cloned\n                    message = self.ptrace_interface._get_event_msg(pid)\n                    liblog.debugger(\n                        f\"Process {pid} cloned, new thread_id: {message}\",\n                    )\n                    self._handle_clone(message, results)\n                    self.forward_signal = False\n                case StopEvents.SECCOMP_EVENT:\n                    # The process has installed a seccomp\n                    liblog.debugger(f\"Process {pid} installed a seccomp\")\n                    self.forward_signal = False\n                case StopEvents.EXIT_EVENT:\n                    # The tracee is still alive; it needs\n                    # to be PTRACE_CONTed or PTRACE_DETACHed to finish exiting.\n                    # so we don't call self._handle_exit(pid) here\n                    # it will be called at the next wait (hopefully)\n                    message = self.ptrace_interface._get_event_msg(pid)\n                    liblog.debugger(\n                        f\"Thread {pid} exited with status: {message}\",\n                    )\n                    self.forward_signal = False\n                case StopEvents.FORK_EVENT:\n                    # The process has been forked\n                    liblog.warning(\n                        f\"Process {pid} forked. Continuing execution of the parent process. The child process will be stopped until the user decides to attach to it.\",\n                    )\n                    self.forward_signal = False\n\n    def _handle_change(self: PtraceStatusHandler, pid: int, status: int, results: list) -&gt; None:\n        \"\"\"Handle a change in the status of a traced process.\"\"\"\n        # Initialize the forward_signal flag\n        self.forward_signal = True\n\n        if os.WIFSTOPPED(status):\n            if self.internal_debugger.resume_context.is_startup:\n                # The process has just started\n                return\n            signum = os.WSTOPSIG(status)\n\n            if signum != signal.SIGSTOP:\n                self._assume_race_sigstop = False\n\n            # Check if the debugger needs to handle the signal\n            self._internal_signal_handler(pid, signum, results, status)\n\n            thread = self.internal_debugger.get_thread_by_id(pid)\n\n            if thread is not None:\n                thread._signal_number = signum\n\n                # Handle the signal\n                self._handle_signal(thread)\n\n                if self.forward_signal and signum != signal.SIGSTOP:\n                    # We have to forward the signal to the thread\n                    self.internal_debugger.resume_context.threads_with_signals_to_forward.append(pid)\n\n        if os.WIFEXITED(status):\n            # The thread has exited normally\n            exit_code = os.WEXITSTATUS(status)\n            liblog.debugger(\"Child process %d exited with exit code %d\", pid, exit_code)\n            self._handle_exit(pid, exit_code=exit_code, exit_signal=None)\n\n        if os.WIFSIGNALED(status):\n            # The thread has exited with a signal\n            exit_signal = os.WTERMSIG(status)\n            liblog.debugger(\"Child process %d exited with signal %d\", pid, exit_signal)\n            self._handle_exit(pid, exit_code=None, exit_signal=exit_signal)\n\n    def manage_change(self: PtraceStatusHandler, result: list[tuple]) -&gt; None:\n        \"\"\"Manage the result of the waitpid and handle the changes.\"\"\"\n        # Assume that the stop depends on SIGSTOP sent by the debugger\n        # This is a workaround for some race conditions that may happen\n        self._assume_race_sigstop = True\n\n        for pid, status in result:\n            if pid != -1:\n                # Otherwise, this is a spurious trap\n                self._handle_change(pid, status, result)\n\n        if self._assume_race_sigstop:\n            # Resume the process if the stop was due to a race condition with SIGSTOP sent by the debugger\n            return\n\n    def check_for_new_threads(self: PtraceStatusHandler, pid: int) -&gt; None:\n        \"\"\"Check for new threads in the process and register them.\"\"\"\n        if not Path(f\"/proc/{pid}/task\").exists():\n            return\n\n        tids = [int(x) for x in os.listdir(f\"/proc/{pid}/task\")]\n        for tid in tids:\n            if not self.internal_debugger.get_thread_by_id(tid):\n                self.ptrace_interface.register_new_thread(tid, self.internal_debugger)\n                liblog.debugger(\"Manually registered new thread %d\" % tid)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the PtraceStatusHandler class.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>def __init__(self: PtraceStatusHandler) -&gt; None:\n    \"\"\"Initializes the PtraceStatusHandler class.\"\"\"\n    self.internal_debugger = provide_internal_debugger(self)\n    self.ptrace_interface: DebuggingInterface = self.internal_debugger.debugging_interface\n    self.forward_signal: bool = True\n    self._assume_race_sigstop: bool = (\n        True  # Assume the stop is due to a race condition with SIGSTOP sent by the debugger\n    )\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler.check_for_new_threads","title":"<code>check_for_new_threads(pid)</code>","text":"<p>Check for new threads in the process and register them.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>def check_for_new_threads(self: PtraceStatusHandler, pid: int) -&gt; None:\n    \"\"\"Check for new threads in the process and register them.\"\"\"\n    if not Path(f\"/proc/{pid}/task\").exists():\n        return\n\n    tids = [int(x) for x in os.listdir(f\"/proc/{pid}/task\")]\n    for tid in tids:\n        if not self.internal_debugger.get_thread_by_id(tid):\n            self.ptrace_interface.register_new_thread(tid, self.internal_debugger)\n            liblog.debugger(\"Manually registered new thread %d\" % tid)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler.manage_change","title":"<code>manage_change(result)</code>","text":"<p>Manage the result of the waitpid and handle the changes.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>def manage_change(self: PtraceStatusHandler, result: list[tuple]) -&gt; None:\n    \"\"\"Manage the result of the waitpid and handle the changes.\"\"\"\n    # Assume that the stop depends on SIGSTOP sent by the debugger\n    # This is a workaround for some race conditions that may happen\n    self._assume_race_sigstop = True\n\n    for pid, status in result:\n        if pid != -1:\n            # Otherwise, this is a spurious trap\n            self._handle_change(pid, status, result)\n\n    if self._assume_race_sigstop:\n        # Resume the process if the stop was due to a race condition with SIGSTOP sent by the debugger\n        return\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/","title":"libdebug.state.resume_context","text":""},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.ResumeContext","title":"<code>ResumeContext</code>","text":"<p>A class representing the context of the resume decision.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>class ResumeContext:\n    \"\"\"A class representing the context of the resume decision.\"\"\"\n\n    def __init__(self: ResumeContext) -&gt; None:\n        \"\"\"Initializes the ResumeContext.\"\"\"\n        self.resume: bool = True\n        self.force_interrupt: bool = False\n        self.is_a_step: bool = False\n        self.is_startup: bool = False\n        self.block_on_signal: bool = False\n        self.threads_with_signals_to_forward: list[int] = []\n\n    def clear(self: ResumeContext) -&gt; None:\n        \"\"\"Clears the context.\"\"\"\n        self.resume = True\n        self.force_interrupt = False\n        self.is_a_step = False\n        self.is_startup = False\n        self.block_on_signal = False\n        self.threads_with_signals_to_forward.clear()\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.ResumeContext.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ResumeContext.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>def __init__(self: ResumeContext) -&gt; None:\n    \"\"\"Initializes the ResumeContext.\"\"\"\n    self.resume: bool = True\n    self.force_interrupt: bool = False\n    self.is_a_step: bool = False\n    self.is_startup: bool = False\n    self.block_on_signal: bool = False\n    self.threads_with_signals_to_forward: list[int] = []\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.ResumeContext.clear","title":"<code>clear()</code>","text":"<p>Clears the context.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>def clear(self: ResumeContext) -&gt; None:\n    \"\"\"Clears the context.\"\"\"\n    self.resume = True\n    self.force_interrupt = False\n    self.is_a_step = False\n    self.is_startup = False\n    self.block_on_signal = False\n    self.threads_with_signals_to_forward.clear()\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/","title":"libdebug.state.thread_context","text":""},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext","title":"<code>ThreadContext</code>","text":"<p>This object represents a thread in the context of the target process. It holds information about the thread's state, registers and stack.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>class ThreadContext:\n    \"\"\"This object represents a thread in the context of the target process. It holds information about the thread's state, registers and stack.\"\"\"\n\n    instruction_pointer: int\n    \"\"\"The thread's instruction pointer.\"\"\"\n\n    syscall_arg0: int\n    \"\"\"The thread's syscall argument 0.\"\"\"\n\n    syscall_arg1: int\n    \"\"\"The thread's syscall argument 1.\"\"\"\n\n    syscall_arg2: int\n    \"\"\"The thread's syscall argument 2.\"\"\"\n\n    syscall_arg3: int\n    \"\"\"The thread's syscall argument 3.\"\"\"\n\n    syscall_arg4: int\n    \"\"\"The thread's syscall argument 4.\"\"\"\n\n    syscall_arg5: int\n    \"\"\"The thread's syscall argument 5.\"\"\"\n\n    syscall_number: int\n    \"\"\"The thread's syscall number.\"\"\"\n\n    syscall_return: int\n    \"\"\"The thread's syscall return value.\"\"\"\n\n    regs: Registers\n    \"\"\"The thread's registers.\"\"\"\n\n    _internal_debugger: InternalDebugger | None = None\n    \"\"\"The debugging context this thread belongs to.\"\"\"\n\n    _dead: bool = False\n    \"\"\"Whether the thread is dead.\"\"\"\n\n    _exit_code: int | None = None\n    \"\"\"The thread's exit code.\"\"\"\n\n    _exit_signal: int | None = None\n    \"\"\"The thread's exit signal.\"\"\"\n\n    _signal_number: int = 0\n    \"\"\"The signal to forward to the thread.\"\"\"\n\n    _thread_id: int\n    \"\"\"The thread's ID.\"\"\"\n\n    def __init__(self: ThreadContext, thread_id: int, registers: RegisterHolder) -&gt; None:\n        \"\"\"Initializes the Thread Context.\"\"\"\n        self._internal_debugger = provide_internal_debugger(self)\n        self._thread_id = thread_id\n        regs_class = registers.provide_regs_class()\n        self.regs = regs_class(thread_id)\n        registers.apply_on_regs(self.regs, regs_class)\n        registers.apply_on_thread(self, ThreadContext)\n\n    def set_as_dead(self: ThreadContext) -&gt; None:\n        \"\"\"Set the thread as dead.\"\"\"\n        self._dead = True\n\n    @property\n    def dead(self: ThreadContext) -&gt; bool:\n        \"\"\"Whether the thread is dead.\"\"\"\n        return self._dead\n\n    @property\n    def memory(self: ThreadContext) -&gt; AbstractMemoryView:\n        \"\"\"The memory view of the debugged process.\"\"\"\n        return self._internal_debugger.memory\n\n    @property\n    def mem(self: ThreadContext) -&gt; AbstractMemoryView:\n        \"\"\"Alias for the `memory` property.\n\n        Get the memory view of the process.\n        \"\"\"\n        return self._internal_debugger.memory\n\n    @property\n    def process_id(self: ThreadContext) -&gt; int:\n        \"\"\"The process ID of the thread.\"\"\"\n        return self._internal_debugger.process_id\n\n    @property\n    def pid(self: ThreadContext) -&gt; int:\n        \"\"\"The process ID of the thread.\"\"\"\n        return self._internal_debugger.process_id\n\n    @property\n    def thread_id(self: ThreadContext) -&gt; int:\n        \"\"\"The thread ID.\"\"\"\n        return self._thread_id\n\n    @property\n    def tid(self: ThreadContext) -&gt; int:\n        \"\"\"The thread ID.\"\"\"\n        return self._thread_id\n\n    @property\n    def running(self: ThreadContext) -&gt; bool:\n        \"\"\"Whether the process is running.\"\"\"\n        return self._internal_debugger.running\n\n    @property\n    def exit_code(self: ThreadContext) -&gt; int | None:\n        \"\"\"The thread's exit code.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        if not self.dead:\n            liblog.warning(\"Thread is not dead. No exit code available.\")\n        elif self._exit_code is None and self._exit_signal is not None:\n            liblog.warning(\n                \"Thread exited with signal %s. No exit code available.\",\n                resolve_signal_name(self._exit_signal),\n            )\n        return self._exit_code\n\n    @property\n    def exit_signal(self: ThreadContext) -&gt; str | None:\n        \"\"\"The thread's exit signal.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        if not self.dead:\n            liblog.warning(\"Thread is not dead. No exit signal available.\")\n            return None\n        elif self._exit_signal is None and self._exit_code is not None:\n            liblog.warning(\"Thread exited with code %d. No exit signal available.\", self._exit_code)\n            return None\n        return resolve_signal_name(self._exit_signal)\n\n    @property\n    def signal(self: ThreadContext) -&gt; str | None:\n        \"\"\"The signal will be forwarded to the thread.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        return None if self._signal_number == 0 else resolve_signal_name(self._signal_number)\n\n    @signal.setter\n    def signal(self: ThreadContext, signal: str | int) -&gt; None:\n        \"\"\"Set the signal to forward to the thread.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        if self._signal_number != 0:\n            liblog.debugger(\n                f\"Overwriting signal {resolve_signal_name(self._signal_number)} with {resolve_signal_name(signal) if isinstance(signal, int) else signal}.\",\n            )\n        if isinstance(signal, str):\n            signal = resolve_signal_number(signal)\n        self._signal_number = signal\n        self._internal_debugger.resume_context.threads_with_signals_to_forward.append(self.thread_id)\n\n    def backtrace(self: ThreadContext, as_symbols: bool = False) -&gt; list:\n        \"\"\"Returns the current backtrace of the thread.\n\n        Args:\n            as_symbols (bool, optional): Whether to return the backtrace as symbols\n        \"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n        backtrace = stack_unwinder.unwind(self)\n        if as_symbols:\n            maps = self._internal_debugger.debugging_interface.maps()\n            backtrace = [resolve_address_in_maps(x, maps) for x in backtrace]\n        return backtrace\n\n    def print_backtrace(self: ThreadContext) -&gt; None:\n        \"\"\"Prints the current backtrace of the thread.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n        backtrace = stack_unwinder.unwind(self)\n        maps = self._internal_debugger.debugging_interface.maps()\n        for return_address in backtrace:\n            return_address_symbol = resolve_address_in_maps(return_address, maps)\n            if return_address_symbol[:2] == \"0x\":\n                print(f\"{PrintStyle.RED}{return_address:#x} {PrintStyle.RESET}\")\n            else:\n                print(f\"{PrintStyle.RED}{return_address:#x} &lt;{return_address_symbol}&gt; {PrintStyle.RESET}\")\n\n    @property\n    def saved_ip(self: ThreadContext) -&gt; int:\n        \"\"\"The return address of the current function.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n\n        try:\n            return_address = stack_unwinder.get_return_address(self, self._internal_debugger.debugging_interface.maps())\n        except (OSError, ValueError) as e:\n            raise ValueError(\n                \"Failed to get the return address. Check stack frame registers (e.g., base pointer).\",\n            ) from e\n\n        return return_address\n\n    def step(self: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\"\"\"\n        self._internal_debugger.step(self)\n\n    def step_until(\n        self: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Executes instructions of the process until the specified location is reached.\n\n        Args:\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n            (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n            the \"binary\" map file).\n        \"\"\"\n        self._internal_debugger.step_until(self, position, max_steps, file)\n\n    def finish(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self._internal_debugger.finish(self, heuristic=heuristic)\n\n    def next(self: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._internal_debugger.next(self)\n\n    def si(self: ThreadContext) -&gt; None:\n        \"\"\"Alias for the `step` method.\n\n        Executes a single instruction of the process.\n        \"\"\"\n        self._internal_debugger.step(self)\n\n    def su(\n        self: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n    ) -&gt; None:\n        \"\"\"Alias for the `step_until` method.\n\n        Executes instructions of the process until the specified location is reached.\n\n        Args:\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        \"\"\"\n        self._internal_debugger.step_until(self, position, max_steps)\n\n    def fin(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Alias for the `finish` method. Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self._internal_debugger.finish(self, heuristic)\n\n    def ni(self: ThreadContext) -&gt; None:\n        \"\"\"Alias for the `next` method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._internal_debugger.next(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.dead","title":"<code>dead: bool</code>  <code>property</code>","text":"<p>Whether the thread is dead.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.exit_code","title":"<code>exit_code: int | None</code>  <code>property</code>","text":"<p>The thread's exit code.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.exit_signal","title":"<code>exit_signal: str | None</code>  <code>property</code>","text":"<p>The thread's exit signal.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.instruction_pointer","title":"<code>instruction_pointer: int</code>  <code>instance-attribute</code>","text":"<p>The thread's instruction pointer.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.mem","title":"<code>mem: AbstractMemoryView</code>  <code>property</code>","text":"<p>Alias for the <code>memory</code> property.</p> <p>Get the memory view of the process.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.memory","title":"<code>memory: AbstractMemoryView</code>  <code>property</code>","text":"<p>The memory view of the debugged process.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.pid","title":"<code>pid: int</code>  <code>property</code>","text":"<p>The process ID of the thread.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.process_id","title":"<code>process_id: int</code>  <code>property</code>","text":"<p>The process ID of the thread.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.regs","title":"<code>regs: Registers = regs_class(thread_id)</code>  <code>instance-attribute</code>","text":"<p>The thread's registers.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Whether the process is running.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.saved_ip","title":"<code>saved_ip: int</code>  <code>property</code>","text":"<p>The return address of the current function.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.signal","title":"<code>signal: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>The signal will be forwarded to the thread.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg0","title":"<code>syscall_arg0: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 0.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg1","title":"<code>syscall_arg1: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 1.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg2","title":"<code>syscall_arg2: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 2.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg3","title":"<code>syscall_arg3: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 3.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg4","title":"<code>syscall_arg4: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 4.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg5","title":"<code>syscall_arg5: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 5.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_number","title":"<code>syscall_number: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall number.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_return","title":"<code>syscall_return: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall return value.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.thread_id","title":"<code>thread_id: int</code>  <code>property</code>","text":"<p>The thread ID.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.tid","title":"<code>tid: int</code>  <code>property</code>","text":"<p>The thread ID.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.__init__","title":"<code>__init__(thread_id, registers)</code>","text":"<p>Initializes the Thread Context.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def __init__(self: ThreadContext, thread_id: int, registers: RegisterHolder) -&gt; None:\n    \"\"\"Initializes the Thread Context.\"\"\"\n    self._internal_debugger = provide_internal_debugger(self)\n    self._thread_id = thread_id\n    regs_class = registers.provide_regs_class()\n    self.regs = regs_class(thread_id)\n    registers.apply_on_regs(self.regs, regs_class)\n    registers.apply_on_thread(self, ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.backtrace","title":"<code>backtrace(as_symbols=False)</code>","text":"<p>Returns the current backtrace of the thread.</p> <p>Parameters:</p> Name Type Description Default <code>as_symbols</code> <code>bool</code> <p>Whether to return the backtrace as symbols</p> <code>False</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def backtrace(self: ThreadContext, as_symbols: bool = False) -&gt; list:\n    \"\"\"Returns the current backtrace of the thread.\n\n    Args:\n        as_symbols (bool, optional): Whether to return the backtrace as symbols\n    \"\"\"\n    self._internal_debugger._ensure_process_stopped()\n    stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n    backtrace = stack_unwinder.unwind(self)\n    if as_symbols:\n        maps = self._internal_debugger.debugging_interface.maps()\n        backtrace = [resolve_address_in_maps(x, maps) for x in backtrace]\n    return backtrace\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.fin","title":"<code>fin(heuristic='backtrace')</code>","text":"<p>Alias for the <code>finish</code> method. Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def fin(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Alias for the `finish` method. Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self._internal_debugger.finish(self, heuristic)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.finish","title":"<code>finish(heuristic='backtrace')</code>","text":"<p>Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def finish(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self._internal_debugger.finish(self, heuristic=heuristic)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.next","title":"<code>next()</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def next(self: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._internal_debugger.next(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.ni","title":"<code>ni()</code>","text":"<p>Alias for the <code>next</code> method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def ni(self: ThreadContext) -&gt; None:\n    \"\"\"Alias for the `next` method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._internal_debugger.next(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.print_backtrace","title":"<code>print_backtrace()</code>","text":"<p>Prints the current backtrace of the thread.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def print_backtrace(self: ThreadContext) -&gt; None:\n    \"\"\"Prints the current backtrace of the thread.\"\"\"\n    self._internal_debugger._ensure_process_stopped()\n    stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n    backtrace = stack_unwinder.unwind(self)\n    maps = self._internal_debugger.debugging_interface.maps()\n    for return_address in backtrace:\n        return_address_symbol = resolve_address_in_maps(return_address, maps)\n        if return_address_symbol[:2] == \"0x\":\n            print(f\"{PrintStyle.RED}{return_address:#x} {PrintStyle.RESET}\")\n        else:\n            print(f\"{PrintStyle.RED}{return_address:#x} &lt;{return_address_symbol}&gt; {PrintStyle.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.set_as_dead","title":"<code>set_as_dead()</code>","text":"<p>Set the thread as dead.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def set_as_dead(self: ThreadContext) -&gt; None:\n    \"\"\"Set the thread as dead.\"\"\"\n    self._dead = True\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.si","title":"<code>si()</code>","text":"<p>Alias for the <code>step</code> method.</p> <p>Executes a single instruction of the process.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def si(self: ThreadContext) -&gt; None:\n    \"\"\"Alias for the `step` method.\n\n    Executes a single instruction of the process.\n    \"\"\"\n    self._internal_debugger.step(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.step","title":"<code>step()</code>","text":"<p>Executes a single instruction of the process.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def step(self: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the process.\"\"\"\n    self._internal_debugger.step(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.step_until","title":"<code>step_until(position, max_steps=-1, file='hybrid')</code>","text":"<p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\"</p> <code>'hybrid'</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def step_until(\n    self: ThreadContext,\n    position: int | str,\n    max_steps: int = -1,\n    file: str = \"hybrid\",\n) -&gt; None:\n    \"\"\"Executes instructions of the process until the specified location is reached.\n\n    Args:\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\"\n        (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t.\n        the \"binary\" map file).\n    \"\"\"\n    self._internal_debugger.step_until(self, position, max_steps, file)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.su","title":"<code>su(position, max_steps=-1)</code>","text":"<p>Alias for the <code>step_until</code> method.</p> <p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def su(\n    self: ThreadContext,\n    position: int | str,\n    max_steps: int = -1,\n) -&gt; None:\n    \"\"\"Alias for the `step_until` method.\n\n    Executes instructions of the process until the specified location is reached.\n\n    Args:\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n    \"\"\"\n    self._internal_debugger.step_until(self, position, max_steps)\n</code></pre>"},{"location":"from_pydoc/generated/utils/arch_mappings/","title":"libdebug.utils.arch_mappings","text":""},{"location":"from_pydoc/generated/utils/arch_mappings/#libdebug.utils.arch_mappings.map_arch","title":"<code>map_arch(arch)</code>","text":"<p>Map the architecture to the correct format.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>str</code> <p>the architecture to map.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the mapped architecture.</p> Source code in <code>libdebug/utils/arch_mappings.py</code> <pre><code>def map_arch(arch: str) -&gt; str:\n    \"\"\"Map the architecture to the correct format.\n\n    Args:\n        arch (str): the architecture to map.\n\n    Returns:\n        str: the mapped architecture.\n    \"\"\"\n    arch = arch.lower()\n\n    if arch in ARCH_MAPPING.values():\n        return arch\n    elif arch in ARCH_MAPPING:\n        return ARCH_MAPPING[arch]\n    else:\n        raise ValueError(f\"Architecture {arch} not supported.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugger_wrappers/","title":"libdebug.utils.debugger_wrappers","text":""},{"location":"from_pydoc/generated/utils/debugger_wrappers/#libdebug.utils.debugger_wrappers.background_alias","title":"<code>background_alias(alias_method)</code>","text":"<p>Decorator that automatically resolves the call to a different method if coming from the background thread.</p> Source code in <code>libdebug/utils/debugger_wrappers.py</code> <pre><code>def background_alias(alias_method: callable) -&gt; callable:\n    \"\"\"Decorator that automatically resolves the call to a different method if coming from the background thread.\"\"\"\n\n    # This is the stupidest thing I've ever seen. Why Python, why?\n    def _background_alias(method: callable) -&gt; callable:\n        @wraps(method)\n        def inner(self: InternalDebugger, *args: ..., **kwargs: ...) -&gt; ...:\n            if self._is_in_background():\n                return alias_method(self, *args, **kwargs)\n            return method(self, *args, **kwargs)\n\n        return inner\n\n    return _background_alias\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugger_wrappers/#libdebug.utils.debugger_wrappers.change_state_function_process","title":"<code>change_state_function_process(method)</code>","text":"<p>Decorator to perfom control flow checks before executing a method.</p> Source code in <code>libdebug/utils/debugger_wrappers.py</code> <pre><code>def change_state_function_process(method: callable) -&gt; callable:\n    \"\"\"Decorator to perfom control flow checks before executing a method.\"\"\"\n\n    @wraps(method)\n    def wrapper(self: InternalDebugger, *args: ..., **kwargs: ...) -&gt; ...:\n        if not self.instanced:\n            raise RuntimeError(\n                \"Process not running. Did you call run()?\",\n            )\n\n        # We have to ensure that the process is stopped before executing the method\n        self._ensure_process_stopped()\n\n        # We have to ensure that at least one thread is alive before executing the method\n        if self.threads[0].dead:\n            raise RuntimeError(\"All threads are dead.\")\n        return method(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugger_wrappers/#libdebug.utils.debugger_wrappers.change_state_function_thread","title":"<code>change_state_function_thread(method)</code>","text":"<p>Decorator to perfom control flow checks before executing a method.</p> Source code in <code>libdebug/utils/debugger_wrappers.py</code> <pre><code>def change_state_function_thread(method: callable) -&gt; callable:\n    \"\"\"Decorator to perfom control flow checks before executing a method.\"\"\"\n\n    @wraps(method)\n    def wrapper(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        *args: ...,\n        **kwargs: ...,\n    ) -&gt; ...:\n        if not self.instanced:\n            raise RuntimeError(\n                \"Process not running. Did you call run()?\",\n            )\n\n        # We have to ensure that the process is stopped before executing the method\n        self._ensure_process_stopped()\n\n        # We have to ensure that at least one thread is alive before executing the method\n        if thread.dead:\n            raise RuntimeError(\"The threads is dead.\")\n        return method(self, thread, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugging_utils/","title":"libdebug.utils.debugging_utils","text":""},{"location":"from_pydoc/generated/utils/debugging_utils/#libdebug.utils.debugging_utils.check_absolute_address","title":"<code>check_absolute_address(address, maps)</code>","text":"<p>Checks if the specified address is an absolute address.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the specified address is an absolute address, False otherwise.</p> Source code in <code>libdebug/utils/debugging_utils.py</code> <pre><code>def check_absolute_address(address: int, maps: list[MemoryMap]) -&gt; bool:\n    \"\"\"Checks if the specified address is an absolute address.\n\n    Returns:\n        bool: True if the specified address is an absolute address, False otherwise.\n    \"\"\"\n    return any(vmap.start &lt;= address &lt; vmap.end for vmap in maps)\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugging_utils/#libdebug.utils.debugging_utils.normalize_and_validate_address","title":"<code>normalize_and_validate_address(address, maps)</code>","text":"<p>Normalizes and validates the specified address.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The normalized address.</p> Throws <p>ValueError: If the specified address does not belong to any memory map.</p> Source code in <code>libdebug/utils/debugging_utils.py</code> <pre><code>def normalize_and_validate_address(address: int, maps: list[MemoryMap]) -&gt; int:\n    \"\"\"Normalizes and validates the specified address.\n\n    Returns:\n        int: The normalized address.\n\n    Throws:\n        ValueError: If the specified address does not belong to any memory map.\n    \"\"\"\n    if address &lt; maps[0].start:\n        # The address is lower than the base address of the lowest map. Suppose it is a relative address for a PIE binary.\n        address += maps[0].start\n\n    for vmap in maps:\n        if vmap.start &lt;= address &lt; vmap.end:\n            return address\n\n    raise ValueError(f\"Address {hex(address)} does not belong to any memory map.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugging_utils/#libdebug.utils.debugging_utils.resolve_address_in_maps","title":"<code>resolve_address_in_maps(address, maps)</code>","text":"<p>Returns the symbol corresponding to the specified address in the specified memory maps.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address whose symbol should be returned.</p> required <code>maps</code> <code>list[MemoryMap]</code> <p>The memory maps.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The symbol corresponding to the specified address in the specified memory maps.</p> Throws <p>ValueError: If the specified address does not belong to any memory map.</p> Source code in <code>libdebug/utils/debugging_utils.py</code> <pre><code>def resolve_address_in_maps(address: int, maps: list[MemoryMap]) -&gt; str:\n    \"\"\"Returns the symbol corresponding to the specified address in the specified memory maps.\n\n    Args:\n        address (int): The address whose symbol should be returned.\n        maps (list[MemoryMap]): The memory maps.\n\n    Returns:\n        str: The symbol corresponding to the specified address in the specified memory maps.\n\n    Throws:\n        ValueError: If the specified address does not belong to any memory map.\n    \"\"\"\n    mapped_files = {}\n\n    for vmap in maps:\n        file = vmap.backing_file\n        if not file or file[0] == \"[\":\n            continue\n\n        if file not in mapped_files:\n            mapped_files[file] = (vmap.start, vmap.end)\n        else:\n            mapped_files[file] = (mapped_files[file][0], vmap.end)\n\n    for file, (base_address, top_address) in mapped_files.items():\n        # Check if the address is in the range of the current section\n        if address &lt; base_address or address &gt;= top_address:\n            continue\n\n        try:\n            return resolve_address(file, address - base_address) if is_pie(file) else resolve_address(file, address)\n        except OSError as e:\n            liblog.debugger(f\"Error while resolving address {hex(address)} in {file}: {e}\")\n        except ValueError:\n            pass\n\n    return hex(address)\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugging_utils/#libdebug.utils.debugging_utils.resolve_symbol_in_maps","title":"<code>resolve_symbol_in_maps(symbol, maps)</code>","text":"<p>Returns the address of the specified symbol in the specified memory maps.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol whose address should be returned.</p> required <code>maps</code> <code>list[MemoryMap]</code> <p>The memory maps.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The address of the specified symbol in the specified memory maps.</p> Throws <p>ValueError: If the specified symbol does not belong to any memory map.</p> Source code in <code>libdebug/utils/debugging_utils.py</code> <pre><code>def resolve_symbol_in_maps(symbol: str, maps: list[MemoryMap]) -&gt; int:\n    \"\"\"Returns the address of the specified symbol in the specified memory maps.\n\n    Args:\n        symbol (str): The symbol whose address should be returned.\n        maps (list[MemoryMap]): The memory maps.\n\n    Returns:\n        int: The address of the specified symbol in the specified memory maps.\n\n    Throws:\n        ValueError: If the specified symbol does not belong to any memory map.\n    \"\"\"\n    mapped_files = {}\n\n    if \"+\" in symbol:\n        symbol, offset_str = symbol.split(\"+\")\n        offset = int(offset_str, 16)\n    else:\n        offset = 0\n\n    for vmap in maps:\n        if vmap.backing_file and vmap.backing_file not in mapped_files and vmap.backing_file[0] != \"[\":\n            mapped_files[vmap.backing_file] = vmap.start\n\n    for file, base_address in mapped_files.items():\n        try:\n            address = resolve_symbol(file, symbol)\n\n            if is_pie(file):\n                address += base_address\n\n            return address + offset\n        except OSError as e:\n            liblog.debugger(f\"Error while resolving symbol {symbol} in {file}: {e}\")\n        except ValueError:\n            pass\n\n    raise ValueError(f\"Symbol {symbol} not found in the specified mapped file. Please specify a valid symbol.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/","title":"libdebug.utils.elf_utils","text":""},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.elf_architecture","title":"<code>elf_architecture(path)</code>","text":"<p>Returns the architecture of the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The architecture of the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def elf_architecture(path: str) -&gt; str:\n    \"\"\"Returns the architecture of the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        str: The architecture of the specified ELF file.\n    \"\"\"\n    return parse_elf_characteristics(path)[2]\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.get_entry_point","title":"<code>get_entry_point(path)</code>","text":"<p>Returns the entry point of the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The entry point of the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def get_entry_point(path: str) -&gt; int:\n    \"\"\"Returns the entry point of the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        int: The entry point of the specified ELF file.\n    \"\"\"\n    return parse_elf_characteristics(path)[1]\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.is_pie","title":"<code>is_pie(path)</code>","text":"<p>Returns True if the specified ELF file is position independent, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the specified ELF file is position independent, False otherwise.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def is_pie(path: str) -&gt; bool:\n    \"\"\"Returns True if the specified ELF file is position independent, False otherwise.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        bool: True if the specified ELF file is position independent, False otherwise.\n    \"\"\"\n    return parse_elf_characteristics(path)[0]\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.parse_elf_characteristics","title":"<code>parse_elf_characteristics(path)</code>  <code>cached</code>","text":"<p>Returns a tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[bool, int, str]</code> <p>A tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>@functools.cache\ndef parse_elf_characteristics(path: str) -&gt; tuple[bool, int, str]:\n    \"\"\"Returns a tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        tuple: A tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.\n    \"\"\"\n    with Path(path).open(\"rb\") as elf_file:\n        elf = ELFFile(elf_file)\n\n    pie = elf.header.e_type == \"ET_DYN\"\n    entry_point = elf.header.e_entry\n    arch = elf.get_machine_arch()\n\n    return pie, entry_point, arch\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.resolve_address","title":"<code>resolve_address(path, address)</code>  <code>cached</code>","text":"<p>Returns the symbol corresponding to the specified address in the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <code>address</code> <code>int</code> <p>The address whose symbol should be returned.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The symbol corresponding to the specified address in the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>@functools.cache\ndef resolve_address(path: str, address: int) -&gt; str:\n    \"\"\"Returns the symbol corresponding to the specified address in the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n        address (int): The address whose symbol should be returned.\n\n    Returns:\n        str: The symbol corresponding to the specified address in the specified ELF file.\n    \"\"\"\n    if libcontext.sym_lvl == 0:\n        return hex(address)\n\n    # Retrieve the symbols from the SymbolTableSection\n    symbols, buildid, debug_file = _parse_elf_file(path, libcontext.sym_lvl)\n    for symbol, (symbol_start, symbol_end) in symbols.items():\n        if symbol_start &lt;= address &lt; symbol_end:\n            return f\"{symbol}+{address-symbol_start:x}\"\n\n    # Retrieve the symbols from the external debuginfo file\n    if buildid and debug_file and libcontext.sym_lvl &gt; 2:\n        folder = buildid[:2]\n        absolute_debug_path_str = str((LOCAL_DEBUG_PATH / folder / debug_file).resolve())\n        symbols = _collect_external_info(absolute_debug_path_str)\n        for symbol, (symbol_start, symbol_end) in symbols.items():\n            if symbol_start &lt;= address &lt; symbol_end:\n                return f\"{symbol}+{address-symbol_start:x}\"\n\n    # Retrieve the symbols from debuginfod\n    if buildid and libcontext.sym_lvl &gt; 4:\n        absolute_debug_path = _debuginfod(buildid)\n        if absolute_debug_path.exists():\n            symbols = _collect_external_info(str(absolute_debug_path))\n            for symbol, (symbol_start, symbol_end) in symbols.items():\n                if symbol_start &lt;= address &lt; symbol_end:\n                    return f\"{symbol}+{address-symbol_start:x}\"\n\n    # Address not found\n    raise ValueError(f\"Address {hex(address)} not found in {path}. Please specify a valid address.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.resolve_symbol","title":"<code>resolve_symbol(path, symbol)</code>  <code>cached</code>","text":"<p>Returns the address of the specified symbol in the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <code>symbol</code> <code>str</code> <p>The symbol whose address should be returned.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The address of the specified symbol in the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>@functools.cache\ndef resolve_symbol(path: str, symbol: str) -&gt; int:\n    \"\"\"Returns the address of the specified symbol in the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n        symbol (str): The symbol whose address should be returned.\n\n    Returns:\n        int: The address of the specified symbol in the specified ELF file.\n    \"\"\"\n    if libcontext.sym_lvl == 0:\n        raise Exception(\n            \"Symbol resolution is disabled. Please enable it by setting the sym_lvl libcontext parameter to a value greater than 0.\",\n        )\n\n    # Retrieve the symbols from the SymbolTableSection\n    symbols, buildid, debug_file = _parse_elf_file(path, libcontext.sym_lvl)\n    if symbol in symbols:\n        return symbols[symbol][0]\n\n    # Retrieve the symbols from the external debuginfo file\n    if buildid and debug_file and libcontext.sym_lvl &gt; 2:\n        folder = buildid[:2]\n        absolute_debug_path_str = str((LOCAL_DEBUG_PATH / folder / debug_file).resolve())\n        symbols = _collect_external_info(absolute_debug_path_str)\n        if symbol in symbols:\n            return symbols[symbol][0]\n\n    # Retrieve the symbols from debuginfod\n    if buildid and libcontext.sym_lvl &gt; 4:\n        absolute_debug_path = _debuginfod(buildid)\n        if absolute_debug_path.exists():\n            symbols = _collect_external_info(str(absolute_debug_path))\n            if symbol in symbols:\n                return symbols[symbol][0]\n\n    # Symbol not found\n    raise ValueError(f\"Symbol {symbol} not found in {path}. Please specify a valid symbol.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/gdb/","title":"libdebug.utils.gdb","text":""},{"location":"from_pydoc/generated/utils/gdb/#libdebug.utils.gdb.GoBack","title":"<code>GoBack</code>","text":"<p>               Bases: <code>Command</code></p> <p>This extension adds a new command to GDB that allows to detach from the current process and quit GDB.</p> Source code in <code>libdebug/utils/gdb.py</code> <pre><code>class GoBack(gdb.Command):\n    \"\"\"This extension adds a new command to GDB that allows to detach from the current process and quit GDB.\"\"\"\n\n    def __init__(self: GoBack) -&gt; None:\n        \"\"\"Initializes the GoBack command.\"\"\"\n        super().__init__(\"goback\", gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, True)\n\n    def invoke(self: GoBack, _: ..., __: bool) -&gt; None:\n        \"\"\"Detaches and quits from GDB on invocation.\"\"\"\n        gdb.execute(\"detach\")\n        gdb.execute(\"quit\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/gdb/#libdebug.utils.gdb.GoBack.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the GoBack command.</p> Source code in <code>libdebug/utils/gdb.py</code> <pre><code>def __init__(self: GoBack) -&gt; None:\n    \"\"\"Initializes the GoBack command.\"\"\"\n    super().__init__(\"goback\", gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, True)\n</code></pre>"},{"location":"from_pydoc/generated/utils/gdb/#libdebug.utils.gdb.GoBack.invoke","title":"<code>invoke(_, __)</code>","text":"<p>Detaches and quits from GDB on invocation.</p> Source code in <code>libdebug/utils/gdb.py</code> <pre><code>def invoke(self: GoBack, _: ..., __: bool) -&gt; None:\n    \"\"\"Detaches and quits from GDB on invocation.\"\"\"\n    gdb.execute(\"detach\")\n    gdb.execute(\"quit\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/","title":"libdebug.utils.libcontext","text":""},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext","title":"<code>LibContext</code>","text":"<p>A class that holds the global context of the library.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>class LibContext:\n    \"\"\"A class that holds the global context of the library.\"\"\"\n\n    _instance = None\n    _pipe_logger_levels: list[str]\n    _debugger_logger_levels: list[str]\n    _general_logger_levels: list[str]\n\n    def __new__(cls: type):\n        \"\"\"Create a new instance of the class if it does not exist yet.\n\n        Returns:\n            LibContext: the instance of the class.\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self: LibContext) -&gt; None:\n        \"\"\"Initializes the context.\"\"\"\n        if self._initialized:\n            return\n\n        self._pipe_logger_levels = [\"DEBUG\", \"SILENT\"]\n        self._debugger_logger_levels = [\"DEBUG\", \"SILENT\"]\n        self._general_logger_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"SILENT\"]\n        self._sym_lvl = 3\n\n        self._debugger_logger = \"SILENT\"\n        self._pipe_logger = \"SILENT\"\n        self._general_logger = \"INFO\"\n\n        # Adjust log levels based on command-line arguments\n        if len(sys.argv) &gt; 1:\n            if \"debugger\" in sys.argv:\n                liblog.debugger_logger.setLevel(\"DEBUG\")\n                self._debugger_logger = \"DEBUG\"\n            elif \"pipe\" in sys.argv:\n                liblog.pipe_logger.setLevel(\"DEBUG\")\n                self._pipe_logger = \"DEBUG\"\n            elif \"dbg\" in sys.argv:\n                self._set_debug_level_for_all()\n                self._debugger_logger = \"DEBUG\"\n                self._pipe_logger = \"DEBUG\"\n                self._general_logger = \"DEBUG\"\n        self._initialized = True\n\n        self._terminal = []\n\n    def _set_debug_level_for_all(self: LibContext) -&gt; None:\n        \"\"\"Set the debug level for all the loggers to DEBUG.\"\"\"\n        for logger in [\n            liblog.general_logger,\n            liblog.debugger_logger,\n            liblog.pipe_logger,\n        ]:\n            logger.setLevel(\"DEBUG\")\n\n    @property\n    def sym_lvl(self: LibContext) -&gt; int:\n        \"\"\"Property getter for sym_lvl.\n\n        Returns:\n            _sym_lvl (int): the current symbol level.\n        \"\"\"\n        return self._sym_lvl\n\n    @sym_lvl.setter\n    def sym_lvl(self: LibContext, value: int) -&gt; None:\n        \"\"\"Property setter for sym_lvl, ensuring it's between 0 and 5.\"\"\"\n        if 0 &lt;= value &lt;= 5:\n            self._sym_lvl = value\n        else:\n            raise ValueError(\"sym_lvl must be between 0 and 5\")\n\n    @property\n    def debugger_logger(self: LibContext) -&gt; str:\n        \"\"\"Property getter for debugger_logger.\n\n        Returns:\n            _debugger_logger (str): the current debugger logger level.\n        \"\"\"\n        return self._debugger_logger\n\n    @debugger_logger.setter\n    def debugger_logger(self: LibContext, value: str) -&gt; None:\n        \"\"\"Property setter for debugger_logger, ensuring it's a supported logging level.\"\"\"\n        if value in self._debugger_logger_levels:\n            self._debugger_logger = value\n            liblog.debugger_logger.setLevel(value)\n        else:\n            raise ValueError(\n                f\"debugger_logger must be a supported logging level. The supported levels are: {self._debugger_logger_levels}\",\n            )\n\n    @property\n    def pipe_logger(self: LibContext) -&gt; str:\n        \"\"\"Property getter for pipe_logger.\n\n        Returns:\n            _pipe_logger (str): the current pipe logger level.\n        \"\"\"\n        return self._pipe_logger\n\n    @pipe_logger.setter\n    def pipe_logger(self: LibContext, value: str) -&gt; None:\n        \"\"\"Property setter for pipe_logger, ensuring it's a supported logging level.\"\"\"\n        if value in self._pipe_logger_levels:\n            self._pipe_logger = value\n            liblog.pipe_logger.setLevel(value)\n        else:\n            raise ValueError(\n                f\"pipe_logger must be a supported logging level. The supported levels are: {self._pipe_logger_levels}\",\n            )\n\n    @property\n    def general_logger(self: LibContext) -&gt; str:\n        \"\"\"Property getter for general_logger.\n\n        Returns:\n            _general_logger (str): the current general logger level.\n        \"\"\"\n        return self._general_logger\n\n    @general_logger.setter\n    def general_logger(self: LibContext, value: str) -&gt; None:\n        \"\"\"Property setter for general_logger, ensuring it's a supported logging level.\"\"\"\n        if value in self._general_logger_levels:\n            self._general_logger = value\n            liblog.general_logger.setLevel(value)\n        else:\n            raise ValueError(\n                f\"general_logger must be a supported logging level. The supported levels are: {self._general_logger_levels}\",\n            )\n\n    @property\n    def platform(self: LibContext) -&gt; str:\n        \"\"\"Return the current platform.\"\"\"\n        return map_arch(platform.machine())\n\n    @property\n    def terminal(self: LibContext) -&gt; list[str]:\n        \"\"\"Property getter for terminal.\n\n        Returns:\n            _terminal (str): the current terminal.\n        \"\"\"\n        return self._terminal\n\n    @terminal.setter\n    def terminal(self: LibContext, value: list[str] | str) -&gt; None:\n        \"\"\"Property setter for terminal, ensuring it's a valid terminal.\"\"\"\n        if isinstance(value, str):\n            value = [value]\n\n        self._terminal = value\n\n    def update(self: LibContext, **kwargs: ...) -&gt; None:\n        \"\"\"Update the context with the given values.\"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n\n    @contextmanager\n    def tmp(self: LibContext, **kwargs: ...) -&gt; ...:\n        \"\"\"Context manager that temporarily changes the library context. Use \"with\" statement.\"\"\"\n        # Make a deep copy of the current state\n        old_context = deepcopy(self.__dict__)\n        self.update(**kwargs)\n        try:\n            yield\n        finally:\n            # Restore the original state\n            self.__dict__.update(old_context)\n            liblog.debugger_logger.setLevel(self.debugger_logger)\n            liblog.pipe_logger.setLevel(self.pipe_logger)\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.debugger_logger","title":"<code>debugger_logger: str</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for debugger_logger.</p> <p>Returns:</p> Name Type Description <code>_debugger_logger</code> <code>str</code> <p>the current debugger logger level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.general_logger","title":"<code>general_logger: str</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for general_logger.</p> <p>Returns:</p> Name Type Description <code>_general_logger</code> <code>str</code> <p>the current general logger level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.pipe_logger","title":"<code>pipe_logger: str</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for pipe_logger.</p> <p>Returns:</p> Name Type Description <code>_pipe_logger</code> <code>str</code> <p>the current pipe logger level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.platform","title":"<code>platform: str</code>  <code>property</code>","text":"<p>Return the current platform.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.sym_lvl","title":"<code>sym_lvl: int</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for sym_lvl.</p> <p>Returns:</p> Name Type Description <code>_sym_lvl</code> <code>int</code> <p>the current symbol level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.terminal","title":"<code>terminal: list[str]</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for terminal.</p> <p>Returns:</p> Name Type Description <code>_terminal</code> <code>str</code> <p>the current terminal.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the context.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>def __init__(self: LibContext) -&gt; None:\n    \"\"\"Initializes the context.\"\"\"\n    if self._initialized:\n        return\n\n    self._pipe_logger_levels = [\"DEBUG\", \"SILENT\"]\n    self._debugger_logger_levels = [\"DEBUG\", \"SILENT\"]\n    self._general_logger_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"SILENT\"]\n    self._sym_lvl = 3\n\n    self._debugger_logger = \"SILENT\"\n    self._pipe_logger = \"SILENT\"\n    self._general_logger = \"INFO\"\n\n    # Adjust log levels based on command-line arguments\n    if len(sys.argv) &gt; 1:\n        if \"debugger\" in sys.argv:\n            liblog.debugger_logger.setLevel(\"DEBUG\")\n            self._debugger_logger = \"DEBUG\"\n        elif \"pipe\" in sys.argv:\n            liblog.pipe_logger.setLevel(\"DEBUG\")\n            self._pipe_logger = \"DEBUG\"\n        elif \"dbg\" in sys.argv:\n            self._set_debug_level_for_all()\n            self._debugger_logger = \"DEBUG\"\n            self._pipe_logger = \"DEBUG\"\n            self._general_logger = \"DEBUG\"\n    self._initialized = True\n\n    self._terminal = []\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.__new__","title":"<code>__new__()</code>","text":"<p>Create a new instance of the class if it does not exist yet.</p> <p>Returns:</p> Name Type Description <code>LibContext</code> <p>the instance of the class.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>def __new__(cls: type):\n    \"\"\"Create a new instance of the class if it does not exist yet.\n\n    Returns:\n        LibContext: the instance of the class.\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.tmp","title":"<code>tmp(**kwargs)</code>","text":"<p>Context manager that temporarily changes the library context. Use \"with\" statement.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>@contextmanager\ndef tmp(self: LibContext, **kwargs: ...) -&gt; ...:\n    \"\"\"Context manager that temporarily changes the library context. Use \"with\" statement.\"\"\"\n    # Make a deep copy of the current state\n    old_context = deepcopy(self.__dict__)\n    self.update(**kwargs)\n    try:\n        yield\n    finally:\n        # Restore the original state\n        self.__dict__.update(old_context)\n        liblog.debugger_logger.setLevel(self.debugger_logger)\n        liblog.pipe_logger.setLevel(self.pipe_logger)\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.update","title":"<code>update(**kwargs)</code>","text":"<p>Update the context with the given values.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>def update(self: LibContext, **kwargs: ...) -&gt; None:\n    \"\"\"Update the context with the given values.\"\"\"\n    for key, value in kwargs.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/","title":"libdebug.utils.pipe_manager","text":""},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager","title":"<code>PipeManager</code>","text":"<p>Class for managing pipes of the child process.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>class PipeManager:\n    \"\"\"Class for managing pipes of the child process.\"\"\"\n\n    _instance = None\n    timeout_default: int = 2\n\n    def __init__(self: PipeManager, stdin_write: int, stdout_read: int, stderr_read: int) -&gt; None:\n        \"\"\"Initializes the PipeManager class.\n\n        Args:\n            stdin_write (int): file descriptor for stdin write.\n            stdout_read (int): file descriptor for stdout read.\n            stderr_read (int): file descriptor for stderr read.\n        \"\"\"\n        self.stdin_write: int = stdin_write\n        self.stdout_read: int = stdout_read\n        self.stderr_read: int = stderr_read\n\n    def _recv(\n        self: PipeManager,\n        numb: int | None = None,\n        timeout: float = timeout_default,\n        stderr: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives at most numb bytes from the child process.\n\n        Args:\n            numb (int, optional): number of bytes to receive. Defaults to None.\n            timeout (float, optional): timeout in seconds. Defaults to timeout_default.\n            stderr (bool, optional): receive from stderr. Defaults to False.\n\n        Returns:\n            bytes: received bytes from the child process stdout.\n\n        Raises:\n            ValueError: numb is negative.\n            RuntimeError: no stdout pipe of the child process.\n        \"\"\"\n        pipe_read: int = self.stderr_read if stderr else self.stdout_read\n\n        if not pipe_read:\n            raise RuntimeError(\"No pipe of the child process\")\n\n        # Buffer for the received data\n        data_buffer = b\"\"\n\n        if numb:\n            # Checking the numb\n            if numb &lt; 0:\n                raise ValueError(\"The number of bytes to receive must be positive\")\n\n            # Setting the alarm\n            end_time = time.time() + timeout\n            while numb &gt; 0:\n                if end_time is not None and time.time() &gt; end_time:\n                    # Timeout reached\n                    break\n\n                # Adjust the timeout for select to the remaining time\n                remaining_time = None if end_time is None else max(0, end_time - time.time())\n                ready, _, _ = select([pipe_read], [], [], remaining_time)\n\n                if not ready:\n                    # No data ready within the remaining timeout\n                    break\n\n                try:\n                    data = os.read(pipe_read, numb)\n                except OSError as e:\n                    raise RuntimeError(\"Broken pipe. Is the child process still running?\") from e\n\n                if not data:\n                    # No more data available\n                    break\n\n                numb -= len(data)\n                data_buffer += data\n        else:\n            ready, _, _ = select([pipe_read], [], [], timeout)\n\n            if ready:\n                # Read all available bytes up to 4096\n                data = os.read(pipe_read, 4096)\n                data_buffer += data\n\n        liblog.pipe(f\"Received {len(data_buffer)} bytes from the child process: {data_buffer!r}\")\n        return data_buffer\n\n    def close(self: PipeManager) -&gt; None:\n        \"\"\"Closes all the pipes of the child process.\"\"\"\n        os.close(self.stdin_write)\n        os.close(self.stdout_read)\n        os.close(self.stderr_read)\n\n    def recv(self: PipeManager, numb: int | None = None, timeout: int = timeout_default) -&gt; bytes:\n        \"\"\"Receives at most numb bytes from the child process stdout.\n\n        Args:\n            numb (int, optional): number of bytes to receive. Defaults to None.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received bytes from the child process stdout.\n        \"\"\"\n        return self._recv(numb=numb, timeout=timeout, stderr=False)\n\n    def recverr(self: PipeManager, numb: int | None = None, timeout: int = timeout_default) -&gt; bytes:\n        \"\"\"Receives at most numb bytes from the child process stderr.\n\n        Args:\n            numb (int, optional): number of bytes to receive. Defaults to None.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received bytes from the child process stderr.\n        \"\"\"\n        return self._recv(numb=numb, timeout=timeout, stderr=True)\n\n    def _recvonceuntil(\n        self: PipeManager,\n        delims: bytes,\n        drop: bool = False,\n        timeout: float = timeout_default,\n        stderr: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process until the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (float, optional): timeout in seconds. Defaults to timeout_default.\n            stderr (bool, optional): receive from stderr. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stdout.\n\n        Raises:\n            RuntimeError: no stdout pipe of the child process.\n            TimeoutError: timeout reached.\n        \"\"\"\n        if isinstance(delims, str):\n            liblog.warning(\"The delimiters are a string, converting to bytes\")\n            delims = delims.encode()\n\n        # Buffer for the received data\n        data_buffer = b\"\"\n\n        # Setting the alarm\n        end_time = time.time() + timeout\n        while True:\n            if end_time is not None and time.time() &gt; end_time:\n                # Timeout reached\n                raise TimeoutError(\"Timeout reached\")\n\n            # Adjust the timeout for select to the remaining time\n            remaining_time = None if end_time is None else max(0, end_time - time.time())\n\n            data = self._recv(numb=1, timeout=remaining_time, stderr=stderr)\n\n            data_buffer += data\n\n            if delims in data_buffer:\n                # Delims reached\n                if drop:\n                    data_buffer = data_buffer[: -len(delims)]\n                break\n\n        return data_buffer\n\n    def _recvuntil(\n        self: PipeManager,\n        delims: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: float = timeout_default,\n        stderr: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process until the delimiters are found occurences time.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (float, optional): timeout in seconds. Defaults to timeout_default.\n            stderr (bool, optional): receive from stderr. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stdout.\n        \"\"\"\n        if occurences &lt;= 0:\n            raise ValueError(\"The number of occurences to receive must be positive\")\n\n        # Buffer for the received data\n        data_buffer = b\"\"\n\n        # Setting the alarm\n        end_time = time.time() + timeout\n\n        for _ in range(occurences):\n            # Adjust the timeout for select to the remaining time\n            remaining_time = None if end_time is None else max(0, end_time - time.time())\n\n            data_buffer += self._recvonceuntil(delims=delims, drop=drop, timeout=remaining_time, stderr=stderr)\n\n        return data_buffer\n\n    def recvuntil(\n        self: PipeManager,\n        delims: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process stdout until the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received data from the child process stdout.\n        \"\"\"\n        return self._recvuntil(\n            delims=delims,\n            occurences=occurences,\n            drop=drop,\n            timeout=timeout,\n            stderr=False,\n        )\n\n    def recverruntil(\n        self: PipeManager,\n        delims: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process stderr until the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received data from the child process stderr.\n        \"\"\"\n        return self._recvuntil(\n            delims=delims,\n            occurences=occurences,\n            drop=drop,\n            timeout=timeout,\n            stderr=True,\n        )\n\n    def recvline(self: PipeManager, numlines: int = 1, drop: bool = True, timeout: int = timeout_default) -&gt; bytes:\n        \"\"\"Receives numlines lines from the child process stdout.\n\n        Args:\n            numlines (int, optional): number of lines to receive. Defaults to 1.\n            drop (bool, optional): drop the line ending. Defaults to True.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received lines from the child process stdout.\n        \"\"\"\n        return self.recvuntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout)\n\n    def recverrline(self: PipeManager, numlines: int = 1, drop: bool = True, timeout: int = timeout_default) -&gt; bytes:\n        \"\"\"Receives numlines lines from the child process stderr.\n\n        Args:\n            numlines (int, optional): number of lines to receive. Defaults to 1.\n            drop (bool, optional): drop the line ending. Defaults to True.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received lines from the child process stdout.\n        \"\"\"\n        return self.recverruntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout)\n\n    def send(self: PipeManager, data: bytes) -&gt; int:\n        \"\"\"Sends data to the child process stdin.\n\n        Args:\n            data (bytes): data to send.\n\n        Returns:\n            int: number of bytes sent.\n\n        Raises:\n            RuntimeError: no stdin pipe of the child process.\n        \"\"\"\n        if not self.stdin_write:\n            raise RuntimeError(\"No stdin pipe of the child process\")\n\n        liblog.pipe(f\"Sending {len(data)} bytes to the child process: {data!r}\")\n\n        if isinstance(data, str):\n            liblog.warning(\"The input data is a string, converting to bytes\")\n            data = data.encode()\n\n        return os.write(self.stdin_write, data)\n\n    def sendline(self: PipeManager, data: bytes) -&gt; int:\n        \"\"\"Sends data to the child process stdin and append a newline.\n\n        Args:\n            data (bytes): data to send.\n\n        Returns:\n            int: number of bytes sent.\n        \"\"\"\n        if isinstance(data, str):\n            liblog.warning(\"The input data is a string, converting to bytes\")\n            data = data.encode()\n\n        return self.send(data=data + b\"\\n\")\n\n    def sendafter(\n        self: PipeManager,\n        delims: bytes,\n        data: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n    ) -&gt; tuple[bytes, int]:\n        \"\"\"Sends data to the child process stdin after the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            data (bytes): data to send.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received data from the child process stdout.\n            int: number of bytes sent.\n        \"\"\"\n        received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout)\n        sent = self.send(data)\n        return (received, sent)\n\n    def sendlineafter(\n        self: PipeManager,\n        delims: bytes,\n        data: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n    ) -&gt; tuple[bytes, int]:\n        \"\"\"Sends line to the child process stdin after the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            data (bytes): data to send.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received data from the child process stdout.\n            int: number of bytes sent.\n        \"\"\"\n        received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout)\n        sent = self.sendline(data)\n        return (received, sent)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.__init__","title":"<code>__init__(stdin_write, stdout_read, stderr_read)</code>","text":"<p>Initializes the PipeManager class.</p> <p>Parameters:</p> Name Type Description Default <code>stdin_write</code> <code>int</code> <p>file descriptor for stdin write.</p> required <code>stdout_read</code> <code>int</code> <p>file descriptor for stdout read.</p> required <code>stderr_read</code> <code>int</code> <p>file descriptor for stderr read.</p> required Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def __init__(self: PipeManager, stdin_write: int, stdout_read: int, stderr_read: int) -&gt; None:\n    \"\"\"Initializes the PipeManager class.\n\n    Args:\n        stdin_write (int): file descriptor for stdin write.\n        stdout_read (int): file descriptor for stdout read.\n        stderr_read (int): file descriptor for stderr read.\n    \"\"\"\n    self.stdin_write: int = stdin_write\n    self.stdout_read: int = stdout_read\n    self.stderr_read: int = stderr_read\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.close","title":"<code>close()</code>","text":"<p>Closes all the pipes of the child process.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def close(self: PipeManager) -&gt; None:\n    \"\"\"Closes all the pipes of the child process.\"\"\"\n    os.close(self.stdin_write)\n    os.close(self.stdout_read)\n    os.close(self.stderr_read)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.recv","title":"<code>recv(numb=None, timeout=timeout_default)</code>","text":"<p>Receives at most numb bytes from the child process stdout.</p> <p>Parameters:</p> Name Type Description Default <code>numb</code> <code>int</code> <p>number of bytes to receive. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received bytes from the child process stdout.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def recv(self: PipeManager, numb: int | None = None, timeout: int = timeout_default) -&gt; bytes:\n    \"\"\"Receives at most numb bytes from the child process stdout.\n\n    Args:\n        numb (int, optional): number of bytes to receive. Defaults to None.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received bytes from the child process stdout.\n    \"\"\"\n    return self._recv(numb=numb, timeout=timeout, stderr=False)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.recverr","title":"<code>recverr(numb=None, timeout=timeout_default)</code>","text":"<p>Receives at most numb bytes from the child process stderr.</p> <p>Parameters:</p> Name Type Description Default <code>numb</code> <code>int</code> <p>number of bytes to receive. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received bytes from the child process stderr.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def recverr(self: PipeManager, numb: int | None = None, timeout: int = timeout_default) -&gt; bytes:\n    \"\"\"Receives at most numb bytes from the child process stderr.\n\n    Args:\n        numb (int, optional): number of bytes to receive. Defaults to None.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received bytes from the child process stderr.\n    \"\"\"\n    return self._recv(numb=numb, timeout=timeout, stderr=True)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.recverrline","title":"<code>recverrline(numlines=1, drop=True, timeout=timeout_default)</code>","text":"<p>Receives numlines lines from the child process stderr.</p> <p>Parameters:</p> Name Type Description Default <code>numlines</code> <code>int</code> <p>number of lines to receive. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the line ending. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received lines from the child process stdout.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def recverrline(self: PipeManager, numlines: int = 1, drop: bool = True, timeout: int = timeout_default) -&gt; bytes:\n    \"\"\"Receives numlines lines from the child process stderr.\n\n    Args:\n        numlines (int, optional): number of lines to receive. Defaults to 1.\n        drop (bool, optional): drop the line ending. Defaults to True.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received lines from the child process stdout.\n    \"\"\"\n    return self.recverruntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.recverruntil","title":"<code>recverruntil(delims, occurences=1, drop=False, timeout=timeout_default)</code>","text":"<p>Receives data from the child process stderr until the delimiters are found.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stderr.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def recverruntil(\n    self: PipeManager,\n    delims: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n) -&gt; bytes:\n    \"\"\"Receives data from the child process stderr until the delimiters are found.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received data from the child process stderr.\n    \"\"\"\n    return self._recvuntil(\n        delims=delims,\n        occurences=occurences,\n        drop=drop,\n        timeout=timeout,\n        stderr=True,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.recvline","title":"<code>recvline(numlines=1, drop=True, timeout=timeout_default)</code>","text":"<p>Receives numlines lines from the child process stdout.</p> <p>Parameters:</p> Name Type Description Default <code>numlines</code> <code>int</code> <p>number of lines to receive. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the line ending. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received lines from the child process stdout.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def recvline(self: PipeManager, numlines: int = 1, drop: bool = True, timeout: int = timeout_default) -&gt; bytes:\n    \"\"\"Receives numlines lines from the child process stdout.\n\n    Args:\n        numlines (int, optional): number of lines to receive. Defaults to 1.\n        drop (bool, optional): drop the line ending. Defaults to True.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received lines from the child process stdout.\n    \"\"\"\n    return self.recvuntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.recvuntil","title":"<code>recvuntil(delims, occurences=1, drop=False, timeout=timeout_default)</code>","text":"<p>Receives data from the child process stdout until the delimiters are found.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stdout.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def recvuntil(\n    self: PipeManager,\n    delims: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n) -&gt; bytes:\n    \"\"\"Receives data from the child process stdout until the delimiters are found.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received data from the child process stdout.\n    \"\"\"\n    return self._recvuntil(\n        delims=delims,\n        occurences=occurences,\n        drop=drop,\n        timeout=timeout,\n        stderr=False,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.send","title":"<code>send(data)</code>","text":"<p>Sends data to the child process stdin.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to send.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of bytes sent.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>no stdin pipe of the child process.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def send(self: PipeManager, data: bytes) -&gt; int:\n    \"\"\"Sends data to the child process stdin.\n\n    Args:\n        data (bytes): data to send.\n\n    Returns:\n        int: number of bytes sent.\n\n    Raises:\n        RuntimeError: no stdin pipe of the child process.\n    \"\"\"\n    if not self.stdin_write:\n        raise RuntimeError(\"No stdin pipe of the child process\")\n\n    liblog.pipe(f\"Sending {len(data)} bytes to the child process: {data!r}\")\n\n    if isinstance(data, str):\n        liblog.warning(\"The input data is a string, converting to bytes\")\n        data = data.encode()\n\n    return os.write(self.stdin_write, data)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.sendafter","title":"<code>sendafter(delims, data, occurences=1, drop=False, timeout=timeout_default)</code>","text":"<p>Sends data to the child process stdin after the delimiters are found.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>data</code> <code>bytes</code> <p>data to send.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stdout.</p> <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def sendafter(\n    self: PipeManager,\n    delims: bytes,\n    data: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n) -&gt; tuple[bytes, int]:\n    \"\"\"Sends data to the child process stdin after the delimiters are found.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        data (bytes): data to send.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received data from the child process stdout.\n        int: number of bytes sent.\n    \"\"\"\n    received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout)\n    sent = self.send(data)\n    return (received, sent)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.sendline","title":"<code>sendline(data)</code>","text":"<p>Sends data to the child process stdin and append a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to send.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def sendline(self: PipeManager, data: bytes) -&gt; int:\n    \"\"\"Sends data to the child process stdin and append a newline.\n\n    Args:\n        data (bytes): data to send.\n\n    Returns:\n        int: number of bytes sent.\n    \"\"\"\n    if isinstance(data, str):\n        liblog.warning(\"The input data is a string, converting to bytes\")\n        data = data.encode()\n\n    return self.send(data=data + b\"\\n\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pipe_manager/#libdebug.utils.pipe_manager.PipeManager.sendlineafter","title":"<code>sendlineafter(delims, data, occurences=1, drop=False, timeout=timeout_default)</code>","text":"<p>Sends line to the child process stdin after the delimiters are found.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>data</code> <code>bytes</code> <p>data to send.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stdout.</p> <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/utils/pipe_manager.py</code> <pre><code>def sendlineafter(\n    self: PipeManager,\n    delims: bytes,\n    data: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n) -&gt; tuple[bytes, int]:\n    \"\"\"Sends line to the child process stdin after the delimiters are found.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        data (bytes): data to send.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received data from the child process stdout.\n        int: number of bytes sent.\n    \"\"\"\n    received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout)\n    sent = self.sendline(data)\n    return (received, sent)\n</code></pre>"},{"location":"from_pydoc/generated/utils/platform_utils/","title":"libdebug.utils.platform_utils","text":""},{"location":"from_pydoc/generated/utils/platform_utils/#libdebug.utils.platform_utils.get_platform_register_size","title":"<code>get_platform_register_size(arch)</code>","text":"<p>Get the register size of the platform.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>str</code> <p>The architecture of the platform.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The register size in bytes.</p> Source code in <code>libdebug/utils/platform_utils.py</code> <pre><code>def get_platform_register_size(arch: str) -&gt; int:\n    \"\"\"Get the register size of the platform.\n\n    Args:\n        arch (str): The architecture of the platform.\n\n    Returns:\n        int: The register size in bytes.\n    \"\"\"\n    match arch:\n        case \"amd64\":\n            return 8\n        case \"aarch64\":\n            return 8\n        case _:\n            raise ValueError(f\"Architecture {arch} not supported.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/posix_spawn/","title":"libdebug.utils.posix_spawn","text":""},{"location":"from_pydoc/generated/utils/posix_spawn/#libdebug.utils.posix_spawn.posix_spawn","title":"<code>posix_spawn(file, argv, env, file_actions, setpgroup)</code>","text":"<p>Spawn a new process, emulating the POSIX spawn function.</p> Source code in <code>libdebug/utils/posix_spawn.py</code> <pre><code>def posix_spawn(file: str, argv: list, env: dict, file_actions: list, setpgroup: bool) -&gt; int:\n    \"\"\"Spawn a new process, emulating the POSIX spawn function.\"\"\"\n    child_pid = os.fork()\n    if child_pid == 0:\n        for element in file_actions:\n            if element[0] == POSIX_SPAWN_CLOSE:\n                os.close(element[1])\n            elif element[0] == POSIX_SPAWN_DUP2:\n                os.dup2(element[1], element[2])\n            elif element[0] == POSIX_SPAWN_OPEN:\n                fd, path, flags, mode = element[1:]\n                os.dup2(os.open(path, flags, mode), fd)\n            else:\n                raise ValueError(\"Invalid file action\")\n        if setpgroup == 0:\n            os.setpgid(0, 0)\n        os.execve(file, argv, env)\n\n    return child_pid\n</code></pre>"},{"location":"from_pydoc/generated/utils/print_style/","title":"libdebug.utils.print_style","text":""},{"location":"from_pydoc/generated/utils/print_style/#libdebug.utils.print_style.PrintStyle","title":"<code>PrintStyle</code>","text":"<p>Class to define colors for the terminal.</p> Source code in <code>libdebug/utils/print_style.py</code> <pre><code>class PrintStyle:\n    \"\"\"Class to define colors for the terminal.\"\"\"\n\n    RED = \"\\033[91m\"\n    BLUE = \"\\033[94m\"\n    GREEN = \"\\033[92m\"\n    BRIGHT_YELLOW = \"\\033[93m\"\n    YELLOW = \"\\033[33m\"\n    PINK = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    STRIKE = \"\\033[9m\"\n    DEFAULT_COLOR = \"\\033[39m\"\n    RESET = \"\\033[0m\"\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/","title":"libdebug.utils.process_utils","text":""},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.disable_self_aslr","title":"<code>disable_self_aslr()</code>","text":"<p>Disables ASLR for the current process.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>def disable_self_aslr() -&gt; None:\n    \"\"\"Disables ASLR for the current process.\"\"\"\n    retval = lib_personality.disable_aslr()\n\n    if retval == -1:\n        raise RuntimeError(\"Failed to disable ASLR.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.get_open_fds","title":"<code>get_open_fds(process_id)</code>  <code>cached</code>","text":"<p>Returns the file descriptors of the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>process_id</code> <code>int</code> <p>The PID of the process whose file descriptors should be returned.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[int]</code> <p>A list of integers, each representing a file descriptor of the specified process.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>@functools.cache\ndef get_open_fds(process_id: int) -&gt; list[int]:\n    \"\"\"Returns the file descriptors of the specified process.\n\n    Args:\n        process_id (int): The PID of the process whose file descriptors should be returned.\n\n    Returns:\n        list: A list of integers, each representing a file descriptor of the specified process.\n    \"\"\"\n    return [int(fd) for fd in os.listdir(f\"/proc/{process_id}/fd\")]\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.get_process_maps","title":"<code>get_process_maps(process_id)</code>  <code>cached</code>","text":"<p>Returns the memory maps of the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>process_id</code> <code>int</code> <p>The PID of the process whose memory maps should be returned.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[MemoryMap]</code> <p>A list of <code>MemoryMap</code> objects, each representing a memory map of the specified process.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>@functools.cache\ndef get_process_maps(process_id: int) -&gt; list[MemoryMap]:\n    \"\"\"Returns the memory maps of the specified process.\n\n    Args:\n        process_id (int): The PID of the process whose memory maps should be returned.\n\n    Returns:\n        list: A list of `MemoryMap` objects, each representing a memory map of the specified process.\n    \"\"\"\n    with Path(f\"/proc/{process_id}/maps\").open() as maps_file:\n        maps = maps_file.readlines()\n\n    return [MemoryMap.parse(vmap) for vmap in maps]\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.invalidate_process_cache","title":"<code>invalidate_process_cache()</code>","text":"<p>Invalidates the cache of the functions in this module. Must be executed any time the process executes code.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>def invalidate_process_cache() -&gt; None:\n    \"\"\"Invalidates the cache of the functions in this module. Must be executed any time the process executes code.\"\"\"\n    get_process_maps.cache_clear()\n    get_open_fds.cache_clear()\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/","title":"libdebug.utils.signal_utils","text":""},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.create_signal_mappings","title":"<code>create_signal_mappings()</code>  <code>cached</code>","text":"<p>Create mappings between signal names and numbers.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef create_signal_mappings() -&gt; tuple[dict, dict]:\n    \"\"\"Create mappings between signal names and numbers.\"\"\"\n    signal_to_number = {}\n    number_to_signal = {}\n\n    for name in dir(signal):\n        if name.startswith(\"SIG\") and not name.startswith(\"SIG_\"):\n            number = getattr(signal, name)\n            signal_to_number[name] = number\n            number_to_signal[number] = name\n\n    return signal_to_number, number_to_signal\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.get_all_signal_numbers","title":"<code>get_all_signal_numbers()</code>  <code>cached</code>","text":"<p>Get all the signal numbers.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the list of signal numbers.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef get_all_signal_numbers() -&gt; list:\n    \"\"\"Get all the signal numbers.\n\n    Returns:\n        list: the list of signal numbers.\n    \"\"\"\n    _, number_to_signal = create_signal_mappings()\n\n    return list(number_to_signal.keys())\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.resolve_signal_name","title":"<code>resolve_signal_name(number)</code>  <code>cached</code>","text":"<p>Resolve a signal number to its name.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>the signal number.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the signal name.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef resolve_signal_name(number: int) -&gt; str:\n    \"\"\"Resolve a signal number to its name.\n\n    Args:\n        number (int): the signal number.\n\n    Returns:\n        str: the signal name.\n    \"\"\"\n    _, number_to_signal = create_signal_mappings()\n\n    try:\n        return number_to_signal[number]\n    except KeyError as e:\n        raise ValueError(f\"Signal {number} not found.\") from e\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.resolve_signal_number","title":"<code>resolve_signal_number(name)</code>  <code>cached</code>","text":"<p>Resolve a signal name to its number.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the signal name.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the signal number.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef resolve_signal_number(name: str) -&gt; int:\n    \"\"\"Resolve a signal name to its number.\n\n    Args:\n        name (str): the signal name.\n\n    Returns:\n        int: the signal number.\n    \"\"\"\n    signal_to_number, _ = create_signal_mappings()\n\n    try:\n        return signal_to_number[name]\n    except KeyError as e:\n        raise ValueError(f\"Signal {name} not found.\") from e\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/","title":"libdebug.utils.syscall_utils","text":""},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.fetch_remote_syscall_definition","title":"<code>fetch_remote_syscall_definition(arch)</code>","text":"<p>Fetch the syscall definition file from the remote server.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>def fetch_remote_syscall_definition(arch: str) -&gt; dict:\n    \"\"\"Fetch the syscall definition file from the remote server.\"\"\"\n    url = get_remote_definition_url(arch)\n\n    response = requests.get(url, timeout=1)\n    response.raise_for_status()\n\n    # Save the response to a local file\n    with Path(f\"{LOCAL_FOLDER_PATH}/{arch}.json\").open(\"w\") as f:\n        f.write(response.text)\n\n    return response.json()\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.get_all_syscall_numbers","title":"<code>get_all_syscall_numbers(architecture)</code>  <code>cached</code>","text":"<p>Retrieves all the syscall numbers.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef get_all_syscall_numbers(architecture: str) -&gt; list[int]:\n    \"\"\"Retrieves all the syscall numbers.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    return [syscall[\"number\"] for syscall in definitions[\"syscalls\"]]\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.get_remote_definition_url","title":"<code>get_remote_definition_url(arch)</code>","text":"<p>Get the URL of the remote syscall definition file.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>def get_remote_definition_url(arch: str) -&gt; str:\n    \"\"\"Get the URL of the remote syscall definition file.\"\"\"\n    match arch:\n        case \"amd64\":\n            return f\"{SYSCALLS_REMOTE}/x86/64/x64/latest/table.json\"\n        case \"aarch64\":\n            return f\"{SYSCALLS_REMOTE}/arm64/64/aarch64/latest/table.json\"\n        case _:\n            raise ValueError(f\"Architecture {arch} not supported\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.get_syscall_definitions","title":"<code>get_syscall_definitions(arch)</code>  <code>cached</code>","text":"<p>Get the syscall definitions for the specified architecture.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef get_syscall_definitions(arch: str) -&gt; dict:\n    \"\"\"Get the syscall definitions for the specified architecture.\"\"\"\n    LOCAL_FOLDER_PATH.mkdir(parents=True, exist_ok=True)\n\n    if (LOCAL_FOLDER_PATH / f\"{arch}.json\").exists():\n        try:\n            with (LOCAL_FOLDER_PATH / f\"{arch}.json\").open() as f:\n                return json.load(f)\n        except json.decoder.JSONDecodeError:\n            pass\n\n    return fetch_remote_syscall_definition(arch)\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.resolve_syscall_arguments","title":"<code>resolve_syscall_arguments(architecture, number)</code>  <code>cached</code>","text":"<p>Resolve a syscall number to its argument definition.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef resolve_syscall_arguments(architecture: str, number: int) -&gt; list[str]:\n    \"\"\"Resolve a syscall number to its argument definition.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    for syscall in definitions[\"syscalls\"]:\n        if syscall[\"number\"] == number:\n            return syscall[\"signature\"]\n\n    raise ValueError(f'Syscall number \"{number}\" not found')\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.resolve_syscall_name","title":"<code>resolve_syscall_name(architecture, number)</code>  <code>cached</code>","text":"<p>Resolve a syscall number to its name.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef resolve_syscall_name(architecture: str, number: int) -&gt; str:\n    \"\"\"Resolve a syscall number to its name.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    for syscall in definitions[\"syscalls\"]:\n        if syscall[\"number\"] == number:\n            return syscall[\"name\"]\n\n    raise ValueError(f'Syscall number \"{number}\" not found')\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.resolve_syscall_number","title":"<code>resolve_syscall_number(architecture, name)</code>  <code>cached</code>","text":"<p>Resolve a syscall name to its number.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef resolve_syscall_number(architecture: str, name: str) -&gt; int:\n    \"\"\"Resolve a syscall name to its number.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    for syscall in definitions[\"syscalls\"]:\n        if syscall[\"name\"] == name:\n            return syscall[\"number\"]\n\n    raise ValueError(f'Syscall \"{name}\" not found')\n</code></pre>"},{"location":"logging/liblog/","title":"Logging","text":"<p>Debugging an application with the freedom of a rich API can lead to flows which are hard to unravel. To aid the user in the debugging process, libdebug provides logging. The logging system is implemented in the submodule <code>liblog</code> and adheres to the Python logging system.</p>","boost":4},{"location":"logging/liblog/#event-logging","title":"Event Logging","text":"<p>By default, libdebug only prints critical logs such as warnings and errors. However, the user can enable more verbose logging by setting the <code>argv</code> parameter of the script.</p> <p>The available logging modes for events are:</p> Mode Description <code>debugger</code> Logs related to the debugging operations performed on the process by libdebug. <code>pipe</code> Logs related to interactions with the process pipe: bytes received and bytes sent. <code>dbg</code> Combination of the <code>pipe</code> and <code>debugger</code> options. <p>pwntools compatibility</p> <p>As reported in this documentation, the <code>argv</code> parameters passed to libdebug are lowercase. This choice is made to avoid conflicts with pwntools, which intercepts all uppercase arguments.</p>","boost":4},{"location":"logging/liblog/#debugger-logging","title":"Debugger Logging","text":"<p>The <code>debugger</code> option displays all logs related to the debugging operations performed on the process by libdebug.</p> <p></p>","boost":4},{"location":"logging/liblog/#pipe-logging","title":"Pipe Logging","text":"<p>The <code>pipe</code> option, on the other hand, displays all logs related to interactions with the process pipe: bytes received and bytes sent.</p> <p></p>","boost":4},{"location":"logging/liblog/#the-best-of-both-worlds","title":"The best of both worlds","text":"<p>The <code>dbg</code> option is the combination of the <code>pipe</code> and <code>debugger</code> options. It displays all logs related to the debugging operations performed on the process by libdebug, as well as interactions with the process pipe: bytes received and bytes sent.</p>","boost":4},{"location":"logging/liblog/#changing-logging-levels-at-runtime","title":"Changing logging levels at runtime","text":"<p>libdebug defines logging levels and information types to allow the user to filter the granularity of the the information they want to see. Logger levels for each event type can be changed at runtime using the <code>libcontext</code> module.</p> <p>Example of setting logging levels</p> <pre><code>```python\nfrom libdebug import libcontext\n\nlibcontext.general_logger = 'DEBUG'\nlibcontext.pipe_logger = 'DEBUG'\nlibcontext.debugger_logger = 'DEBUG'\n```\n</code></pre> Logger Description Supported Levels Default Level <code>general_logger</code> Logger used for general libdebug logs, different from the <code>pipe</code> and <code>debugger</code> logs. <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>SILENT</code> <code>DEBUG</code> <code>pipe_logger</code> Logger used for pipe logs. <code>DEBUG</code>, <code>SILENT</code> <code>SILENT</code> <code>debugger_logger</code> Logger used for debugger logs. <code>DEBUG</code>, <code>SILENT</code> <code>SILENT</code> <p>Let's see what each logging level actually logs:</p> Log Level Debug Logs Information Logs Warnings DEBUG INFO WARNING SILENT","boost":4},{"location":"logging/liblog/#temporary-logging-level-changes","title":"Temporary logging level changes","text":"<p>Logger levels can be temporarily changed at runtime using a <code>with</code> statement, as shown in the following example.</p> <pre><code>from libdebug import libcontext\n\nwith libcontext.tmp(pipe_logger='SILENT', debugger_logger='DEBUG'):\n    r.sendline(b'gimme the flag')\n</code></pre>","boost":4},{"location":"multithreading/multithreading/","title":"Debugging Multithreaded Applications","text":"<p>Debugging multi-threaded applications can be a daunting task, particularly in an interactive debugger that is designed to operate on one thread at a time. libdebug offers a few features that will help you debug multi-threaded applications more intuitively and efficiently.</p>","boost":4},{"location":"multithreading/multithreading/#child-processes","title":"Child processes","text":"<p>Threads of a running process in the POSIX standard are children of the main process. They are created by system calls such as fork, clone and clone3. In the Linux kernel, the ptrace system call allows a parent process to trace new threads and retrieve their thread id (tid).</p> <p>libdebug automatically registers new threads and exposes their state with the same API as the main Debugger object. While technically threads can be running or stopped independently, libdebug will enforce a coherent state. This means that if a thread is stopped, all other threads will be stopped as well and if a continuation command is issued, all threads will be resumed.</p> <p>To access the threads of a process, you can use the <code>threads</code> attribute of the Debugger object. This attribute will return a list of ThreadContext objects, each representing a thread of the process.</p> <p>Meaning of the debugger object</p> <p>When accessing state fields of the Debugger object (e.g. registers, memory), the debugger will act as an alias for the main thread. For example, doing d.regs.rax will be equivalent to doing d.threads[0].regs.rax.</p>","boost":4},{"location":"multithreading/multithreading/#shared-and-unshared-state","title":"Shared and Unshared State","text":"<p>Each thread has its own register set, stack, and instruction pointer. However, threads share the same virtual address space and file descriptors. This has a series of implications when debugging multi-threaded applications:</p> <ul> <li> <p> Software breakpoints are implemented through code patching in the process memory. This means that a breakpoint set in one thread will affect all threads.</p> <ul> <li> <p>When using synchronous breakpoints, you will need to \"diagnose\" the stopping event to determine which thread triggered the breakpoint. You can do this by checking the return value of the <code>hit_on()</code> method of the Breakpoint object. Passing the ThreadContext as an argument will return <code>True</code> if the breakpoint was hit by that thread.</p> </li> <li> <p>When using asynchronous breakpoints, the breakpoint will be more intuitive to handle, as the signature of the callback function includes the ThreadContext object that triggered the breakpoint.</p> </li> <li> <p> While hardware breakpoints are thread-specific, libdebug mirrors them across all threads. This is done to avoid the complexity of managing hardware breakpoints on a per-thread basis. Watchpoints are hardware breakpoints, so this applies to them as well.</p> </li> </ul> </li> <li> <p> For consistency, syscall handlers are also enabled across all threads. The same considerations for synchronous and asynchronous breakpoints apply here as well.</p> </li> </ul> <p>Concurrency in Syscall Handling</p> <p>libdebug does not guarantee that the syscall entry and exit events will be triggered by the same thread. This is because the kernel may schedule a different thread to handle the syscall exit event.</p> <ul> <li> Signal Catching is also shared among threads. Apart from consistency, this is a necessity. In fact, the kernel does not guarantee that a signal sent to a process will be dispatched to a specific thread.<ul> <li>By contrast, when sending arbitrary signals through the ThreadContext object, the signal will be sent to the requested thread.</li> </ul> </li> </ul> <p>How to access TLS?</p> <p>While the virtual address space is shared between threads, each thread has its own Thread Local Storage (TLS) area. As it stands, libdebug does not provide a direct interface to the TLS area. Moreover, some of the registers that are used to access the TLS area are not exposed by libdebug in the <code>regs</code> attribute.</p> <p>You can still access segment registers on Intel architectures through the <code>register_file</code> attribute of the <code>regs</code> holder. For example, <code>t.regs.register_file.fs_base</code> will return the value of the <code>FS</code> segment base register.</p>","boost":4},{"location":"quality_of_life/anti_debugging/","title":"Evasion of Anti-Debugging","text":"","boost":4},{"location":"quality_of_life/anti_debugging/#automatic-evasion-of-anti-debugging-techniques","title":"Automatic Evasion of Anti-Debugging Techniques","text":"<p>A common anti-debugging technique for Linux ELF binaries is to invoke the <code>ptrace</code> syscall with the <code>PTRACE_TRACEME</code> argument. The syscall will fail if the binary is currently being traced by a debugger, as the kernel forbids a process from being traced by multiple debuggers.</p> <p>Bypassing this technique involves intercepting such syscalls and altering the return value to make the binary believe that it is not being traced. While this can absolutely be performed manually, libdebug comes with a pre-made implementation that can save you precious time.</p> <p>To enable this feature, set the <code>escape_antidebug</code> property to <code>True</code> when creating the debugger object. The debugger will take care of the rest.</p> <p>Example</p> <p>&gt; C source code <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/ptrace.h&gt;\n\nint main()\n{\n\n    if (ptrace(PTRACE_TRACEME, 0, NULL, 0) == -1) // (1)\n    {\n        puts(\"No cheating! Debugger detected.\\n\"); // (2)\n        exit(1);\n    }\n\n    puts(\"Congrats! Here's your flag:\\n\"); // (3)\n    puts(\"flag{y0u_sn3aky_guy_y0u_tr1ck3d_m3}\\n\");\n\n    return 0;\n}\n</code></pre></p> <ol> <li>Call ptrace with <code>PTRACE_TRACEME</code> to detect if we are being debugged</li> <li>If the call fails, it means the program is being debugged</li> <li>If the program is not being debugged, print the flag</li> </ol> <p>&gt; libdebug script <pre><code>from libdebug import debugger\n\nd = debugger(\"evasive_binary\",\n    escape_antidebug=True)\n\npipe = d.run()\n\nd.cont()\nd.wait()\n\nout = pipe.recvline(numlines=2)\nprint(out.decode())\n</code></pre></p> <p>Execution of the script will print the flag, even if the binary is being debugged.</p>","boost":4},{"location":"quality_of_life/memory_maps/","title":"Memory Maps","text":"<p>Virtual memory is a fundamental concept in operating systems. It allows the operating system to provide each process with its own address space, which is isolated from other processes. This isolation is crucial for security and stability reasons. The memory of a process is divided into regions called memory maps. Each memory map has a starting address, an ending address, and a set of permissions (read, write, execute).</p> <p>In libdebug, you can access the memory maps of a process using the <code>maps</code> attribute of the Debugger object.</p> <p>The <code>maps</code> attribute returns a list of MemoryMap objects, which contain the following attributes:</p> Attribute Type Description <code>start</code> <code>int</code> The start address of the memory map. <code>end</code> <code>int</code> The end address of the memory map. <code>permissions</code> <code>str</code> The permissions of the memory map. <code>size</code> <code>int</code> The size of the memory map. <code>offset</code> <code>int</code> The offset of the memory map relative to the backing file. <code>backing_file</code> <code>str</code> The backing file of the memory map, or the symbolic name of the memory map.","boost":4},{"location":"quality_of_life/memory_maps/#searching-memory-maps","title":"Searching Memory Maps","text":"<p>You can search for memory maps based on their attributes using the <code>find()</code> method of the <code>maps</code> attribute. The <code>find()</code> method accepts a value that can be either a memory address (<code>int</code>) or a symbolic name (<code>str</code>) and returns a list of MemoryMap objects that match the search criteria.</p> <p>Function Signature</p> <pre><code>d.maps.find(value: int | str) -&gt; MemoryMapList[MemoryMap]:\n</code></pre> <p>The behavior of the memory map search depends on the type of the <code>value</code> parameter:</p> Queried Value Return Value Integer (memory address) Map that contains the address String (symbolic map name) List of maps that match the symbolic name","boost":4},{"location":"quality_of_life/pretty_printing/","title":"Pretty Printing","text":"","boost":4},{"location":"quality_of_life/pretty_printing/#pretty-printing","title":"Pretty Printing","text":"<p>libdebug offers utilities to visualize the process's state in a human-readable format and with color highlighting. This can be especially useful when debugging complex binaries or when you need to quickly understand the behavior of a program.</p>","boost":4},{"location":"quality_of_life/pretty_printing/#registers-pretty-printing","title":"Registers Pretty Printing","text":"<p>There are two functions available to print the registers of a thread: <code>pprint_registers()</code> and <code>print_registers_all()</code>. The former will print the current values of general-purpose registers, while the latter will print all available registers.</p> <p></p> <p>Aliases</p> <p>If you don't like long function names, you can use aliases for the two register pretty print functions. The shorter aliases are <code>pprint_regs()</code> and <code>print_regs_all()</code>.</p>","boost":4},{"location":"quality_of_life/pretty_printing/#syscall-trace-pretty-printing","title":"Syscall Trace Pretty Printing","text":"<p>When debugging a binary, it is often much faster to guess what the intended functionality is by looking at the syscalls that are being invoked. libdebug offers a function that will intercept any syscall and print its arguments and return value. This can be done by setting the property <code>pprint_syscalls = True</code> in the debugger object and resuming execution.</p> <p>Syscall Trace PPrint Syntax</p> <pre><code>d.pprint_syscalls = True\nd.cont()\n</code></pre> <p>The output will be printed to the console in color accoring to the following coding:</p> Format Description blue Syscall name red Syscall was intercepted and handled by a callback (either a basic handler or a hijack) yellow Value given to a syscall argument in hexadecimal strikethrough Syscall was hijacked, the next line contains the syscall executed in its place <p>Handled syscalls with a callback associated with them will be listed as such. Additionally, syscalls hijacked through the libdebug API will be highlighted as striken through, allowing you to monitor both the original behavior and your own changes to the flow.</p> <p></p>","boost":4},{"location":"quality_of_life/pretty_printing/#memory-maps-pretty-printing","title":"Memory Maps Pretty Printing","text":"<p>To pretty print the memory maps of a process, you can simply use the <code>pprint_maps()</code> function. This will print the memory maps of the process in a human-readable format, with color highlighting to distinguish between different memory regions.</p> Format Description green Memory map with read permission only yellow Memory map with read and write permissions red Memory map with read and execute permissions underlined Memory map with read, write, and execute permissions <p></p>","boost":4},{"location":"quality_of_life/pretty_printing/#stack-trace-pretty-printing","title":"Stack Trace Pretty Printing","text":"<p>To pretty print the stack trace (backtrace) of a process, you can use the <code>pprint_backtrace()</code> function. This will print the stack trace of the process in a human-readable format.</p> <p></p>","boost":4},{"location":"quality_of_life/quality_of_life/","title":"Quality of Life Features","text":"<p>For your convenience, libdebug offers a few functions that will speed up your debugging process.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#pretty-printing","title":"Pretty Printing","text":"<p>Visualizing the state of the process you are debugging can be a daunting task. libdebug offers utilities to print registers, memory maps, syscalls, and more in a human-readable format and with color highlighting.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#symbol-resolution","title":"Symbol Resolution","text":"<p>libdebug can resolve symbols in the binary and shared libraries. With big binaries, this can be a computationally intensive, especially if your script needs to be run multiple types. You can set symbol resolution levels and specify where to look for symbols according to your needs.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#memory-maps","title":"Memory Maps","text":"<p>libdebug offers utilities to retrieve the memory maps of a process. This can be useful to understand the memory layout of the process you are debugging.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#stack-frame-utils","title":"Stack Frame Utils","text":"<p>libdebug offers utilities to resolve the return addresses of a process.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#evasion-of-anti-debugging","title":"Evasion of Anti-Debugging","text":"<p>libdebug offers a few functions that will help you evade simple anti-debugging techniques. These functions can be used to bypass checks for the presence of a debugger.</p>","boost":4},{"location":"quality_of_life/stack_frame_utils/","title":"Stack Frame Utils","text":"<p>Function calls in a binary executable are made according to a system calling convention. One constant in these conventions is the use of a stack frame to store the return addresses to resume at the end of the function.</p> <p>Different architectures have slightly different ways to retrieve the return address (for example, in AArch64, the latest return address is stored in <code>x30</code>, the Link Register). To abstract these differences, libdebug provides common utilities to resolve the stack trace (backtrace) of the running process (or thread).</p> <p>libdebug's backtrace is structured like a LIFO stack, with the top-most value being the current instruction pointer. Subsequent values are the return addresses of the functions that were called to reach the current instruction pointer.</p> <p>Backtrace usage example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"test_backtrace\")\nd.run()\n\n# A few calls later...\n[...]\n\ncurrent_ip = d.backtrace[0]\nreturn_addresse = d.backtrace[1]\nother_return_addresses = d.backtrace[2:]\n</code></pre> <p>Additionally, the field <code>saved_ip</code> of the Debugger or ThreadContext objects will contain the return address of the current function.</p>","boost":4},{"location":"quality_of_life/symbols/","title":"Symbol Resolution","text":"","boost":4},{"location":"quality_of_life/symbols/#symbol-resolution","title":"Symbol Resolution","text":"<p>As described in the memory access section, many functions in libdebug accept symbols as an alternative to actual addresses.</p> <p>C++ Demangling</p> <p>Reverse-engineering of C++ binaries can be a struggle. To help out, libdebug automatically demangles C++ symbols.</p>","boost":4},{"location":"quality_of_life/symbols/#symbol-resolution-levels","title":"Symbol Resolution Levels","text":"<p>With large binaries and libraries, parsing symbols can become an expensive operation. Because of this, libdebug offers the possibility of choosing among 6 levels of symbol resolution. To set the symbol resolution level, you can use the <code>sym_lvl</code> property of the <code>libcontext</code> module.</p> Level Description 0 Symbol resolution is disabled. 1 Parse the ELF symbol table (.symtab) and dynamic symbol table (.dynsym). 2 Parse the ELF DWARF. 3 Follow the external debug file link in the .gnu_debuglink and/or .gnu_debugaltlink sections. If the file is present in the system, read its .symtab and .dynsym. 4 Parse the external debug file DWARF, if the file exists in the system. 5 Download the external debug file using <code>debuginfod</code>. The file is cached in the default folder for <code>debuginfod</code>. <p>The default value is level 4.</p> <p>Example of setting the symbol resolution level</p> <pre><code>from libdebug import libcontext\n\nlibcontext.sym_lvl = 5\nd.breakpoint('main')\n</code></pre> <p>If you want to change the symbol resolution level temporarily, you can use a <code>with</code> statement along with the <code>tmp</code> method of the <code>libcontext</code> module.</p> <p>Example of temporary resolution level change</p> <pre><code>from libdebug import libcontext\n\nwith libcontext.tmp(sym_lvl = 5):\n    d.breakpoint('main')\n</code></pre>","boost":4},{"location":"quality_of_life/symbols/#symbol-search","title":"Symbol Search","text":"<p>The <code>symbols</code> attribute of the Debugger object allows you to search for symbols in the binary and shared libraries.</p> <p>Function Signature</p> <pre><code>d.symbols.find(value: int | str) -&gt; SymbolDict[str, set[Symbol]]:\n</code></pre> <p>Given a symbol name or address, this function returns a SymbolDict dictionary with the symbol name as the key and a set of Symbol objects as the value.</p> <p>These are the attributes of a Symbol object:</p> Attribute Type Description <code>start</code> <code>int</code> The start address of the symbol. <code>end</code> <code>int</code> The end address of the symbol. <code>name</code> <code>str</code> The name of the symbol. <code>backing_file</code> <code>str</code> The file where the symbol is defined (e.g., binary, libc, ld).","boost":4},{"location":"stopping_events/breakpoints/","title":"Breakpoints","text":"<p>Breakpoints are the killer feature of any debugger, the fundamental stopping event. They allow you to stop the execution of your code at a specific point and inspect the state of your program to find bugs or understand its design.</p> <p>Multithreading and Breakpoints</p> <p>libdebug breakpoints are shared across all threads. This means that if a breakpoint is hit in one thread, all threads will stop. You can use the <code>hit_on()</code> method of a breakpoint object to determine if a breakpoint was hit in a specific thread.</p> <p>A breakpoint can be inserted at any of two levels: software or hardware.</p>","boost":4},{"location":"stopping_events/breakpoints/#software-breakpoints","title":"Software Breakpoints","text":"<p>Software breakpoints in the Linux kernel are implemented by patching the code in memory at runtime. The instruction at the chosen address is replaced with an interrupt instruction that is conventionally used for debugging. For example, in the <code>i386</code> and <code>AMD64</code> instruction sets, <code>int3</code> (0xCC) is reserved for this purpose.</p> <p>When the <code>int3</code> instruction is executed, the CPU raises a <code>SIGTRAP</code> signal, which is caught by the debugger. The debugger then stops the process and restores the original instruction to its rightful place.</p> <p>Pros and Cons of Software Breakpoints</p> <p>Software breakpoints are unlimited, but they can break when the program uses self-modifying code. This is because the patched code could be overwritten by the program.</p>","boost":4},{"location":"stopping_events/breakpoints/#hardware-breakpoints","title":"Hardware Breakpoints","text":"<p>Hardware breakpoints are a more reliable way to set breakpoints. They are made possible by the existence of special registers in the CPU that can be used to monitor memory accesses. Differently from software breakpoints, their hardware counterparts allows the debugger to monitor read and write accesses on top of code execution. This kind of hardware breakpoint is also called a watchpoint. More information on watchpoints can be found in the dedicated documentation.</p> <p>Pros and Cons of Hardware Breakpoints</p> <p>Hardware breakpoints are not affected by self-modifying code. They are also faster and more flexible. However, hardware breakpoints are limited in number and are hardware-dependent, so their support may vary across different systems.</p>","boost":4},{"location":"stopping_events/breakpoints/#libdebug-api-for-breakpoints","title":"libdebug API for Breakpoints","text":"<p>The <code>breakpoint()</code> function in the Debugger object sets a breakpoint at a specific address.</p> <p>Function Signature</p> <pre><code>d.breakpoint(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')\n</code></pre> <p>Parameters:</p> Argument Type Description <code>position</code> <code>int</code> | <code>str</code> The address or symbol where the breakpoint will be set. <code>hardware</code> <code>bool</code> Set to <code>True</code> to set a hardware breakpoint. <code>condition</code> <code>str</code> The type of access in case of a hardware breakpoint. <code>length</code> <code>int</code> The size of the word being watched in case of a hardware breakpoint. <code>callback</code> <code>Callable</code> (see callback signature here) Used to create asyncronous breakpoints (read more on the debugging flow of stopping events). <code>file</code> <code>str</code> The backing file for relative addressing. Refer to the memory access section for more information on addressing modes. <p>Returns:</p> Return Type Description <code>Breakpoint</code> Breakpoint The breakpoint object created. <p>Limited Hardware Breakpoints</p> <p>Hardware breakpoints are limited in number. If you exceed the number of hardware breakpoints available on your system, a <code>RuntimeError</code> will be raised.</p> <p>Usage Example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\n\nd.run()\n\nbp = d.breakpoint(0x10ab) # (1)\n\nd.cont()\n\nprint(f\"RAX: {d.regs.rax} at the breakpoint\") # (2)\n</code></pre> <ol> <li>Set a software breakpoint at address 0x10ab relative to the program's base address</li> <li>Print the value of the RAX register when the breakpoint is hit</li> </ol>","boost":4},{"location":"stopping_events/breakpoints/#callback-signature","title":"Callback Signature","text":"<p>If you wish to create an asynchronous breakpoint, you will have to provide a callback function.</p> <p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, bp: Breakpoint) -&gt; None:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the breakpoint. <code>bp</code> Breakpoint The breakpoint object that triggered the callback. <p>Example usage of asynchronous breakpoints</p> <pre><code>def on_breakpoint_hit(t, bp):\n    print(f\"RAX: {t.regs.rax}\")\n\n    if bp.hit_count == 100:\n        print(\"Hit count reached 100\")\n        bp.disable()\n\nd.breakpoint(0x11f0, callback=on_breakpoint_hit)\n</code></pre>","boost":4},{"location":"stopping_events/debugging_flow/","title":"Debugging Flow of Stopping Events","text":"<p>Before diving into each libdebug stopping event, it's crucial to understand the debugging flow that these events introduce, based on the mode selected by the user.</p> <p>The flow of all stopping events is similar and adheres to a mostly uniform API structure. Upon placing a stopping event, the user is allowed to specify a callback function for the stopping event. If a callback is passed, the event will trigger asynchronously. Otherwise, if the callback is not passed, the event will be synchronous. The following flowchart shows the difference between the two flows.</p> Flowchart of different handling modes for stopping events <p>When a synchronous event is hit, the process will stop, awaiting further commands. When an asynchronous event is hit, libdebug temporarily stops the process and invokes the user callback. Process execution is automatically resumed right after.</p> <p>Tip: Use cases of asynchronous stopping events</p> <p>The asynchronous mode for stopping events is particularly useful for events being repeated as a result of a loop in the executed code.</p> <p>When attempting side-channel reverse engineering, this mode can save a lot of your time.</p>","boost":4},{"location":"stopping_events/debugging_flow/#types-of-stopping-events","title":"Types of Stopping Events","text":"<p>libdebug supports the following types of stopping events:</p> Event Type Description Notes Breakpoint Stops the process when a certain address is executed Can be a software or a hardware breakpoint Watchpoint Stops the process when a memory area is read, written or executed Alias for a hardware breakpoint Syscall Stops the process when a syscall is made Two events are supported: syscall start and end Signal Stops the process when a signal is received","boost":4},{"location":"stopping_events/debugging_flow/#common-apis-of-stopping-events","title":"Common APIs of Stopping Events","text":"<p>All libdebug stopping events share some common attributes that can be employed in debugging scripts.</p>","boost":4},{"location":"stopping_events/debugging_flow/#enabledisable","title":"Enable/Disable","text":"<p>All stopping events can be enabled or disabled at any time. You can read the <code>enabled</code> attribute to check the current state of the event. To enable or disable the event, you can call the <code>enable()</code> or <code>disable()</code> methods respectively.</p>","boost":4},{"location":"stopping_events/debugging_flow/#callback","title":"Callback","text":"<p>The callback function of the event can be set, changed or removed (set to <code>None</code>) at any time. Please be mindful of the event mode resulting from the change on the callback parameter, as explained here.</p>","boost":4},{"location":"stopping_events/debugging_flow/#hit-records","title":"Hit Records","text":"<p>Stopping events have attributes that can help you keep track of hits. For example, the <code>hit_count</code> attribute stores the number of times the event has been triggered.</p> <p>The <code>hit_on()</code> function is used to check if the stopping event was the cause of the process stopping. It is particularly useful when debugging multithreaded applications, as it takes a ThreadContext as a parameter. Refer to multithreading for more information.</p>","boost":4},{"location":"stopping_events/debugging_flow/#hijacking","title":"Hijacking","text":"<p>Hijacking is a powerful feature that allows you to change the flow of the process when a stopping event is hit. It is available for both syscalls and signals, but currently not for other stopping events. When registering an hijack for a compatible stopping event, that execution flow will be replaced with another.</p> Example hijacking of a SIGALRM to a SIGUSR1 <p>For example, in the case of a signal, you can specify that a received <code>SIGALRM</code> signal should be replaced with a <code>SIGUSR1</code> signal. This can be useful when you want to prevent a process from executing a certain code path. In fact, you can even use the hijack feature to \"NOP\" the syscall or signal altogether, avoiding it to be executed / forwarded to the processed. More information on how to use this feature in each stopping event can be found in their respective documentation.</p> <p>Hijacking Loop Detection</p> <p>When carelessly hijacking stopping events, it could happen that loops are created. libdebug automatically performs checks to avoid these situations and raises an exception if an infinite loop is detected.</p> <p>For example, the following code raises a <code>RuntimeError</code>:</p> <pre><code>handler = d.hijack_syscall(\"read\", \"write\")\nhandler = d.hijack_syscall(\"write\", \"read\")\n</code></pre>","boost":4},{"location":"stopping_events/debugging_flow/#recursion","title":"Recursion","text":"<p>Mixing asynchronous callbacks and hijacking can become messy. Because of this, libdebug provides users with the choice of whether to execute the callback for an event that was triggered by a hijack.</p> <p>This behavior is enabled by the parameter <code>recursive</code>, available when instantiating a syscall handler, a signal catcher, or their respective hijackers. By default, recursion is disabled.</p>","boost":4},{"location":"stopping_events/signals/","title":"Signals","text":"<p>Signals are a feature of POSIX systems like (e.g., the Linux kernel) that provide a mechanism for asynchronous communication between processes and the operating system. When certain events occur (e.g., hardware interrupts, illegal operations, or termination requests) the kernel can send a signal to a process to notify it of the event. Each signal is identified by a unique integer and corresponds to a specific type of event. For example, <code>SIGINT</code> (usually triggered by pressing <code>Ctrl+C</code>) is used to interrupt a process, while <code>SIGKILL</code> forcefully terminates a process without cleanup. </p> <p>Processes can handle these signals in different ways: they may catch and define custom behavior for certain signals, ignore them, or allow the default action to occur.</p> <p>Restrictions on Signal Catching</p> <p>libdebug does not support catching <code>SIGTRAP</code>, <code>SIGSTOP</code>, and <code>SIGKILL</code>. While the first is used internally for debugging purposes, the other two cannot be intercepted as a result of kernel limitations.</p> <p>libdebug allows you to intercept signals sent to the tracee. Specifically, you can choose to catch or hijack a specific signal (read more on hijacking).</p>","boost":4},{"location":"stopping_events/signals/#signal-catchers","title":"Signal Catchers","text":"<p>Signal catchers can be created to register stopping events for when a signal is received.</p> <p>Multiple catchers for the same signal</p> <p>Please note that there can be at most one user-defined catcher or hijack for each signal. If a new catcher is defined for a signal that is already caught or hijacked, the new catcher will replace the old one, and a warning will be printed.</p>","boost":4},{"location":"stopping_events/signals/#libdebug-api-for-signal-catching","title":"libdebug API for Signal Catching","text":"<p>The <code>catch_signal()</code> function in the Debugger object registers a catcher for the specified signal.</p> <p>Function Signature</p> <pre><code>d.catch_signal(signal, callback=None, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>signal</code> <code>int</code> | <code>str</code> The signal number or name to catch. <code>callback</code> <code>Callable</code> (see callback signature here) The callback function to be executed when the signal is received. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the catcher's callback will be executed even if the signal was triggered by a hijack. <p>Returns:</p> Return Type Description <code>SignalCatcher</code> SignalCatcher The catcher object created.","boost":4},{"location":"stopping_events/signals/#callback-signature","title":"Callback Signature","text":"<p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, catcher: SignalCatcher) -&gt; None:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that received the signal. <code>catcher</code> SignalCatcher The SignalCatcher object that triggered the callback. <p>Signals in multi-threaded applications</p> <p>In the Linux kernel, an incoming signal could be delivered to any thread in the process. Please do not assume that the signal will be delivered to a specific thread in your scripts.</p> <p>Example usage of asynchronous signal catchers</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\n# Define the callback function\ndef catcher_SIGUSR1(t, catcher):\n    t.signal = 0x0\n    print(\"Look mum, I'm catching a signal\")\n\ndef catcher_SIGINT(t, catcher):\n    print(\"Look mum, I'm catching another signal\")\n\n# Register the signal catchers\ncatcher1 = d.catch_signal(10, callback=catcher_SIGUSR1)\ncatcher2 = d.catch_signal('SIGINT', callback=catcher_SIGINT)\n\nd.cont()\n</code></pre> <p>Example of synchronous signal catching</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\ncatcher = d.catch_signal(10)\nd.cont()\n\nif catcher.hit_on(d):\n    print(\"Signal 10 was caught\")\n</code></pre> <p>The script above will print \"Signal 10 was entered\".</p>","boost":4},{"location":"stopping_events/signals/#hijacking","title":"Hijacking","text":"<p>When hijacking a signal, the user can provide an alternative signal to be executed in place of the original one. Internally, the hijack is implemented by registering a catcher for the signal and replacing the signal number with the new one.</p> <p>Function Signature</p> <pre><code>d.hijack_signal(original_signal, new_signal, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>original_signal</code> <code>int</code> | <code>str</code> The signal number or name to be hijacked. <code>new_signal</code> <code>int</code> | <code>str</code> The signal number or name to be delivered instead. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the catcher's callback will be executed even if the signal was dispached by a hijack. <p>Returns:</p> Return Type Description <code>SignalCatcher</code> SignalCatcher The catcher object created. <p>Example of hijacking a signal</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n\n// Handler for SIGALRM\nvoid handle_sigalrm(int sig) {\n    printf(\"You failed. Better luck next time\\n\");\n    exit(1);\n}\n\n// Handler for SIGUSR1\nvoid handle_sigusr1(int sig) {\n    printf(\"Congrats: flag{pr1nt_pr0vol4_1s_th3_w4y}\\n\");\n    exit(0);\n}\n\nint main() {\n    // Set up the SIGALRM handler\n    struct sigaction sa_alrm;\n    sa_alrm.sa_handler = handle_sigalrm;\n    sigemptyset(&amp;sa_alrm.sa_mask);\n    sa_alrm.sa_flags = 0;\n    sigaction(SIGALRM, &amp;sa_alrm, NULL);\n\n    // Set up the SIGUSR1 handler\n    struct sigaction sa_usr1;\n    sa_usr1.sa_handler = handle_sigusr1;\n    sigemptyset(&amp;sa_usr1.sa_mask);\n    sa_usr1.sa_flags = 0;\n    sigaction(SIGUSR1, &amp;sa_usr1, NULL);\n\n    // Set an alarm to go off after 10 seconds\n    alarm(10);\n\n    printf(\"Waiting for a signal...\\n\");\n\n    // Infinite loop, waiting for signals\n    while (1) {\n        pause(); // Suspend the program until a signal is caught\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.hijack_signal(\"SIGALRM\", \"SIGUSR1\")\n\nd.cont()\n\n# Will print \"Waiting for a signal...\"\nout = pipe.recvline()\nprint(out.decode())\n\nd.wait()\n\n# Will print the flag\nout = pipe.recvline()\nprint(out.decode())\n</code></pre>","boost":4},{"location":"stopping_events/signals/#signal-filtering","title":"Signal Filtering","text":"<p>Instead of setting a catcher on signals, you might want to filter which signals are not to be forwarded to the debugged process during execution.</p> <p>By default, all signals not related to libdebug internals are forwarded to the process. By contrast, <code>SIGSTOP</code> is never dispatched.</p> <p>Example of signal filtering</p> <pre><code>d.signals_to_block = [10, 15, 'SIGINT', 3, 13]\n</code></pre>","boost":4},{"location":"stopping_events/signals/#arbitrary-signals","title":"Arbitrary Signals","text":"<p>You can also send an arbitrary signal to the process. The signal will be forwarded upon resuming execution. As always, you can specify the signal number or name.</p> <p>Example of sending an arbitrary signal</p> <pre><code>d.signal = 10\nd.cont()\n</code></pre> <p>In multithreaded applications, the same syntax applies when using a ThreadContext object instead of the Debugger object.</p>","boost":4},{"location":"stopping_events/stopping_events/","title":"Stopping Events","text":"<p>Debugging a process involves stopping the execution at specific points to inspect the state of the program. libdebug provides several ways to stop the execution of a program, such as breakpoints, syscalls and signals. This section covers the different stopping events available in libdebug.</p>","boost":4},{"location":"stopping_events/stopping_events/#is-the-process-running","title":"Is the process running?","text":"<p>Before we dive into the different stopping events, it is important to understand how to check if the process is running. The <code>running</code> attribute of the Debugger object returns <code>True</code> if the process is running and <code>False</code> otherwise.</p> <p>Example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\n\nd.run()\n\nif d.running:\n    print(\"The process is running\")\nelse:\n    print(\"The process is not running\")\n</code></pre> <p>In this example, the script should print <code>The process is not running</code>, since the <code>run()</code> command gives you control over a stopped process, ready to be debugged.</p> <p>To know more on how to wait for the process to stop or forcibly cause it to stop, please read about control flow commands.</p>","boost":4},{"location":"stopping_events/syscalls/","title":"Syscalls","text":"<p>System calls (a.k.a. syscalls or software interrupts) are the interface between user space and kernel space. They are used to request services from the kernel, such as reading from a file or creating a new process. libdebug allows you to trace syscalls invoked by the debugged program. Specifically, you can choose to handle or hijack a specific syscall (read more on hijacking).</p>","boost":4},{"location":"stopping_events/syscalls/#syscall-handlers","title":"Syscall Handlers","text":"<p>Syscall handlers can be created to register stopping events for when a syscall is entered and exited.</p> <p>Do I have to handle both on enter and on exit?</p> <p>When using asynchronous syscall handlers, you can choose to handle both or only one of the two events. However, when using synchronous handlers, both events will stop the process.</p> <p>Multiple handlers for the same syscall</p> <p>Please note that there can be at most one user-defined handler or hijack for each syscall. If a new handler is defined for a syscall that is already handled or hijacked, the new handler will replace the old one, and a warning will be printed.</p>","boost":4},{"location":"stopping_events/syscalls/#libdebug-api-for-syscall-handlers","title":"libdebug API for Syscall Handlers","text":"<p>The <code>handle_syscall()</code> function in the Debugger object registers a handler for the specified syscall.</p> <p>Function Signature</p> <pre><code>d.handle_syscall(syscall, on_enter=None, on_exit=None, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be handled. <code>on_enter</code> <code>Callable</code> (see callback signature here) The callback function to be executed when the syscall is entered. <code>on_exit</code> <code>Callable</code> (see callback signature here) The callback function to be executed when the syscall is exited. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the handler's callback will be executed even if the syscall was triggered by a hijack. <p>Returns:</p> Return Type Description <code>SyscallHandler</code> SyscallHandler The handler object created.","boost":4},{"location":"stopping_events/syscalls/#callback-signature","title":"Callback Signature","text":"<p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, handler: HandledSyscall) -&gt; None:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the syscall. <code>handler</code> SyscallHandler The SyscallHandler object that triggered the callback. <p>Nuances of Syscall Handling</p> <p>The syscall handler is the only stopping event that can be triggered by the same syscall twice in a row. This is because the handler is triggered both when the syscall is entered and when it is exited. As a result the <code>hit_on()</code> function does not exist in the SyscallHandler object.</p> <p>Instead, you can use the <code>hit_on_enter()</code> and <code>hit_on_exit()</code> functions to check if cause of the process stop was the syscall entering or exiting, respectively.</p> <p>As for the <code>hit_count</code> attribute, it stores the number of times the syscall was exited.</p> <p>Example usage of asynchronous syscall handlers</p> <pre><code>def on_enter_open(t: ThreadContext, handler: SyscallHandler):\n    print(\"entering open\")\n    t.syscall_arg0 = 0x1\n\ndef on_exit_open(t: ThreadContext, handler: SyscallHandler):\n    print(\"exiting open\")\n    t.syscall_return = 0x0\n\nhandler = d.handle_syscall(syscall=\"open\", on_enter=on_enter_open, on_exit=on_exit_open)\n</code></pre> <p>Example of synchronous syscall handling</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.handle_syscall(syscall=\"open\")\nd.cont()\n\nif handler.hit_on_enter(d):\n    print(\"open syscall was entered\")\nelif handler.hit_on_exit(d):\n    print(\"open syscall was exited\")\n</code></pre> <p>The script above will print \"open syscall was entered\".</p>","boost":4},{"location":"stopping_events/syscalls/#resolution-of-syscall-numbers","title":"Resolution of Syscall Numbers","text":"<p>Syscall handlers can be created with the identifier number of the syscall or by the syscall's common name. In the second case, syscall names are resolved from a definition list for Linux syscalls on the target architecture. The list is fetched from mebeim's syscall table. We thank him for hosting such a precious resource. Once downloaded, the list cached internally. </p>","boost":4},{"location":"stopping_events/syscalls/#hijacking","title":"Hijacking","text":"<p>When hijacking a syscall, the user can provide an alternative syscall to be executed in place of the original one. Internally, the hijack is implemented by registering a handler for the syscall and replacing the syscall number with the new one.</p> <p>Function Signature</p> <pre><code>d.hijack_syscall(original_syscall, new_syscall, recursive=False, **kwargs) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>original_syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be hijacked. <code>new_syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be executed instead. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the handler's callback will be executed even if the syscall was triggered by a hijack. <code>**kwargs</code> <code>(int, optional)</code> Additional arguments to be passed to the new syscall. <p>Returns:</p> Return Type Description <code>SyscallHandler</code> SyscallHandler The handler object created. <p>Example of hijacking a syscall</p> <pre><code>#include &lt;unistd.h&gt;\n\nchar secretBuffer[32] = \"The password is 12345678\";\n\nint main(int argc, char** argv)\n{\n    [...]\n\n    read(0, secretBuffer, 31);\n\n    [...]\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.hijack_syscall(\"read\", \"write\")\n\nd.cont()\nd.wait()\n\nout = pipe.recvline()\nprint(out.decode())\n</code></pre> <p> In this case, the secret will be leaked to the standard output instead of being overwritten with content from the standard input.</p> <p>For your convenience, you can also easily provide the syscall parameters to be used when the hijacked syscall is executed:</p> <p>Example of hijacking a syscall with parameters</p> <pre><code>#include &lt;unistd.h&gt;\n\nchar manufacturerName[32] = \"libdebug\";\nchar secretKey[32] = \"provola\";\n\nint main(int argc, char** argv)\n{\n    [...]\n\n    read(0, manufacturerName, 31);\n\n    [...]\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nmanufacturerBuffer = [...]\n\nhandler = d.hijack_syscall(\"read\", \"write\",\n    syscall_arg0=0x1,\n    syscall_arg1=manufacturerBuffer,\n    syscall_arg2=0x100\n)\n\nd.cont()\nd.wait()\n\nout = pipe.recvline()\nprint(out.decode())\n</code></pre> <p>Again, the secret will be leaked to the standard output.</p>","boost":4},{"location":"stopping_events/watchpoints/","title":"Watchpoints","text":"<p>Watchpoints are a special type of hardware breakpoint that triggers when a specific memory location is accessed. You can set a watchpoint to trigger on certain memory access conditions, or upon execution (equivalent to a hardware breakpoint).</p> <p>Features of watchpoints are shared with breakpoints, so you can set asynchronous watchpoints and use properties in the same way.</p>","boost":4},{"location":"stopping_events/watchpoints/#libdebug-api-for-watchpoints","title":"libdebug API for Watchpoints","text":"<p>The <code>watchpoint()</code> function in the Debugger object sets a watchpoint at a specific address. While you can also use the breakpoint API to set up a watchpoint, a specific API is provided for your convenience:</p> <p>Function Signature</p> <pre><code>d.watchpoint(position, condition='w', length=1, callback=None, file='hybrid') \n</code></pre> <p>Parameters:</p> Argument Type Description <code>position</code> <code>int</code> | <code>str</code> The address or symbol where the watchpoint will be set. <code>condition</code> <code>str</code> The type of access (see later section). <code>length</code> <code>int</code> The size of the word being watched (see later section). <code>callback</code> <code>Callable</code> (see callback signature here) Used to create asyncronous watchpoints (read more on the debugging flow of stopping events). <code>file</code> <code>str</code> The backing file for relative addressing. Refer to the memory access section for more information on addressing modes. <p>Returns:</p> Return Type Description <code>Breakpoint</code> Breakpoint The breakpoint object created.","boost":4},{"location":"stopping_events/watchpoints/#valid-access-conditions","title":"Valid Access Conditions","text":"<p>The <code>condition</code> parameter specifies the type of access that triggers the watchpoint. Default is write access.</p> Condition Description Supported Architectures <code>\"r\"</code> Read access AArch64 <code>\"w\"</code> Write access AMD64, AArch64 <code>\"rw\"</code> Read/write access AMD64, AArch64 <code>\"x\"</code> Execute access AMD64","boost":4},{"location":"stopping_events/watchpoints/#valid-word-lengths","title":"Valid Word Lengths","text":"<p>The <code>length</code> parameter specifies the size of the word being watched. By default, the watchpoint is set to watch a single byte.</p> Architecture Supported Lengths AMD64 1, 2, 4, 8 AArch64 Any length from 1 to 8 bytes","boost":4},{"location":"stopping_events/watchpoints/#callback-signature","title":"Callback Signature","text":"<p>If you wish to create an asynchronous watchpoint, you will have to provide a callback function. Since internally watchpoints are implemented as hardware breakpoints, the callback signature is the same as for breakpoints.</p> <p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, bp: Breakpoint) -&gt; None:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the breakpoint. <code>bp</code> Breakpoint The breakpoint object that triggered the callback. <p>Example usage of asynchronous watchpoints</p> <pre><code>def on_watchpoint_hit(t, bp):\n    print(f\"RAX: {t.regs.rax}\")\n\n    if bp.hit_count == 100:\n        print(\"Hit count reached 100\")\n        bp.disable()\n\nd.watchpoint(0x11f0, condition=\"rw\", length=8, callback=on_watchpoint_hit)\n</code></pre>","boost":4}]}